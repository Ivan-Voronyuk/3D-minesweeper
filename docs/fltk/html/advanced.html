<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: Advanced FLTK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">FLTK Programming Manual</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Advanced FLTK</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This chapter explains advanced programming and design topics that will help you to get the most out of FLTK.</p>
<h1><a class="anchor" id="advanced_multithreading"></a>
Multithreading</h1>
<p>FLTK can be used to implement a GUI for a multithreaded application but, as with multithreaded programming generally, there are some concepts and caveats that must be kept in mind.</p>
<p>Key amongst these is that, for many of the target platforms on which FLTK is supported, only the <code>main()</code> thread of the process is permitted to handle system events, create or destroy windows and open or close windows. Further, only the <code>main()</code> thread of the process can safely write to the display.</p>
<p>To support this in a portable way, all FLTK <code>draw()</code> methods are executed in the <code>main()</code> thread. A worker thread may update the state of an existing widget, but it may not do any rendering directly, nor create or destroy a window. (<b>NOTE:</b> A special case exists for Fl_Gl_Window where it can, with suitable precautions, be possible to safely render to an existing GL context from a worker thread.)</p>
<h3>Creating portable threads</h3>
<p>We do not provide a threading interface as part of the library. A simple example showing how threads can be implemented, for all supported platforms, can be found in <code><a class="el" href="threads_8h_source.html">test/threads.h</a></code> and <code>test/threads.cxx</code>.</p>
<p>FLTK has been used with a variety of thread interfaces, so if the simple example shown in <code>test/threads.cxx</code> does not cover your needs, you might want to select a third-party library that provides the features you require.</p>
<h1><a class="anchor" id="advanced_multithreading_lock"></a>
FLTK multithread locking - Fl::lock() and Fl::unlock()</h1>
<p>In a multithreaded program, drawing of widgets (in the <code>main()</code> thread) happens asynchronously to widgets being updated by worker threads, so no drawing can occur safely whilst a widget is being modified (and no widget should be modified whilst drawing is in progress).</p>
<p>FLTK supports multithreaded applications using a locking mechanism internally. This allows a worker thread to lock the rendering context, preventing any drawing from taking place, whilst it changes the value of its widget.</p>
<dl class="section note"><dt>Note</dt><dd>The converse is also true; whilst a worker thread holds the lock, the <code>main()</code> thread may not be able to process any drawing requests, nor service any events. So a worker thread that holds the FLTK lock <b>must</b> contrive to do so for the shortest time possible or it could impair operation of the application.</dd></dl>
<p>The lock operates broadly as follows.</p>
<p>Using the FLTK library, the <code>main()</code> thread holds the lock whenever it is processing events or redrawing the display. It acquires (locks) and releases (unlocks) the FLTK lock automatically and no "user intervention" is required. Indeed, a function that runs in the context of the <code>main()</code> thread ideally should <b>not</b> acquire / release the FLTK lock explicitly. (Though note that the lock calls are recursive, so calling Fl::lock() from a thread that already holds the lock, including the <code>main()</code> thread, is benign. The only constraint is that every call to Fl::lock() <b>must</b> be balanced by a corresponding call to Fl::unlock() to ensure the lock count is preserved.)</p>
<p>The <code>main()</code> thread <b>must</b> call Fl::lock() <b>once</b> before any windows are shown, to enable the internal lock (it is "off" by default since it is not useful in single-threaded applications) but thereafter the <code>main()</code> thread lock is managed by the library internally.</p>
<p>A worker thread, when it wants to alter the value of a widget, can acquire the lock using Fl::lock(), update the widget, then release the lock using Fl::unlock(). Acquiring the lock ensures that the worker thread can update the widget, without any risk that the <code>main()</code> thread will attempt to redraw the widget whilst it is being updated.</p>
<p>Note that acquiring the lock is a blocking action; the worker thread will stall for as long as it takes to acquire the lock. If the <code>main()</code> thread is engaged in some complex drawing operation this may block the worker thread for a long time, effectively serializing what ought to be parallel operations. (This frequently comes as a surprise to coders less familiar with multithreaded programming issues; see the discussion of "lockless programming" later for strategies for managing this.)</p>
<p>To incorporate the locking mechanism in the library, FLTK must be compiled with <code>--enable-threads</code> set during the <code>configure</code> process. IDE-based versions of FLTK are automatically compiled with the locking mechanism incorporated if possible. Since version 1.3, the <code>configure</code> script that builds the FLTK library also sets <code>--enable-threads</code> by default.</p>
<h1><a class="anchor" id="advanced_multithreading_lock_example"></a>
Simple multithreaded examples using Fl::lock</h1>
<p>In <code>main()</code>, call Fl::lock() once before Fl::run() or Fl::wait() to enable the lock and start the runtime multithreading support for your program. All callbacks and derived functions like <code>handle()</code> and <code>draw()</code> will now be properly locked.</p>
<p>This might look something like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="comment">/* Create your windows and widgets here */</span></div>
<div class="line"> </div>
<div class="line">  Fl::lock(); <span class="comment">/* &quot;start&quot; the FLTK lock mechanism */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* show your window */</span></div>
<div class="line">  main_win-&gt;show(argc, argv);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* start your worker threads */</span></div>
<div class="line">  ... start threads ...</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Run the FLTK main loop */</span></div>
<div class="line">  <span class="keywordtype">int</span> result = Fl::run();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* terminate any pending worker threads */</span></div>
<div class="line">  ... stop threads ...</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can start as many threads as you like. From within a thread (other than the <code>main()</code> thread) FLTK calls must be wrapped with calls to Fl::lock() and Fl::unlock():</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_thread(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keywordflow">while</span> (thread_still_running) {</div>
<div class="line">    <span class="comment">/* do thread work */</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">/* compute new values for widgets */</span></div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    Fl::lock();      <span class="comment">// acquire the lock</span></div>
<div class="line">    my_widget-&gt;update(values);</div>
<div class="line">    Fl::unlock();    <span class="comment">// release the lock; allow other threads to access FLTK again</span></div>
<div class="line">    Fl::awake();     <span class="comment">// use Fl::awake() to signal main thread to refresh the GUI</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>To trigger a refresh of the GUI from a worker thread, the worker code should call Fl::awake()</dd></dl>
<h3>Using Fl::awake thread messages</h3>
<p>You can send messages from worker threads to the <code>main()</code> thread using Fl::awake(void* message). If using this thread message interface, your <code>main()</code> might look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="comment">/* Create your windows and widgets here */</span></div>
<div class="line"> </div>
<div class="line">  Fl::lock(); <span class="comment">/* &quot;start&quot; the FLTK lock mechanism */</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* show your window */</span></div>
<div class="line">  main_win-&gt;show(argc, argv);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* start your worker threads */</span></div>
<div class="line">  ... start threads ...</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Run the FLTK loop and process thread messages */</span></div>
<div class="line">  <span class="keywordflow">while</span> (Fl::wait() &gt; 0) {</div>
<div class="line">    <span class="keywordflow">if</span> ((next_message = Fl::thread_message()) != NULL) {</div>
<div class="line">      <span class="comment">/* process your data, update widgets, etc. */</span></div>
<div class="line">      ...</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* terminate any pending worker threads */</span></div>
<div class="line">  ... stop threads ...</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Your worker threads can send messages to the <code>main()</code> thread using Fl::awake(void* message):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *msg;       <span class="comment">// &quot;msg&quot; is a pointer to your message</span></div>
<div class="line">Fl::awake(msg);  <span class="comment">// send &quot;msg&quot; to main thread</span></div>
</div><!-- fragment --><p>A message can be anything you like. The <code>main()</code> thread can retrieve the message by calling Fl::thread_message().</p>
<h3>Using Fl::awake callback messages</h3>
<p>You can also request that the <code>main()</code> thread call a function on behalf of the worker thread by using Fl::awake(Fl_Awake_Handler cb, void* userdata).</p>
<p>The <code>main()</code> thread will execute the callback "as soon as possible" when next processing the pending events. This can be used by a worker thread to perform operations (for example showing or hiding windows) that are prohibited in a worker thread.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> do_something_cb(<span class="keywordtype">void</span> *userdata) {</div>
<div class="line">  <span class="comment">// Will run in the context of the main thread</span></div>
<div class="line">  ... do_stuff ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// running in worker thread</span></div>
<div class="line"><span class="keywordtype">void</span> *data;                       <span class="comment">// &quot;data&quot; is a pointer to your user data</span></div>
<div class="line">Fl::awake(do_something_cb, data); <span class="comment">// call to execute cb in main thread</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The <code>main()</code> thread will execute the Fl_Awake_Handler callback <code>do_something_cb</code> asynchronously to the worker thread, at some short but indeterminate time after the worker thread registers the request. When it executes the Fl_Awake_Handler callback, the <code>main()</code> thread will use the contents of <code>*userdata</code> <b>at</b> <b>the</b> <b>time</b> <b>of</b> <b>execution</b>, not necessarily the contents that <code>*userdata</code> had at the time that the worker thread posted the callback request. The worker thread should therefore contrive <b>not</b> to alter the contents of <code>*userdata</code> once it posts the callback, since the worker thread does not know when the <code>main()</code> thread will consume that data. It is often useful that <code>userdata</code> point to a struct, one member of which the <code>main()</code> thread can modify to indicate that it has consumed the data, thereby allowing the worker thread to re-use or update <code>userdata</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The mechanisms used to deliver Fl::awake(void* message) and Fl::awake(Fl_Awake_Handler cb, void* userdata) events to the <code>main()</code> thread can interact in unexpected ways on some platforms. Therefore, for reliable operation, it is advised that a program use either Fl::awake(Fl_Awake_Handler cb, void* userdata) or Fl::awake(void* message), but that they never be intermixed. Calling Fl::awake() with no parameters should be safe in either case. </dd></dl>
<dl class="section user"><dt></dt><dd>If you have to choose between using the Fl::awake(void* message) and Fl::awake(Fl_Awake_Handler cb, void* userdata) mechanisms and don't know which to choose, then try the Fl::awake(Fl_Awake_Handler cb, void* userdata) method first as it tends to be more powerful in general.</dd></dl>
<h1><a class="anchor" id="advanced_multithreading_lockless"></a>
FLTK multithreaded "lockless programming"</h1>
<p>The simple multithreaded examples shown above, using the FLTK lock, work well for many cases where multiple threads are required. However, when that model is extended to more complex programs, it often produces results that the developer did not anticipate.</p>
<p>A typical case might go something like this. A developer creates a program to process a huge data set. The program has a <code>main()</code> thread and 7 worker threads and is targeted to run on an 8-core computer. When it runs, the program divides the data between the 7 worker threads, and as they process their share of the data, each thread updates its portion of the GUI with the results, locking and unlocking as they do so.</p>
<p>But when this program runs, it is much slower than expected and the developer finds that only one of the eight CPU cores seems to be utilised, despite there being 8 threads in the program. What happened?</p>
<p>The threads in the program all run as expected, but they end up being serialized (that is, not able to run in parallel) because they all depend on the single FLTK lock. Acquiring (and releasing) that lock has an associated cost, and is a <b>blocking</b> action if the lock is already held by any other worker thread or by the <code>main()</code> thread.</p>
<p>If the worker threads are acquiring the lock "too often", then the lock will <b>always</b> be held <b>somewhere</b> and every attempt by any other thread (even <code>main()</code>) to lock will cause that other thread (including <code>main()</code>) to block. And blocking <code>main()</code> also blocks event handling, display refresh...</p>
<p>As a result, only one thread will be running at any given time, and the multithreaded program is effectively reduced to being a (complicated and somewhat less efficient) single thread program.</p>
<p>A "solution" is for the worker threads to lock "less often", such that they do not block each other or the <code>main()</code> thread. But judging what constitutes locking "too often" for any given configuration, and hence will block, is a very tricky question. What works well on one machine, with a given graphics card and CPU configuration may behave very differently on another target machine.</p>
<p>There are "interesting" variations on this theme, too: for example it is possible that a "faulty" multithreaded program such as described above will work adequately on a single-core machine (where all threads are inherently serialized anyway and so are less likely to block each other) but then stall or even deadlock in unexpected ways on a multicore machine when the threads do interfere with each other. (I have seen this - it really happens.)</p>
<p>The "better" solution is to avoid using the FLTK lock so far as possible. Instead, the code should be designed so that the worker threads do not update the GUI themselves and therefore never need to acquire the FLTK lock. This would be FLTK multithreaded "lockless programming".</p>
<p>There are a number of ways this can be achieved (or at least approximated) in practice but the most direct approach is for the worker threads to make use of the Fl::awake(Fl_Awake_Handler cb, void* userdata) method so that GUI updates can all run in the context of the <code>main()</code> thread, alleviating the need for the worker thread to ever lock. The onus is then on the worker threads to manage the <code>userdata</code> so that it is delivered safely to the <code>main()</code> thread, but there are many ways that can be done.</p>
<dl class="section note"><dt>Note</dt><dd>Using Fl::awake is not, strictly speaking, entirely "lockless" since the awake handler mechanism incorporates resource locking internally to protect the queue of pending awake messages. These resource locks are held transiently and generally do not trigger the pathological blocking issues described here.</dd></dl>
<p>However, aside from using Fl::awake, there are many other ways that a "lockless" design can be implemented, including message passing, various forms of IPC, etc.</p>
<p>If you need high performing multithreaded programming, then take some time to study the options and understand the advantages and disadvantages of each; we can't even begin to scratch the surface of this huge topic here!</p>
<p>And of course occasional, sparse, use of the FLTK lock from worker threads will do no harm; it is "excessive" locking (whatever that might be) that triggers the failing behaviour.</p>
<p>It is always a Good Idea to update the GUI at the lowest rate that is acceptable when processing bulk data (or indeed, in all cases!) Updating at a few frames per second is probably adequate for providing feedback during a long calculation. At the upper limit, anything faster than the frame rate of your monitor and the updates will never even be displayed; why waste CPU computing pixels that you will never show?</p>
<h1><a class="anchor" id="advanced_multithreading_caveats"></a>
FLTK multithreaded Constraints</h1>
<p>FLTK supports multiple platforms, some of which allow only the <code>main()</code> thread to handle system events and open or close windows. The safe thing to do is to adhere to the following rules for threads on all operating systems:</p>
<ul>
<li>Don't <code>show()</code> or <code>hide()</code> anything that contains Fl_Window based widgets from a worker thread. This includes any windows, dialogs, file choosers, subwindows or widgets using Fl_Gl_Window. Note that this constraint also applies to non-window widgets that have tooltips, since the tooltip will contain a Fl_Window object. The safe and portable approach is <b>never</b> to call <code>show()</code> or <code>hide()</code> on any widget from the context of a worker thread. Instead you can use the Fl_Awake_Handler variant of Fl::awake() to request the <code>main()</code> thread to create, destroy, show or hide the widget on behalf of the worker thread.</li>
</ul>
<ul>
<li>Don't call Fl::run(), Fl::wait(), Fl::flush(), Fl::check() or any related methods that will handle system messages from a worker thread</li>
</ul>
<ul>
<li>Don't intermix use of Fl::awake(Fl_Awake_Handler cb, void* userdata) and Fl::awake(void* message) calls in the same program as they may interact unpredictably on some platforms; choose one or other style of Fl::awake(&lt;thing&gt;) mechanism and use that. (Intermixing calls to Fl::awake() should be safe with either however.)</li>
</ul>
<ul>
<li>Starting with FLTK 1.4, it's possible to start (or cancel) a timer from a worker thread under the condition that the call to Fl::add_timeout (or Fl::remove_timeout) is wrapped in Fl::lock() and Fl::unlock().</li>
</ul>
<ul>
<li>Don't change window decorations or titles from a worker thread</li>
</ul>
<ul>
<li>The <code>make_current()</code> method will probably not work well for regular windows, but should always work for a Fl_Gl_Window to allow for high speed rendering on graphics cards with multiple pipelines. Managing thread-safe access to the GL pipelines is left as an exercise for the reader! (And may be target specific...)</li>
</ul>
<p>See also: Fl::lock(), Fl::unlock(), Fl::awake(), Fl::awake(Fl_Awake_Handler cb, void* userdata), Fl::awake(void* message), Fl::thread_message().</p>
<p> 
<hr>
<table summary="navigation bar" width="100%" border="0">
<tr>
  <td width="45%" align="LEFT">
    <a class="el" href="fltk-options.html">
    [Prev]
    FLTK Runtime Options
    </a>
  </td>
  <td width="10%" align="CENTER">
    <a class="el" href="index.html">[Index]</a>
  </td>
  <td width="45%" align="RIGHT">
    <a class="el" href="unicode.html">
    Unicode and UTF-8 Support
    [Next]
    </a>
  </td>
</tr>
</table>
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

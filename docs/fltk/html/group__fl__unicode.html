<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: Fl_unicode</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Fl_unicode</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga23a9fbc8aa65df748b38e4a9ffdb737d" id="r_ga23a9fbc8aa65df748b38e4a9ffdb737d"><td class="memItemLeft" align="right" valign="top"><a id="ga23a9fbc8aa65df748b38e4a9ffdb737d" name="ga23a9fbc8aa65df748b38e4a9ffdb737d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NBC</b>&#160;&#160;&#160;0xFFFF + 1</td></tr>
<tr class="separator:ga23a9fbc8aa65df748b38e4a9ffdb737d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab32b33e9780bd5daf6b837ad05dda081" id="r_gab32b33e9780bd5daf6b837ad05dda081"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gab32b33e9780bd5daf6b837ad05dda081">ERRORS_TO_ISO8859_1</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gab32b33e9780bd5daf6b837ad05dda081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a884ca5383ac1a607c60a4b32757299" id="r_ga3a884ca5383ac1a607c60a4b32757299"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga3a884ca5383ac1a607c60a4b32757299">ERRORS_TO_CP1252</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga3a884ca5383ac1a607c60a4b32757299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39777a7d175212740aba2b63068d799" id="r_gad39777a7d175212740aba2b63068d799"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gad39777a7d175212740aba2b63068d799">STRICT_RFC3629</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gad39777a7d175212740aba2b63068d799"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3e25d5c315ce7f0acf87c3662e331468" id="r_ga3e25d5c315ce7f0acf87c3662e331468"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga3e25d5c315ce7f0acf87c3662e331468">fl_utf8bytes</a> (unsigned ucs)</td></tr>
<tr class="separator:ga3e25d5c315ce7f0acf87c3662e331468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eedf721bef934868002eb94d247d834" id="r_ga3eedf721bef934868002eb94d247d834"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga3eedf721bef934868002eb94d247d834">fl_utf8len</a> (char c)</td></tr>
<tr class="separator:ga3eedf721bef934868002eb94d247d834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf739852beaf3dacf039fdc0b1f289a5a" id="r_gaf739852beaf3dacf039fdc0b1f289a5a"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gaf739852beaf3dacf039fdc0b1f289a5a">fl_utf8len1</a> (char c)</td></tr>
<tr class="separator:gaf739852beaf3dacf039fdc0b1f289a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a19fe8946a1272ede63709516a03a37" id="r_ga3a19fe8946a1272ede63709516a03a37"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga3a19fe8946a1272ede63709516a03a37">fl_utf8strlen</a> (const char *text, int len)</td></tr>
<tr class="separator:ga3a19fe8946a1272ede63709516a03a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5ccdf22c2cb46125cc9a152542e63b" id="r_gaff5ccdf22c2cb46125cc9a152542e63b"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gaff5ccdf22c2cb46125cc9a152542e63b">fl_utf_nb_char</a> (const unsigned char *buf, int len)</td></tr>
<tr class="separator:gaff5ccdf22c2cb46125cc9a152542e63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80ac8abaa3ed7b8c245447d6b3aab95" id="r_gad80ac8abaa3ed7b8c245447d6b3aab95"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode</a> (const char *p, const char *end, int *len)</td></tr>
<tr class="separator:gad80ac8abaa3ed7b8c245447d6b3aab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae608a28bc43f10014343483ed3d5e99c" id="r_gae608a28bc43f10014343483ed3d5e99c"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gae608a28bc43f10014343483ed3d5e99c">fl_utf8encode</a> (unsigned ucs, char *buf)</td></tr>
<tr class="separator:gae608a28bc43f10014343483ed3d5e99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881af6d9537e0aadb1ab7ab3f35bd3bc" id="r_ga881af6d9537e0aadb1ab7ab3f35bd3bc"><td class="memItemLeft" align="right" valign="top">FL_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga881af6d9537e0aadb1ab7ab3f35bd3bc">fl_utf8fwd</a> (const char *p, const char *start, const char *end)</td></tr>
<tr class="separator:ga881af6d9537e0aadb1ab7ab3f35bd3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad28ab9ec404eed36008de0ddcf95db0f" id="r_gad28ab9ec404eed36008de0ddcf95db0f"><td class="memItemLeft" align="right" valign="top">FL_EXPORT const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gad28ab9ec404eed36008de0ddcf95db0f">fl_utf8back</a> (const char *p, const char *start, const char *end)</td></tr>
<tr class="separator:gad28ab9ec404eed36008de0ddcf95db0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda1ae7fbd7f38a12a7e390dd847020b" id="r_gadda1ae7fbd7f38a12a7e390dd847020b"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gadda1ae7fbd7f38a12a7e390dd847020b">fl_ucs_to_Utf16</a> (const unsigned ucs, unsigned short *dst, const unsigned dstlen)</td></tr>
<tr class="separator:gadda1ae7fbd7f38a12a7e390dd847020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b537f15e29c1eb78bee7c24483dc759" id="r_ga6b537f15e29c1eb78bee7c24483dc759"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga6b537f15e29c1eb78bee7c24483dc759">fl_utf8toUtf16</a> (const char *src, unsigned srclen, unsigned short *dst, unsigned dstlen)</td></tr>
<tr class="separator:ga6b537f15e29c1eb78bee7c24483dc759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac483f43232e4444086487d3417236209" id="r_gac483f43232e4444086487d3417236209"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gac483f43232e4444086487d3417236209">fl_utf8towc</a> (const char *src, unsigned srclen, wchar_t *dst, unsigned dstlen)</td></tr>
<tr class="separator:gac483f43232e4444086487d3417236209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a6296024debb49690b81addda7589b" id="r_ga56a6296024debb49690b81addda7589b"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga56a6296024debb49690b81addda7589b">fl_utf8fromwc</a> (char *dst, unsigned dstlen, const wchar_t *src, unsigned srclen)</td></tr>
<tr class="separator:ga56a6296024debb49690b81addda7589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12eec84f8d118aac87eaabaedfcd4154" id="r_ga12eec84f8d118aac87eaabaedfcd4154"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga12eec84f8d118aac87eaabaedfcd4154">fl_utf8toa</a> (const char *src, unsigned srclen, char *dst, unsigned dstlen)</td></tr>
<tr class="separator:ga12eec84f8d118aac87eaabaedfcd4154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae652006e11dcea72e9ae23e8fb606ff1" id="r_gae652006e11dcea72e9ae23e8fb606ff1"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gae652006e11dcea72e9ae23e8fb606ff1">fl_utf8froma</a> (char *dst, unsigned dstlen, const char *src, unsigned srclen)</td></tr>
<tr class="separator:gae652006e11dcea72e9ae23e8fb606ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c212b970de7dde3cac0b6d49f9d3c4f" id="r_ga6c212b970de7dde3cac0b6d49f9d3c4f"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga6c212b970de7dde3cac0b6d49f9d3c4f">fl_utf8locale</a> (void)</td></tr>
<tr class="separator:ga6c212b970de7dde3cac0b6d49f9d3c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db7a23fb75a6a76d3118704806918ea" id="r_ga9db7a23fb75a6a76d3118704806918ea"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga9db7a23fb75a6a76d3118704806918ea">fl_utf8test</a> (const char *src, unsigned len)</td></tr>
<tr class="separator:ga9db7a23fb75a6a76d3118704806918ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86f3c69d9e3e7b3bdc348211e4a8b7de" id="r_ga86f3c69d9e3e7b3bdc348211e4a8b7de"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga86f3c69d9e3e7b3bdc348211e4a8b7de">fl_wcwidth_</a> (unsigned int ucs)</td></tr>
<tr class="separator:ga86f3c69d9e3e7b3bdc348211e4a8b7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga434459dcb7e07a747350403dc9ddca8c" id="r_ga434459dcb7e07a747350403dc9ddca8c"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga434459dcb7e07a747350403dc9ddca8c">fl_wcwidth</a> (const char *src)</td></tr>
<tr class="separator:ga434459dcb7e07a747350403dc9ddca8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75d310d956bedf6129c5ef6c1e868a8f" id="r_ga75d310d956bedf6129c5ef6c1e868a8f"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga75d310d956bedf6129c5ef6c1e868a8f">fl_nonspacing</a> (unsigned int ucs)</td></tr>
<tr class="separator:ga75d310d956bedf6129c5ef6c1e868a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7140599647f4494b4c636e87cf9083b0" id="r_ga7140599647f4494b4c636e87cf9083b0"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga7140599647f4494b4c636e87cf9083b0">fl_utf8to_mb</a> (const char *src, unsigned srclen, char *dst, unsigned dstlen)</td></tr>
<tr class="separator:ga7140599647f4494b4c636e87cf9083b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9723eb37891c2c754f30e1d64d4c6b72" id="r_ga9723eb37891c2c754f30e1d64d4c6b72"><td class="memItemLeft" align="right" valign="top">FL_EXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga9723eb37891c2c754f30e1d64d4c6b72">fl_utf2mbcs</a> (const char *src)</td></tr>
<tr class="separator:ga9723eb37891c2c754f30e1d64d4c6b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39a1895b879cc7bde01adc073f15e32" id="r_gae39a1895b879cc7bde01adc073f15e32"><td class="memItemLeft" align="right" valign="top">FL_EXPORT unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gae39a1895b879cc7bde01adc073f15e32">fl_utf8from_mb</a> (char *dst, unsigned dstlen, const char *src, unsigned srclen)</td></tr>
<tr class="separator:gae39a1895b879cc7bde01adc073f15e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b2222dd56379bd207aa43008599ea09" id="r_ga3b2222dd56379bd207aa43008599ea09"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga3b2222dd56379bd207aa43008599ea09">fl_utf_strncasecmp</a> (const char *s1, const char *s2, int n)</td></tr>
<tr class="separator:ga3b2222dd56379bd207aa43008599ea09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63a1c56de1f2ebbe4c1e125386d2e60" id="r_gad63a1c56de1f2ebbe4c1e125386d2e60"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gad63a1c56de1f2ebbe4c1e125386d2e60">fl_utf_strcasecmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:gad63a1c56de1f2ebbe4c1e125386d2e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga740fa37418471ca5be990c7cda17633a" id="r_ga740fa37418471ca5be990c7cda17633a"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga740fa37418471ca5be990c7cda17633a">fl_tolower</a> (unsigned int ucs)</td></tr>
<tr class="separator:ga740fa37418471ca5be990c7cda17633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89f0f2a9adf00a1b6b73776b8f01cd0" id="r_gaa89f0f2a9adf00a1b6b73776b8f01cd0"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gaa89f0f2a9adf00a1b6b73776b8f01cd0">fl_toupper</a> (unsigned int ucs)</td></tr>
<tr class="separator:gaa89f0f2a9adf00a1b6b73776b8f01cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf76050fa9f74aac6bf174bd3872742d" id="r_gacf76050fa9f74aac6bf174bd3872742d"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gacf76050fa9f74aac6bf174bd3872742d">fl_utf_tolower</a> (const unsigned char *str, int len, char *buf)</td></tr>
<tr class="separator:gacf76050fa9f74aac6bf174bd3872742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f601b637b94506eaa17056ba20ce25d" id="r_ga4f601b637b94506eaa17056ba20ce25d"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga4f601b637b94506eaa17056ba20ce25d">fl_utf_toupper</a> (const unsigned char *str, int len, char *buf)</td></tr>
<tr class="separator:ga4f601b637b94506eaa17056ba20ce25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga284e7ffcaa8920af917bcde2937290a0" id="r_ga284e7ffcaa8920af917bcde2937290a0"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga284e7ffcaa8920af917bcde2937290a0">fl_chmod</a> (const char *f, int mode)</td></tr>
<tr class="separator:ga284e7ffcaa8920af917bcde2937290a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c145ba77cf3a650e0a0eb2f40e9766" id="r_ga82c145ba77cf3a650e0a0eb2f40e9766"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga82c145ba77cf3a650e0a0eb2f40e9766">fl_access</a> (const char *f, int mode)</td></tr>
<tr class="separator:ga82c145ba77cf3a650e0a0eb2f40e9766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340b483102011c7bf3ab3cfdb8c48c43" id="r_ga340b483102011c7bf3ab3cfdb8c48c43"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga340b483102011c7bf3ab3cfdb8c48c43">fl_stat</a> (const char *path, struct stat *<a class="el" href="structbuffer.html">buffer</a>)</td></tr>
<tr class="separator:ga340b483102011c7bf3ab3cfdb8c48c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c9fa96383ace7e2e2a876e6d1530c0" id="r_ga88c9fa96383ace7e2e2a876e6d1530c0"><td class="memItemLeft" align="right" valign="top">FL_EXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga88c9fa96383ace7e2e2a876e6d1530c0">fl_getcwd</a> (char *buf, int len)</td></tr>
<tr class="separator:ga88c9fa96383ace7e2e2a876e6d1530c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga604dcd35f5599bda6d9f701960edede1" id="r_ga604dcd35f5599bda6d9f701960edede1"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga604dcd35f5599bda6d9f701960edede1">fl_chdir</a> (const char *path)</td></tr>
<tr class="separator:ga604dcd35f5599bda6d9f701960edede1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a457e9f251d83d565a62fb3c88cf32e" id="r_ga8a457e9f251d83d565a62fb3c88cf32e"><td class="memItemLeft" align="right" valign="top">FL_EXPORT FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga8a457e9f251d83d565a62fb3c88cf32e">fl_fopen</a> (const char *f, const char *mode)</td></tr>
<tr class="separator:ga8a457e9f251d83d565a62fb3c88cf32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f89c3f89322ec150861b6447f2e7fd6" id="r_ga9f89c3f89322ec150861b6447f2e7fd6"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga9f89c3f89322ec150861b6447f2e7fd6">fl_system</a> (const char *f)</td></tr>
<tr class="separator:ga9f89c3f89322ec150861b6447f2e7fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab84087f262c42c9a4a3aa637a62fa3" id="r_gafab84087f262c42c9a4a3aa637a62fa3"><td class="memItemLeft" align="right" valign="top"><a id="gafab84087f262c42c9a4a3aa637a62fa3" name="gafab84087f262c42c9a4a3aa637a62fa3"></a>
FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><b>fl_execvp</b> (const char *file, char *const *argv)</td></tr>
<tr class="separator:gafab84087f262c42c9a4a3aa637a62fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga070365398f64a04b75e4e004a82c8611" id="r_ga070365398f64a04b75e4e004a82c8611"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga070365398f64a04b75e4e004a82c8611">fl_open</a> (const char *fname, int oflags,...)</td></tr>
<tr class="separator:ga070365398f64a04b75e4e004a82c8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa068389f876ebb9dd5b619ad1dfa23a6" id="r_gaa068389f876ebb9dd5b619ad1dfa23a6"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gaa068389f876ebb9dd5b619ad1dfa23a6">fl_open_ext</a> (const char *fname, int binary, int oflags,...)</td></tr>
<tr class="separator:gaa068389f876ebb9dd5b619ad1dfa23a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0796bf837058013e07765f5c425d95" id="r_ga6c0796bf837058013e07765f5c425d95"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga6c0796bf837058013e07765f5c425d95">fl_close_fd</a> (int fd)</td></tr>
<tr class="separator:ga6c0796bf837058013e07765f5c425d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cea59ee78f8284678e9279d384c7799" id="r_ga9cea59ee78f8284678e9279d384c7799"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga9cea59ee78f8284678e9279d384c7799">fl_unlink</a> (const char *fname)</td></tr>
<tr class="separator:ga9cea59ee78f8284678e9279d384c7799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27a123cb14a33e1024f520b7ca88d2f" id="r_gad27a123cb14a33e1024f520b7ca88d2f"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gad27a123cb14a33e1024f520b7ca88d2f">fl_rmdir</a> (const char *f)</td></tr>
<tr class="separator:gad27a123cb14a33e1024f520b7ca88d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3396a1bbcf14adc06066d791791464da" id="r_ga3396a1bbcf14adc06066d791791464da"><td class="memItemLeft" align="right" valign="top">FL_EXPORT char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga3396a1bbcf14adc06066d791791464da">fl_getenv</a> (const char *name)</td></tr>
<tr class="separator:ga3396a1bbcf14adc06066d791791464da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7561ee8db315213580d0b164c9a71ae1" id="r_ga7561ee8db315213580d0b164c9a71ae1"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga7561ee8db315213580d0b164c9a71ae1">fl_putenv</a> (const char *var)</td></tr>
<tr class="separator:ga7561ee8db315213580d0b164c9a71ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2d28413204e9059f02f4651f455fb5" id="r_ga7b2d28413204e9059f02f4651f455fb5"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga7b2d28413204e9059f02f4651f455fb5">fl_mkdir</a> (const char *f, int mode)</td></tr>
<tr class="separator:ga7b2d28413204e9059f02f4651f455fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2905a37cbb3b2eaf1c302980bf9ce86a" id="r_ga2905a37cbb3b2eaf1c302980bf9ce86a"><td class="memItemLeft" align="right" valign="top">FL_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga2905a37cbb3b2eaf1c302980bf9ce86a">fl_rename</a> (const char *f, const char *t)</td></tr>
<tr class="separator:ga2905a37cbb3b2eaf1c302980bf9ce86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd78a1155fa19f67153dda7538ce00d" id="r_gaedd78a1155fa19f67153dda7538ce00d"><td class="memItemLeft" align="right" valign="top">FL_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#gaedd78a1155fa19f67153dda7538ce00d">fl_make_path_for_file</a> (const char *path)</td></tr>
<tr class="separator:gaedd78a1155fa19f67153dda7538ce00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eaa1bb84d01ca3f6d102771ff296974" id="r_ga8eaa1bb84d01ca3f6d102771ff296974"><td class="memItemLeft" align="right" valign="top">FL_EXPORT char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fl__unicode.html#ga8eaa1bb84d01ca3f6d102771ff296974">fl_make_path</a> (const char *path)</td></tr>
<tr class="separator:ga8eaa1bb84d01ca3f6d102771ff296974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3a884ca5383ac1a607c60a4b32757299" name="ga3a884ca5383ac1a607c60a4b32757299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a884ca5383ac1a607c60a4b32757299">&#9670;&#160;</a></span>ERRORS_TO_CP1252</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERRORS_TO_CP1252&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set to 1 to turn bad UTF-8 bytes in the 0x80-0x9f range into the Unicode index for Microsoft's CP1252 character set. You should also set ERRORS_TO_ISO8859_1. With this a huge amount of more available text (such as all web pages) are correctly converted to Unicode. </p>

</div>
</div>
<a id="gab32b33e9780bd5daf6b837ad05dda081" name="gab32b33e9780bd5daf6b837ad05dda081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32b33e9780bd5daf6b837ad05dda081">&#9670;&#160;</a></span>ERRORS_TO_ISO8859_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERRORS_TO_ISO8859_1&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set to 1 to turn bad UTF-8 bytes into ISO-8859-1. If this is zero they are instead turned into the Unicode REPLACEMENT CHARACTER, of value 0xfffd. If this is on <a class="el" href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode()</a> will correctly map most (perhaps all) human-readable text that is in ISO-8859-1. This may allow you to completely ignore character sets in your code because virtually everything is either ISO-8859-1 or UTF-8. </p>

</div>
</div>
<a id="gad39777a7d175212740aba2b63068d799" name="gad39777a7d175212740aba2b63068d799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad39777a7d175212740aba2b63068d799">&#9670;&#160;</a></span>STRICT_RFC3629</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STRICT_RFC3629&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A number of Unicode code points are in fact illegal and should not be produced by a UTF-8 converter. Turn this on will replace the bytes in those encodings with errors. If you do this then converting arbitrary 16-bit data to UTF-8 and then back is not an identity, which will probably break a lot of software. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga82c145ba77cf3a650e0a0eb2f40e9766" name="ga82c145ba77cf3a650e0a0eb2f40e9766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82c145ba77cf3a650e0a0eb2f40e9766">&#9670;&#160;</a></span>fl_access()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_access </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to test a files access() with a UTF-8 encoded name or value.</p>
<p>This function is especially useful on the Windows platform where the standard access() function fails with UTF-8 encoded non-ASCII filenames.</p>
<p>Windows defines the mode values 0 for existence, 2 for writable, 4 for readable, and 6 of readable and writable. On other systems, the modes <code>X_OK</code>, <code>W_OK</code>, and <code>R_OK</code> are usually defined as 1, 2, and 4.</p>
<p>Upon successful completion, the value 0 is returned on all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the UTF-8 encoded filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the mode to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _waccess() on Windows or access() on other platforms. </dd></dl>

</div>
</div>
<a id="ga604dcd35f5599bda6d9f701960edede1" name="ga604dcd35f5599bda6d9f701960edede1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga604dcd35f5599bda6d9f701960edede1">&#9670;&#160;</a></span>fl_chdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_chdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to change the current working directory, given as a UTF-8 encoded string.</p>
<p>This function is especially useful on the Windows platform where the standard _wchdir() function needs a <code>path</code> in UTF-16 encoding.</p>
<p>The <code>path</code> is converted to a system specific encoding if necessary and the system specific <code>chdir(converted_path)</code> function is called.</p>
<p>The function returns 0 on success and -1 on error. Depending on the platform, <code>errno</code> <b>may</b> be set if an error occurs.</p>
<dl class="section note"><dt>Note</dt><dd>The possible errno values are platform specific. Refer to the documentation of the platform specific chdir() function.</dd></dl>
<p>If the function is not implemented on a particular platform the default implementation returns -1 and <code>errno</code> is <b>not</b> set.</p>
<p>If the <code>path</code> is <code>NULL</code> the function returns -1, but <code>errno</code> is <b>not</b> changed. This is a convenience feature of <a class="el" href="group__fl__unicode.html#ga604dcd35f5599bda6d9f701960edede1">fl_chdir()</a> as opposed to chdir().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>the target directory for chdir (may be <code>NULL</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, -1 on error (errno may be set) </dd></dl>

</div>
</div>
<a id="ga284e7ffcaa8920af917bcde2937290a0" name="ga284e7ffcaa8920af917bcde2937290a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga284e7ffcaa8920af917bcde2937290a0">&#9670;&#160;</a></span>fl_chmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_chmod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to set a files mode() with a UTF-8 encoded name or value.</p>
<p>This function is especially useful on the Windows platform where the standard chmod() function fails with UTF-8 encoded non-ASCII filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the UTF-8 encoded filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the mode to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _wchmod() on Windows or chmod() on other platforms. </dd></dl>

</div>
</div>
<a id="ga6c0796bf837058013e07765f5c425d95" name="ga6c0796bf837058013e07765f5c425d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c0796bf837058013e07765f5c425d95">&#9670;&#160;</a></span>fl_close_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_close_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to close a file descriptor. </p><dl class="section return"><dt>Returns</dt><dd>0 in case of success, or -1 in case of error. </dd></dl>

</div>
</div>
<a id="ga8a457e9f251d83d565a62fb3c88cf32e" name="ga8a457e9f251d83d565a62fb3c88cf32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a457e9f251d83d565a62fb3c88cf32e">&#9670;&#160;</a></span>fl_fopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * fl_fopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to open files with a UTF-8 encoded name.</p>
<p>This function is especially useful on the Windows platform where the standard fopen() function fails with UTF-8 encoded non-ASCII filenames. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the UTF-8 encoded filename </td></tr>
    <tr><td class="paramname">mode</td><td>same as the second argument of the standard fopen() function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a FILE pointer upon successful completion, or NULL in case of error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__unicode.html#ga070365398f64a04b75e4e004a82c8611">fl_open()</a>. </dd></dl>

</div>
</div>
<a id="ga88c9fa96383ace7e2e2a876e6d1530c0" name="ga88c9fa96383ace7e2e2a876e6d1530c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88c9fa96383ace7e2e2a876e6d1530c0">&#9670;&#160;</a></span>fl_getcwd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * fl_getcwd </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to get the current working directory as a UTF-8 encoded value.</p>
<p>This function is especially useful on the Windows platform where the standard _wgetcwd() function returns UTF-16 encoded non-ASCII filenames.</p>
<p>If <code>buf</code> is <code>NULL</code> a buffer of size <code></code>(len+1) is allocated, filled with the current working directory, and returned. In this case the buffer must be released by the caller with free() to prevent memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>the buffer to populate (may be NULL) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>the length of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the CWD encoded as UTF-8 </dd></dl>

</div>
</div>
<a id="ga3396a1bbcf14adc06066d791791464da" name="ga3396a1bbcf14adc06066d791791464da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3396a1bbcf14adc06066d791791464da">&#9670;&#160;</a></span>fl_getenv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * fl_getenv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to get environment variables with a UTF-8 encoded name or value.</p>
<p>This function is especially useful on the Windows platform where non-ASCII environment variables are encoded as wide characters. The returned value of the variable is encoded in UTF-8 as well.</p>
<p>On platforms other than Windows this function calls getenv directly. The return value is returned as-is.</p>
<p>The return value is a pointer to an implementation defined buffer:</p><ul>
<li>an internal buffer that is (re)allocated as needed (Windows) or</li>
<li>the string in the environment itself (Unix, Linux, MaOS) or</li>
<li>any other implementation (other platforms). This string must be considered read-only and must not be freed by the caller.</li>
</ul>
<p>If the resultant string is to be used later it must be copied to a safe place. The next call to <a class="el" href="group__fl__unicode.html#ga3396a1bbcf14adc06066d791791464da">fl_getenv()</a> or any other environment changes may overwrite the string.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not thread-safe.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>the UTF-8 encoded environment variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the environment variable in UTF-8 encoding, or NULL in case of error. </dd></dl>

</div>
</div>
<a id="ga8eaa1bb84d01ca3f6d102771ff296974" name="ga8eaa1bb84d01ca3f6d102771ff296974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eaa1bb84d01ca3f6d102771ff296974">&#9670;&#160;</a></span>fl_make_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char fl_make_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to recursively create a path in the file system.</p>
<p>This function creates a <code>path</code> in the file system by recursively creating all directories.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>a Unix style ('/' forward slashes) absolute or relative pathname </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the path was created, 0 if creating the path failed at some point </dd></dl>

</div>
</div>
<a id="gaedd78a1155fa19f67153dda7538ce00d" name="gaedd78a1155fa19f67153dda7538ce00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd78a1155fa19f67153dda7538ce00d">&#9670;&#160;</a></span>fl_make_path_for_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fl_make_path_for_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to create a path for the file in the file system.</p>
<p>This function strips the filename from the given <code>path</code> and creates a path in the file system by recursively creating all directories. </p>

</div>
</div>
<a id="ga7b2d28413204e9059f02f4651f455fb5" name="ga7b2d28413204e9059f02f4651f455fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b2d28413204e9059f02f4651f455fb5">&#9670;&#160;</a></span>fl_mkdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_mkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to create a directory with a UTF-8 encoded name.</p>
<p>This function is especially useful on the Windows platform where the standard _wmkdir() function expects UTF-16 encoded non-ASCII filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the UTF-8 encoded filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>the mode of the directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _wmkdir() on Windows or mkdir() on other platforms. </dd></dl>

</div>
</div>
<a id="ga75d310d956bedf6129c5ef6c1e868a8f" name="ga75d310d956bedf6129c5ef6c1e868a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75d310d956bedf6129c5ef6c1e868a8f">&#9670;&#160;</a></span>fl_nonspacing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int fl_nonspacing </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ucs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the Unicode character <code>ucs</code> is non-spacing.</p>
<p>Non-spacing characters in Unicode are typically combining marks like tilde (~), diaeresis (¨), or other marks that are added to a base character, for instance 'a' (base character) + '¨' (combining mark) = 'ä' (German Umlaut).</p>
<ul>
<li><a href="http://unicode.org/glossary/#base_character">http://unicode.org/glossary/#base_character</a></li>
<li><a href="http://unicode.org/glossary/#nonspacing_mark">http://unicode.org/glossary/#nonspacing_mark</a></li>
<li><a href="http://unicode.org/glossary/#combining_character">http://unicode.org/glossary/#combining_character</a> </li>
</ul>

</div>
</div>
<a id="ga070365398f64a04b75e4e004a82c8611" name="ga070365398f64a04b75e4e004a82c8611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga070365398f64a04b75e4e004a82c8611">&#9670;&#160;</a></span>fl_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to open files with a UTF-8 encoded name.</p>
<p>This function is especially useful on the Windows platform where the standard open() function fails with UTF-8 encoded non-ASCII filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>the UTF-8 encoded filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oflags</td><td>other arguments are as in the standard open() function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a file descriptor upon successful completion, or -1 in case of error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__unicode.html#ga8a457e9f251d83d565a62fb3c88cf32e">fl_fopen()</a>, <a class="el" href="group__fl__unicode.html#gaa068389f876ebb9dd5b619ad1dfa23a6">fl_open_ext()</a>, <a class="el" href="group__fl__unicode.html#ga6c0796bf837058013e07765f5c425d95">fl_close_fd(int fd)</a>. </dd></dl>

</div>
</div>
<a id="gaa068389f876ebb9dd5b619ad1dfa23a6" name="gaa068389f876ebb9dd5b619ad1dfa23a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa068389f876ebb9dd5b619ad1dfa23a6">&#9670;&#160;</a></span>fl_open_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_open_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to open files with a UTF-8 encoded name.</p>
<p>In comparison with <a class="el" href="group__fl__unicode.html#ga070365398f64a04b75e4e004a82c8611">fl_open()</a>, this function allows to control whether the file is opened in binary (a.k.a. untranslated) mode. This is especially useful on the Windows platform where files are by default opened in text (translated) mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fname</td><td>the UTF-8 encoded filename </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binary</td><td>if non-zero, the file is to be accessed in binary (a.k.a. untranslated) mode. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oflags,...</td><td>these arguments are as in the standard open() function. Setting <code>oflags</code> to zero opens the file for reading.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a file descriptor upon successful completion, or -1 in case of error. </dd></dl>

</div>
</div>
<a id="ga7561ee8db315213580d0b164c9a71ae1" name="ga7561ee8db315213580d0b164c9a71ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7561ee8db315213580d0b164c9a71ae1">&#9670;&#160;</a></span>fl_putenv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_putenv </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to write environment variables with a UTF-8 encoded name or value.</p>
<p>This function is especially useful on the Windows platform where non-ASCII environment variables are encoded as wide characters.</p>
<p>The given argument <code>var</code> must be encoded in UTF-8 in the form "name=value". The <code>'name'</code> part must conform to platform dependent restrictions on environment variable names.</p>
<p>The string given in <code>var</code> is copied and optionally converted to the required encoding for the platform. On platforms other than Windows this function calls putenv directly.</p>
<p>The return value is zero on success and non-zero in case of error. The value in case of error is platform specific and returned as-is.</p>
<dl class="section note"><dt>Note</dt><dd>The copied string is allocated on the heap and "lost" on some platforms, i.e. calling <a class="el" href="group__fl__unicode.html#ga7561ee8db315213580d0b164c9a71ae1">fl_putenv()</a> to change environment variables frequently may cause memory leaks. There may be an option to avoid this in a future implementation.</dd>
<dd>
This function is not thread-safe.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>the UTF-8 encoded environment variable <code>'name=value'</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, non-zero in case of error. </dd></dl>

</div>
</div>
<a id="ga2905a37cbb3b2eaf1c302980bf9ce86a" name="ga2905a37cbb3b2eaf1c302980bf9ce86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2905a37cbb3b2eaf1c302980bf9ce86a">&#9670;&#160;</a></span>fl_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to rename a filesystem object using UTF-8 encoded names.</p>
<p>This function is especially useful on the Windows platform where the standard _wrename() function expects UTF-16 encoded non-ASCII filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the UTF-8 encoded filename to change </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the new UTF-8 encoded filename to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _wrename() on Windows or rename() on other platforms. </dd></dl>

</div>
</div>
<a id="gad27a123cb14a33e1024f520b7ca88d2f" name="gad27a123cb14a33e1024f520b7ca88d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad27a123cb14a33e1024f520b7ca88d2f">&#9670;&#160;</a></span>fl_rmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_rmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to remove a directory with a UTF-8 encoded name.</p>
<p>This function is especially useful on the Windows platform where the standard _wrmdir() function expects UTF-16 encoded non-ASCII filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the UTF-8 encoded filename to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _wrmdir() on Windows or rmdir() on other platforms. </dd></dl>

</div>
</div>
<a id="ga340b483102011c7bf3ab3cfdb8c48c43" name="ga340b483102011c7bf3ab3cfdb8c48c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga340b483102011c7bf3ab3cfdb8c48c43">&#9670;&#160;</a></span>fl_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_stat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to stat() a file using a UTF-8 encoded name or value.</p>
<p>This function is especially useful on the Windows platform where the standard stat() function fails with UTF-8 encoded non-ASCII filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the UTF-8 encoded filename </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>the stat struct to populate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _wstat() on Windows or stat() on other platforms. </dd></dl>

</div>
</div>
<a id="ga9f89c3f89322ec150861b6447f2e7fd6" name="ga9f89c3f89322ec150861b6447f2e7fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f89c3f89322ec150861b6447f2e7fd6">&#9670;&#160;</a></span>fl_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_system </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to run a system command with a UTF-8 encoded string.</p>
<p>This function is especially useful on the Windows platform where non-ASCII program (file) names must be encoded as wide characters.</p>
<p>On platforms other than Windows this function calls system() directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>the UTF-8 encoded command string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _wsystem() on Windows or system() on other platforms. </dd></dl>

</div>
</div>
<a id="ga740fa37418471ca5be990c7cda17633a" name="ga740fa37418471ca5be990c7cda17633a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga740fa37418471ca5be990c7cda17633a">&#9670;&#160;</a></span>fl_tolower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_tolower </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ucs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Unicode lower case value of <code>ucs</code>. </p>

</div>
</div>
<a id="gaa89f0f2a9adf00a1b6b73776b8f01cd0" name="gaa89f0f2a9adf00a1b6b73776b8f01cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa89f0f2a9adf00a1b6b73776b8f01cd0">&#9670;&#160;</a></span>fl_toupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_toupper </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ucs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Unicode upper case value of <code>ucs</code>. </p>

</div>
</div>
<a id="gadda1ae7fbd7f38a12a7e390dd847020b" name="gadda1ae7fbd7f38a12a7e390dd847020b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda1ae7fbd7f38a12a7e390dd847020b">&#9670;&#160;</a></span>fl_ucs_to_Utf16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_ucs_to_Utf16 </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>ucs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a single 32-bit Unicode codepoint into an array of 16-bit characters. These are used by some system calls, especially on Windows.</p>
<p><code>ucs</code> is the value to convert.</p>
<p><code>dst</code> points at an array to write, and <code>dstlen</code> is the number of locations in this array. At most <code>dstlen</code> words will be written, and a 0 terminating word will be added if <code>dstlen</code> is large enough. Thus this function will never overwrite the buffer and will attempt return a zero-terminated string if space permits. If <code>dstlen</code> is zero then <code>dst</code> can be set to NULL and no data is written, but the length is returned.</p>
<p>The return value is the number of 16-bit words that <em>would</em> be written to <code>dst</code> if it is large enough, not counting any terminating zero.</p>
<p>If the return value is greater than <code>dstlen</code> it indicates truncation, you should then allocate a new array of size return+1 and call this again.</p>
<p>Unicode characters in the range 0x10000 to 0x10ffff are converted to "surrogate pairs" which take two words each (in UTF-16 encoding). Typically, setting <code>dstlen</code> to 2 will ensure that any valid Unicode value can be converted, and setting <code>dstlen</code> to 3 or more will allow a NULL terminated sequence to be returned. </p>

</div>
</div>
<a id="ga9cea59ee78f8284678e9279d384c7799" name="ga9cea59ee78f8284678e9279d384c7799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cea59ee78f8284678e9279d384c7799">&#9670;&#160;</a></span>fl_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_unlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cross-platform function to unlink() (that is, delete) a file using a UTF-8 encoded filename.</p>
<p>This function is especially useful on the Windows platform where the standard function expects UTF-16 encoded non-ASCII filenames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>the filename to unlink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of _wunlink() on Windows or unlink() on other platforms. </dd></dl>

</div>
</div>
<a id="ga9723eb37891c2c754f30e1d64d4c6b72" name="ga9723eb37891c2c754f30e1d64d4c6b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9723eb37891c2c754f30e1d64d4c6b72">&#9670;&#160;</a></span>fl_utf2mbcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * fl_utf2mbcs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts UTF-8 string <code>s</code> to a local multi-byte character string. </p>

</div>
</div>
<a id="gad28ab9ec404eed36008de0ddcf95db0f" name="gad28ab9ec404eed36008de0ddcf95db0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad28ab9ec404eed36008de0ddcf95db0f">&#9670;&#160;</a></span>fl_utf8back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * fl_utf8back </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move <code>p</code> backward until it points to the start of a UTF-8 character. If it already points at the start of one then it is returned unchanged. Any UTF-8 errors are treated as though each byte of the error is an individual character.</p>
<p><em>start</em> is the start of the string and is used to limit the backwards search for the start of a UTF-8 character.</p>
<p><em>end</em> is the end of the string and is assumed to be a break between characters. It is assumed to be greater than p.</p>
<p>If you wish to decrement a UTF-8 pointer, pass p-1 to this. </p>

</div>
</div>
<a id="ga3e25d5c315ce7f0acf87c3662e331468" name="ga3e25d5c315ce7f0acf87c3662e331468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e25d5c315ce7f0acf87c3662e331468">&#9670;&#160;</a></span>fl_utf8bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf8bytes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ucs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of bytes needed to encode the given UCS4 character in UTF-8. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucs</td><td>UCS4 encoded character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes required</dd></dl>
<p>Returns number of bytes that utf8encode() will use to encode the character <code>ucs</code>. </p>

</div>
</div>
<a id="gad80ac8abaa3ed7b8c245447d6b3aab95" name="gad80ac8abaa3ed7b8c245447d6b3aab95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad80ac8abaa3ed7b8c245447d6b3aab95">&#9670;&#160;</a></span>fl_utf8decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode a single UTF-8 encoded character starting at <em>p</em>. The resulting Unicode value (in the range 0-0x10ffff) is returned, and <em>len</em> is set to the number of bytes in the UTF-8 encoding (adding <em>len</em> to <em>p</em> will point at the next character).</p>
<p>If <code>p</code> points at an illegal UTF-8 encoding, including one that would go past <em>end</em>, or where a code uses more bytes than necessary, then *(unsigned char*)p is translated as though it is in the Microsoft CP1252 character set and <em>len</em> is set to 1. Treating errors this way allows this to decode almost any ISO-8859-1 or CP1252 text that has been mistakenly placed where UTF-8 is expected, and has proven very useful.</p>
<p>If you want errors to be converted to error characters (as the standards recommend), adding a test to see if the length is unexpectedly 1 will work:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (*p &amp; 0x80) {              <span class="comment">// what should be a multibyte encoding</span></div>
<div class="line">  <a class="code hl_struct" href="structcode.html">code</a> = <a class="code hl_function" href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode</a>(p,end,&amp;len);</div>
<div class="line">  <span class="keywordflow">if</span> (len&lt;2) <a class="code hl_struct" href="structcode.html">code</a> = 0xFFFD;   <span class="comment">// Turn errors into REPLACEMENT CHARACTER</span></div>
<div class="line">} <span class="keywordflow">else</span> {                      <span class="comment">// handle the 1-byte UTF-8 encoding:</span></div>
<div class="line">  <a class="code hl_struct" href="structcode.html">code</a> = *p;</div>
<div class="line">  len = 1;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__fl__unicode_html_gad80ac8abaa3ed7b8c245447d6b3aab95"><div class="ttname"><a href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode</a></div><div class="ttdeci">FL_EXPORT unsigned fl_utf8decode(const char *p, const char *end, int *len)</div><div class="ttdef"><b>Definition</b> fl_utf8.cxx:724</div></div>
<div class="ttc" id="astructcode_html"><div class="ttname"><a href="structcode.html">code</a></div><div class="ttdef"><b>Definition</b> inftrees.h:24</div></div>
</div><!-- fragment --><p>Direct testing for the 1-byte case (as shown above) will also speed up the scanning of strings where the majority of characters are ASCII. </p>

</div>
</div>
<a id="gae608a28bc43f10014343483ed3d5e99c" name="gae608a28bc43f10014343483ed3d5e99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae608a28bc43f10014343483ed3d5e99c">&#9670;&#160;</a></span>fl_utf8encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf8encode </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ucs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the UTF-8 encoding of <em>ucs</em> into <em>buf</em> and return the number of bytes written. Up to 4 bytes may be written. If you know that <code>ucs</code> is less than 0x10000 then at most 3 bytes will be written. If you wish to speed this up, remember that anything less than 0x80 is written as a single byte.</p>
<p>If ucs is greater than 0x10ffff this is an illegal character according to RFC 3629. These are converted as though they are 0xFFFD (REPLACEMENT CHARACTER).</p>
<p>RFC 3629 also says many other values for <code>ucs</code> are illegal (in the range 0xd800 to 0xdfff, or ending with 0xfffe or 0xffff). However I encode these as though they are legal, so that utf8encode/fl_utf8decode will be the identity for all codes between 0 and 0x10ffff. </p>

</div>
</div>
<a id="gae39a1895b879cc7bde01adc073f15e32" name="gae39a1895b879cc7bde01adc073f15e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae39a1895b879cc7bde01adc073f15e32">&#9670;&#160;</a></span>fl_utf8from_mb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8from_mb </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a filename from the locale-specific multibyte encoding used by Windows to UTF-8 as used by FLTK.</p>
<p>Up to <code>dstlen</code> bytes are written to <code>dst</code>, including a null terminator. The return value is the number of bytes that would be written, not counting the null terminator. If greater or equal to <code>dstlen</code> then if you malloc a new array of size n+1 you will have the space needed for the entire string. If <code>dstlen</code> is zero then nothing is written and this call just measures the storage space needed.</p>
<p>On Unix or on Windows when a UTF-8 locale is in effect, this does not change the data. You may also want to check if <a class="el" href="group__fl__unicode.html#ga9db7a23fb75a6a76d3118704806918ea">fl_utf8test()</a> returns non-zero, so that the filesystem can store filenames in UTF-8 encoding regardless of the locale. </p>

</div>
</div>
<a id="gae652006e11dcea72e9ae23e8fb606ff1" name="gae652006e11dcea72e9ae23e8fb606ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae652006e11dcea72e9ae23e8fb606ff1">&#9670;&#160;</a></span>fl_utf8froma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8froma </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an ISO-8859-1 (ie normal c-string) byte stream to UTF-8.</p>
<p>It is possible this should convert Microsoft's CP1252 to UTF-8 instead. This would translate the codes in the range 0x80-0x9f to different characters. Currently it does not do this.</p>
<p>Up to <code>dstlen</code> bytes are written to <code>dst</code>, including a null terminator. The return value is the number of bytes that would be written, not counting the null terminator. If greater or equal to <code>dstlen</code> then if you malloc a new array of size n+1 you will have the space needed for the entire string. If <code>dstlen</code> is zero then nothing is written and this call just measures the storage space needed.</p>
<p><code>srclen</code> is the number of bytes in <code>src</code> to convert.</p>
<p>If the return value equals <code>srclen</code> then this indicates that no conversion is necessary, as only ASCII characters are in the string. </p>

</div>
</div>
<a id="ga56a6296024debb49690b81addda7589b" name="ga56a6296024debb49690b81addda7589b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a6296024debb49690b81addda7589b">&#9670;&#160;</a></span>fl_utf8fromwc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8fromwc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn "wide characters" as returned by some system calls (especially on Windows) into UTF-8.</p>
<p>Up to <code>dstlen</code> bytes are written to <code>dst</code>, including a null terminator. The return value is the number of bytes that would be written, not counting the null terminator. If greater or equal to <code>dstlen</code> then if you malloc a new array of size n+1 you will have the space needed for the entire string. If <code>dstlen</code> is zero then nothing is written and this call just measures the storage space needed.</p>
<p><code>srclen</code> is the number of words in <code>src</code> to convert. On Windows this is not necessarily the number of characters, due to there possibly being "surrogate pairs" in the UTF-16 encoding used. On Unix wchar_t is 32 bits and each location is a character.</p>
<p>On Unix if a <code>src</code> word is greater than 0x10ffff then this is an illegal character according to RFC 3629. These are converted as though they are 0xFFFD (REPLACEMENT CHARACTER). Characters in the range 0xd800 to 0xdfff, or ending with 0xfffe or 0xffff are also illegal according to RFC 3629. However I encode these as though they are legal, so that fl_utf8towc will return the original data.</p>
<p>On Windows "surrogate pairs" are converted to a single character and UTF-8 encoded (as 4 bytes). Mismatched halves of surrogate pairs are converted as though they are individual characters. </p>

</div>
</div>
<a id="ga881af6d9537e0aadb1ab7ab3f35bd3bc" name="ga881af6d9537e0aadb1ab7ab3f35bd3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga881af6d9537e0aadb1ab7ab3f35bd3bc">&#9670;&#160;</a></span>fl_utf8fwd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * fl_utf8fwd </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move <code>p</code> forward until it points to the start of a UTF-8 character. If it already points at the start of one then it is returned unchanged. Any UTF-8 errors are treated as though each byte of the error is an individual character.</p>
<p><em>start</em> is the start of the string and is used to limit the backwards search for the start of a UTF-8 character.</p>
<p><em>end</em> is the end of the string and is assumed to be a break between characters. It is assumed to be greater than p.</p>
<p>This function is for moving a pointer that was jumped to the middle of a string, such as when doing a binary search for a position. You should use either this or <a class="el" href="group__fl__unicode.html#gad28ab9ec404eed36008de0ddcf95db0f">fl_utf8back()</a> depending on which direction your algorithm can handle the pointer moving. Do not use this to scan strings, use <a class="el" href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode()</a> instead. </p>

</div>
</div>
<a id="ga3eedf721bef934868002eb94d247d834" name="ga3eedf721bef934868002eb94d247d834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eedf721bef934868002eb94d247d834">&#9670;&#160;</a></span>fl_utf8len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf8len </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the byte length of the UTF-8 sequence with first byte <code>c</code>, or -1 if <code>c</code> is not valid.</p>
<p>This function is helpful for finding faulty UTF-8 sequences. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__unicode.html#gaf739852beaf3dacf039fdc0b1f289a5a">fl_utf8len1</a> </dd></dl>

</div>
</div>
<a id="gaf739852beaf3dacf039fdc0b1f289a5a" name="gaf739852beaf3dacf039fdc0b1f289a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf739852beaf3dacf039fdc0b1f289a5a">&#9670;&#160;</a></span>fl_utf8len1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf8len1 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the byte length of the UTF-8 sequence with first byte <code>c</code>, or 1 if <code>c</code> is not valid.</p>
<p>This function can be used to scan faulty UTF-8 sequences, albeit ignoring invalid codes. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__unicode.html#ga3eedf721bef934868002eb94d247d834">fl_utf8len</a> </dd></dl>

</div>
</div>
<a id="ga6c212b970de7dde3cac0b6d49f9d3c4f" name="ga6c212b970de7dde3cac0b6d49f9d3c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c212b970de7dde3cac0b6d49f9d3c4f">&#9670;&#160;</a></span>fl_utf8locale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf8locale </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the "locale" seems to indicate that UTF-8 encoding is used. If true the fl_utf8to_mb and fl_utf8from_mb don't do anything useful.</p>
<p><em>It is highly recommended that you change your system so this does return true.</em> On Windows this is done by setting the "codepage" to CP_UTF8. On Unix this is done by setting $LC_CTYPE to a string containing the letters "utf" or "UTF" in it, or by deleting all $LC* and $LANG environment variables. In the future it is likely that all non-Asian Unix systems will return true, due to the compatibility of UTF-8 with ISO-8859-1. </p>

</div>
</div>
<a id="ga3a19fe8946a1272ede63709516a03a37" name="ga3a19fe8946a1272ede63709516a03a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a19fe8946a1272ede63709516a03a37">&#9670;&#160;</a></span>fl_utf8strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf8strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the length in bytes of a UTF-8 string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">text</td><td>encoded in UTF-8 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of Unicode characters, -1 to test until the end of text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes that make up the Unicode string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__unicode.html#gaff5ccdf22c2cb46125cc9a152542e63b">fl_utf_nb_char(const unsigned char *buf, int len)</a> </dd></dl>

</div>
</div>
<a id="ga9db7a23fb75a6a76d3118704806918ea" name="ga9db7a23fb75a6a76d3118704806918ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db7a23fb75a6a76d3118704806918ea">&#9670;&#160;</a></span>fl_utf8test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf8test </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Examines the first <code>srclen</code> bytes in <code>src</code> and returns a verdict on whether it is UTF-8 or not.</p><ul>
<li>Returns 0 if there is any illegal UTF-8 sequences, using the same rules as <a class="el" href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode()</a>. Note that some UCS values considered illegal by RFC 3629, such as 0xffff, are considered legal by this.</li>
<li>Returns 1 if there are only single-byte characters (ie no bytes have the high bit set). This is legal UTF-8, but also indicates plain ASCII. It also returns 1 if <code>srclen</code> is zero.</li>
<li>Returns 2 if there are only characters less than 0x800.</li>
<li>Returns 3 if there are only characters less than 0x10000.</li>
<li>Returns 4 if there are characters in the 0x10000 to 0x10ffff range.</li>
</ul>
<p>Because there are many illegal sequences in UTF-8, it is almost impossible for a string in another encoding to be confused with UTF-8. This is very useful for transitioning Unix to UTF-8 filenames, you can simply test each filename with this to decide if it is UTF-8 or in the locale encoding. My hope is that if this is done we will be able to cleanly transition to a locale-less encoding. </p>

</div>
</div>
<a id="ga7140599647f4494b4c636e87cf9083b0" name="ga7140599647f4494b4c636e87cf9083b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7140599647f4494b4c636e87cf9083b0">&#9670;&#160;</a></span>fl_utf8to_mb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8to_mb </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the UTF-8 used by FLTK to the locale-specific encoding used for filenames (and sometimes used for data in files). Unfortunately due to stupid design you will have to do this as needed for filenames. This is a bug on both Unix and Windows.</p>
<p>Up to <code>dstlen</code> bytes are written to <code>dst</code>, including a null terminator. The return value is the number of bytes that would be written, not counting the null terminator. If greater or equal to <code>dstlen</code> then if you malloc a new array of size n+1 you will have the space needed for the entire string. If <code>dstlen</code> is zero then nothing is written and this call just measures the storage space needed.</p>
<p>If <a class="el" href="group__fl__unicode.html#ga6c212b970de7dde3cac0b6d49f9d3c4f">fl_utf8locale()</a> returns true then this does not change the data. </p>

</div>
</div>
<a id="ga12eec84f8d118aac87eaabaedfcd4154" name="ga12eec84f8d118aac87eaabaedfcd4154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12eec84f8d118aac87eaabaedfcd4154">&#9670;&#160;</a></span>fl_utf8toa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8toa </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a UTF-8 sequence into an array of 1-byte characters.</p>
<p>If the UTF-8 decodes to a character greater than 0xff then it is replaced with '?'.</p>
<p>Errors in the UTF-8 sequence are converted as individual bytes, same as <a class="el" href="group__fl__unicode.html#gad80ac8abaa3ed7b8c245447d6b3aab95">fl_utf8decode()</a> does. This allows ISO-8859-1 text mistakenly identified as UTF-8 to be printed correctly (and possibly CP1252 on Windows).</p>
<p><code>src</code> points at the UTF-8 sequence, and <code>srclen</code> is the number of bytes to convert.</p>
<p>Up to <code>dstlen</code> bytes are written to <code>dst</code>, including a null terminator. The return value is the number of bytes that would be written, not counting the null terminator. If greater or equal to <code>dstlen</code> then if you malloc a new array of size n+1 you will have the space needed for the entire string. If <code>dstlen</code> is zero then nothing is written and this call just measures the storage space needed. </p>

</div>
</div>
<a id="ga6b537f15e29c1eb78bee7c24483dc759" name="ga6b537f15e29c1eb78bee7c24483dc759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b537f15e29c1eb78bee7c24483dc759">&#9670;&#160;</a></span>fl_utf8toUtf16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8toUtf16 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a UTF-8 sequence into an array of 16-bit characters. These are used by some system calls, especially on Windows.</p>
<p><code>src</code> points at the UTF-8, and <code>srclen</code> is the number of bytes to convert.</p>
<p><code>dst</code> points at an array to write, and <code>dstlen</code> is the number of locations in this array. At most <code>dstlen-1</code> words will be written there, plus a 0 terminating word. Thus this function will never overwrite the buffer and will always return a zero-terminated string. If <code>dstlen</code> is zero then <code>dst</code> can be null and no data is written, but the length is returned.</p>
<p>The return value is the number of 16-bit words that <em>would</em> be written to <code>dst</code> if it were long enough, not counting the terminating zero. If the return value is greater or equal to <code>dstlen</code> it indicates truncation, you can then allocate a new array of size return+1 and call this again.</p>
<p>Errors in the UTF-8 are converted as though each byte in the erroneous string is in the Microsoft CP1252 encoding. This allows ISO-8859-1 text mistakenly identified as UTF-8 to be printed correctly.</p>
<p>Unicode characters in the range 0x10000 to 0x10ffff are converted to "surrogate pairs" which take two words each (this is called UTF-16 encoding). </p>

</div>
</div>
<a id="gac483f43232e4444086487d3417236209" name="gac483f43232e4444086487d3417236209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac483f43232e4444086487d3417236209">&#9670;&#160;</a></span>fl_utf8towc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned fl_utf8towc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>srclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a UTF-8 string into a wide character string.</p>
<p>This function generates 32-bit wchar_t (e.g. "ucs4" as it were) except on Windows where it is equivalent to fl_utf8toUtf16 and returns UTF-16.</p>
<p><code>src</code> points at the UTF-8, and <code>srclen</code> is the number of bytes to convert.</p>
<p><code>dst</code> points at an array to write, and <code>dstlen</code> is the number of locations in this array. At most <code>dstlen-1</code> wchar_t will be written there, plus a 0 terminating wchar_t.</p>
<p>The return value is the number of wchar_t that <em>would</em> be written to <code>dst</code> if it were long enough, not counting the terminating zero. If the return value is greater or equal to <code>dstlen</code> it indicates truncation, you can then allocate a new array of size return+1 and call this again.</p>
<p>Notice that sizeof(wchar_t) is 2 on Windows and is 4 on Linux and most other systems. Where wchar_t is 16 bits, Unicode characters in the range 0x10000 to 0x10ffff are converted to "surrogate pairs" which take two words each (this is called UTF-16 encoding). If wchar_t is 32 bits this rather nasty problem is avoided.</p>
<p>Note that Windows includes Cygwin, i.e. compiled with Cygwin's POSIX layer (cygwin1.dll, &ndash;enable-cygwin), either native (GDI) or X11. </p>

</div>
</div>
<a id="gaff5ccdf22c2cb46125cc9a152542e63b" name="gaff5ccdf22c2cb46125cc9a152542e63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5ccdf22c2cb46125cc9a152542e63b">&#9670;&#160;</a></span>fl_utf_nb_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf_nb_char </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of Unicode chars in the UTF-8 string. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__fl__unicode.html#ga3a19fe8946a1272ede63709516a03a37">fl_utf8strlen(const char *text, int len)</a> </dd></dl>

</div>
</div>
<a id="gad63a1c56de1f2ebbe4c1e125386d2e60" name="gad63a1c56de1f2ebbe4c1e125386d2e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad63a1c56de1f2ebbe4c1e125386d2e60">&#9670;&#160;</a></span>fl_utf_strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf_strcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UTF-8 aware strcasecmp - converts to Unicode and tests.</p>
<dl class="section return"><dt>Returns</dt><dd>result of comparison </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the strings are equal </td></tr>
    <tr><td class="paramname">1</td><td>if s1 is greater than s2 </td></tr>
    <tr><td class="paramname">-1</td><td>if s1 is less than s2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b2222dd56379bd207aa43008599ea09" name="ga3b2222dd56379bd207aa43008599ea09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b2222dd56379bd207aa43008599ea09">&#9670;&#160;</a></span>fl_utf_strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf_strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UTF-8 aware strncasecmp - converts to lower case Unicode and tests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1,s2</td><td>the UTF-8 strings to compare </td></tr>
    <tr><td class="paramname">n</td><td>the maximum number of UTF-8 characters to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of comparison </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the strings are equal </td></tr>
    <tr><td class="paramname">&gt;0</td><td>if s1 is greater than s2 </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if s1 is less than s2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf76050fa9f74aac6bf174bd3872742d" name="gacf76050fa9f74aac6bf174bd3872742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf76050fa9f74aac6bf174bd3872742d">&#9670;&#160;</a></span>fl_utf_tolower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf_tolower </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the string <code>str</code> to its lower case equivalent into buf. Warning: to be safe buf length must be at least 3 * len [for 16-bit Unicode] </p>

</div>
</div>
<a id="ga4f601b637b94506eaa17056ba20ce25d" name="ga4f601b637b94506eaa17056ba20ce25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f601b637b94506eaa17056ba20ce25d">&#9670;&#160;</a></span>fl_utf_toupper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_utf_toupper </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the string <code>str</code> to its upper case equivalent into buf. Warning: to be safe buf length must be at least 3 * len [for 16-bit Unicode] </p>

</div>
</div>
<a id="ga434459dcb7e07a747350403dc9ddca8c" name="ga434459dcb7e07a747350403dc9ddca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga434459dcb7e07a747350403dc9ddca8c">&#9670;&#160;</a></span>fl_wcwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_wcwidth </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>extended wrapper around <a class="el" href="group__fl__unicode.html#ga86f3c69d9e3e7b3bdc348211e4a8b7de">fl_wcwidth_(unsigned int ucs)</a> function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>pointer to start of UTF-8 byte sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>width of character in columns</dd></dl>
<p>Depending on build options, this function may map C1 control characters (0x80 to 0x9f) to CP1252, and return the width of that character instead. This is not the same behaviour as <a class="el" href="group__fl__unicode.html#ga86f3c69d9e3e7b3bdc348211e4a8b7de">fl_wcwidth_(unsigned int ucs)</a> .</p>
<p>Note that other control characters and DEL will still return -1, so if you want different behaviour, you need to test for those characters before calling <a class="el" href="group__fl__unicode.html#ga434459dcb7e07a747350403dc9ddca8c">fl_wcwidth()</a>, and handle them separately. </p>

</div>
</div>
<a id="ga86f3c69d9e3e7b3bdc348211e4a8b7de" name="ga86f3c69d9e3e7b3bdc348211e4a8b7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86f3c69d9e3e7b3bdc348211e4a8b7de">&#9670;&#160;</a></span>fl_wcwidth_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fl_wcwidth_ </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ucs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper to adapt Markus Kuhn's implementation of wcwidth() for FLTK. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucs</td><td>Unicode character value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>width of character in columns</dd></dl>
<p>See <a href="http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c">http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c</a> for Markus Kuhn's original implementation of wcwidth() and wcswidth() (defined in IEEE Std 1002.1-2001) for Unicode.</p>
<p><b>WARNING:</b> this function returns widths for "raw" Unicode characters. It does not even try to map C1 control characters (0x80 to 0x9F) to CP1252, and C0/C1 control characters and DEL will return -1. You are advised to use fl_width(const char* src) instead. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

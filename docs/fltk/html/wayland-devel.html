<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: The Wayland backend for its developer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="FLTK-devel.html">Development of the FLTK library</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">The Wayland backend for its developer</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This chapter describes how the Wayland backend of FLTK works from a developer's viewpoint.</p>
<h1><a class="anchor" id="wayland-intro"></a>
Introduction to Wayland</h1>
<p>Wayland usage involves communication via a Unix domain socket between a client application and another process called the Wayland compositor which creates, moves, resizes and draws windows on the display. Diverse Wayland compositors exist. They can follow rather diverse logics. For example, FreeBSD offers Sway which is a tiling compositor where the display is always entirely filled with whatever resizable windows are mapped at any given time. Compositors follow either the client-side decoration (CSD) rule where client apps draw window titlebars, or the server-side decoration (SSD) rule where the compositor draws titlebars. FLTK supports both CSD and SSD compositors. It uses a library called <code>libdecor</code> charged of determining whether a CSD or a SSD compositor is active, and of drawing titlebars in the first case.</p>
<p>Wayland is divided in various protocols that a given compositor may or may not support, although they all support the <code>core</code> protocol. Each protocol adds functionality not available in the core protocol. <a href="https://wayland.app/protocols/">Wayland Explorer</a> lists all protocols. The core protocol allows a client app to discover what protocols the connected compositor supports. Protocols can be stable, which means they have a defined API that will not change but can be expanded, or unstable. For example, mapping a window on a display is not done by the core protocol but by the <code>xdg shell</code> protocol which is stable. The names of symbols used by unstable protocols always begin with letter 'z'. For example, FLTK uses unstable protocol <a href="https://wayland.app/protocols/text-input-unstable-v3">Text input</a> to support CJK input methods; its symbol names begin with <code>zwp_text_input_v3</code>.</p>
<p>Wayland makes intensive use of the <em>listener</em> mechanism. A listener is a small array of pointers to FLTK-defined callback functions associated to a Wayland-defined object; Wayland calls these functions when defined events occur (more at <a class="el" href="wayland-devel.html#wayland-listeners">Listeners</a> below).</p>
<p>Wayland differs noticeably from X11 in that rendering is left to clients: Wayland provides no drawing API. Instead, Wayland provides objects of type <code>struct wl_buffer</code> which encapsulate a memory array of pixel values shared between the client and the compositor. The client app is expected to draw to that memory buffer with whatever means it chooses, and to instruct the compositor to map those pixels to the display when the drawing is complete. The Wayland platform of FLTK draws with the Cairo library to <code>Fl_Window's</code> and <code>Fl_Image_Surface's</code>, and with OpenGL to <code>Fl_Gl_Window's</code>.</p>
<p>Wayland differs also from X11 in that the position of a window in the display is completely hidden to the client app. This prevents function <code>Fl_Window::position()</code> from having any effect on a top-level window. Wayland also prevents a client app from knowing whether a window is minimized: <code>Fl_Window::show()</code> has no effect on a minimized window. Subwindows can be positioned as usual relatively to their parent window. Wayland allows to create popup windows positioned relatively to a previously mapped other window. This allows FLTK to position adequately menu and tooltip windows (see <a class="el" href="wayland-devel.html#menu-windows">Menu windows and other popups</a>). FLTK uses also popups for the small, yellow windows that display the new scale factor value when it's changed: these are created as short-lived popups centered above <code>Fl::first_window()</code>.</p>
<p>Wayland uses a trick of its own to handle lists of linked records. It defines type <code>struct wl_list</code> and a few macros (<code>wl_list_init()</code>, <code>wl_list_for_each()</code>, <code>wl_list_insert()</code>, <code>wl_list_for_each_safe()</code>, <code>wl_list_remove()</code>) to manage linked lists. Records put in these lists must contain a member variable of type <code>struct wl_list</code> used to link records together and often named 'link'. Access to such a list is possible memorizing a value of type <code>struct wl_list</code> computed by macro <code>wl_list_init()</code>. Macro <code>wl_list_for_each(arg1, arg2, arg3)</code> allows to run through all list elements with:</p><ul>
<li><code>arg1</code> is a pointer variable of the type of elements of the linked list;</li>
<li><code>arg2</code> is the address of a variable of type <code>struct wl_list</code> identifying the targeted list;</li>
<li><code>arg3</code> is the name of the member variable of these elements used to link them together.</li>
</ul>
<p>For example, <code>wl_list_for_each()</code> can be used as follows to scan the linked list of all displays of the system (see <a class="el" href="wayland-devel.html#wayland-output">Fl_Wayland_Screen_Driver::output</a>): </p><div class="fragment"><div class="line">Fl_Wayland_Screen_Driver::output *<a class="code hl_struct" href="structoutput.html">output</a>;</div>
<div class="line">Fl_Wayland_Screen_Driver *scr_driver = (Fl_Wayland_Screen_Driver*)Fl::screen_driver();</div>
<div class="line">wl_list_for_each(<a class="code hl_struct" href="structoutput.html">output</a>, &amp;(scr_driver-&gt;outputs), link) {</div>
<div class="line">  <span class="comment">// … work with output, an item of the linked list of all displays in the system …</span></div>
<div class="line">}</div>
<div class="ttc" id="astructoutput_html"><div class="ttname"><a href="structoutput.html">output</a></div><div class="ttdef"><b>Definition</b> libdecor-cairo.c:164</div></div>
</div><!-- fragment --><p>Overall, and ignoring for now OpenGL usage, FLTK interacts with Wayland as follows :</p><ul>
<li>When opening the display: FLTK calls <code>Fl::add_fd()</code> in <code>FL_READ</code> mode to associate a callback function called <code>wayland_socket_callback</code> to the socket connecting the client and the compositor.</li>
<li>Client to compositor: FLTK calls C functions of the <code>libwayland-client.so</code>, <code>libwayland-cursor.so</code> and <code>libxkbcommon.so</code> shared libraries and of the libdecor library. These send suitable messages to the compositor writing to the socket. The names of these functions begin with <code>wl_</code>, <code>xkb_</code> or <code>libdecor_</code>.</li>
<li>Compositor to client: the callback function <code>wayland_socket_callback</code> runs when there are data to read in the socket; it calls <code>wl_display_dispatch()</code> which interprets the read data and calls corresponding listeners.</li>
</ul>
<p>The core protocol defines also a number of mostly opaque structures whose names begin with <code>wl_</code>. The names of symbols and types defined by the other protocols FLTK uses begin with <code>xdg_</code>, <code>zwp_text_input_v3</code>, <code>zxdg_toplevel_decoration_</code>, <code>gtk_shell1_</code> and <code>gtk_surface1_</code>. FLTK defines a few structures holding Wayland-related data. The names of FLTK-defined structures don't begin with <code>wl_</code>. For example, <code>struct wld_window</code> (see <a class="el" href="wayland-devel.html#wld_window">wld_window</a>) is used to store all Wayland-specific data associated to a mapped Fl_Window.</p>
<h1><a class="anchor" id="wayland-build"></a>
Building libfltk as a Wayland client</h1>
<p>Classes <code>Fl_Wayland_Window_Driver</code>, <code>Fl_Wayland_Screen_Driver</code>, <code>Fl_Wayland_Graphics_Driver</code>, <code>Fl_Wayland_Copy_Surface_Driver</code>, <code>Fl_Wayland_Image_Surface_Driver</code> and <code>Fl_Wayland_Gl_Window_Driver</code> and file <code>fl_wayland_platform_init.cxx</code> contain all the Wayland-specific code of the FLTK library. This code is located at <code>src/drivers/Wayland/</code> in the FLTK source tree. A single C++ source file generally contains all the code of a given class. The code related to copy, paste and drag-and-drop operations, however, is gathered in file <code>fl_wayland_clipboard_dnd.cxx</code> and contains a few member functions of class <code>Fl_Wayland_Screen_Driver</code>. Furthermore, class <code>Fl_Unix_System_Driver</code> is used by both the Wayland and the X11 FLTK platforms. File FL/fl_config.h defines preprocessor variables <code>FLTK_USE_WAYLAND</code> and <code>FLTK_USE_CAIRO</code>.</p>
<p>The public C API to Wayland, xkb, EGL and libdecor libraries are obtained with </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;wayland-client.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;wayland-cursor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xkbcommon/xkbcommon.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;xkbcommon/xkbcommon-compose.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;linux/input.h&gt;</span> <span class="comment">// for BTN_LEFT, BTN_RIGHT, BTN_MIDDLE</span></div>
<div class="line"><span class="preprocessor">#include &quot;../../../libdecor/src/libdecor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;../../../libdecor/src/libdecor-plugin.h&quot;</span></div>
<div class="line"><span class="preprocessor">#if HAVE_GL</span></div>
<div class="line"><span class="preprocessor">#  include &lt;wayland-egl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#  include &lt;EGL/egl.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// HAVE_GL</span></div>
</div><!-- fragment --><p> as necessary.</p>
<p>File <code>README.Wayland.txt</code> details what software packages are needed on Debian-based, Fedora and FreeBSD systems for FLTK to use Wayland. Wayland protocols are packaged as XML files accompanied by a utility program, <code>wayland-scanner</code>, able to generate a header file and a necessary glue C source file from a given XML file. For example, for FLTK to use the <a href="https://wayland.app/protocols/xdg-shell">XDG shell</a> protocol, these commands are run at build time to generate a .c file (<code>xdg-shell-protocol.c</code>) that will be compiled into <code>libfltk</code> and a header file (<code>xdg-shell-client-protocol.h</code>) that the FLTK code will include: </p><div class="fragment"><div class="line">PROTOCOLS=`pkg-<a class="code hl_struct" href="structconfig__s.html">config</a> --variable=pkgdatadir wayland-protocols`</div>
<div class="line">wayland-scanner <span class="keyword">private</span>-<a class="code hl_struct" href="structcode.html">code</a> $PROTOCOLS/stable/xdg-shell/xdg-shell.xml xdg-shell-protocol.c</div>
<div class="line">wayland-scanner client-header $PROTOCOLS/stable/xdg-shell/xdg-shell.xml xdg-shell-client-protocol.h</div>
<div class="ttc" id="astructcode_html"><div class="ttname"><a href="structcode.html">code</a></div><div class="ttdef"><b>Definition</b> inftrees.h:24</div></div>
<div class="ttc" id="astructconfig__s_html"><div class="ttname"><a href="structconfig__s.html">config_s</a></div><div class="ttdef"><b>Definition</b> deflate.c:98</div></div>
</div><!-- fragment --><p> Similar operations are performed for FLTK to use protocols <a href="https://wayland.app/protocols/xdg-decoration-unstable-v1">XDG decoration</a>, <a href="https://wayland.app/protocols/text-input-unstable-v3">Text input</a> and <a href="https://wayland.app/protocols/gtk-shell">GTK Shell</a>.</p>
<h1><a class="anchor" id="wayland-x11-hybrid"></a>
The hybrid Wayland/X11 platform</h1>
<p>The Wayland platform of FLTK is normally a two-legged hybrid able to use either Wayland or X11 and to choose between these possibilities at run-time, without any change to the client application. The Wayland/X11 hybrid is essentially a version of the FLTK library containing both all Wayland-specific <u>and</u> all X11-specific code. That's reflected in file FL/fl_config.h which defines both <code>FLTK_USE_WAYLAND</code> and <code>FLTK_USE_X11</code>. This creates the constraint that Wayland and X11 cannot use the same type name for different purposes or the same symbol name. That is why function <code>fl_xid(const Fl_Window*)</code> is deprecated in FLTK 1.4 and replaced by <code>fl_wl_xid()</code> for Wayland and <code>fl_x11_xid()</code> for X11. Also, global variable <code>Window fl_window</code> is not used by the Wayland platform which instead uses <code>static struct wld_window *Fl_Wayland_Window_Driver:: wld_window</code>. The FLTK library contains also a short source file, <code>fl_wayland_platform_init.cxx</code>, that determines, at startup time, whether the app will run as a Wayland or as an X11 client. Function <code>attempt_wayland()</code> therein performs this choice as follows :</p><ul>
<li>if the app defines a global bool variable called <code>fl_disable_wayland</code> and this variable is true, the X11 leg is chosen;</li>
<li>if environment variable FLTK_BACKEND is defined to string "wayland", the Wayland leg is chosen;</li>
<li>if environment variable FLTK_BACKEND is defined to string "x11", the X11 leg is chosen;</li>
<li>otherwise, a connection to a Wayland compositor is attempted; if it's successful, the Wayland leg is chosen; if it's not, the X11 leg is chosen.</li>
</ul>
<p>The first condition listed above is meant to facilitate transition to FLTK 1.4 of source code written for FLTK 1.3 and containing X11-specific code : it's enough to put </p><div class="fragment"><div class="line">FL_EXPORT <span class="keywordtype">bool</span> fl_disable_wayland = <span class="keyword">true</span>;</div>
</div><!-- fragment --><p> anywhere in the source code, for the app to run with 1.4, using the x11 leg of the hybrid platform, without any other change in the source code nor to the application's environment.</p>
<p>Function <code>attempt_wayland()</code> must be called before the very first platform-dependent operation FLTK performs so that operation is done the Wayland or the X11 way, as appropriate. That's why 4 locations of the FLTK source code call <code>attempt_wayland()</code>: <code>Fl_Graphics_Driver::newMainGraphicsDriver(), Fl_Screen_Driver::newScreenDriver(), Fl_Window_Driver::newWindowDriver(Fl_Window*), and Fl_Image_Surface_Driver::newImageSurfaceDriver().</code></p>
<p>In special situations, such as with embedded systems equipped with the Wayland software but lacking the X11 library, it's possible to build the FLTK library such as it contains only the Wayland backend. This is achieved building FLTK with <code>cmake -DFLTK_BACKEND_X11=OFF</code> or with <code>configure &ndash;disable-x11</code>. In that case, FL/fl_config.h does not define <code>FLTK_USE_X11</code>.</p>
<p>The rest of this chapter describes what happens when the Wayland leg has been chosen.</p>
<h1><a class="anchor" id="wayland-listeners"></a>
Listeners</h1>
<p>A Wayland 'listener' is a small array of pointers to FLTK-defined callback functions associated to a Wayland-defined object, usually right after creation of this object, by a call to a specific Wayland function named following the form <code>wl_XXX_add_listener()</code>. After defined events have occurred, the Wayland compositor sends appropriate commands to the client through the socket; the event loop detects the availability of data in the socket and calls function <code>wayland_socket_callback()</code>; this function calls the appropriate member of the listener and transmits relevant information to the client app as parameters of this call. For example, this code: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> surface_enter(……) { …… } <span class="comment">// called when a surface enters a display</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> surface_leave(……) { …… } <span class="comment">// called when a surface leaves a display</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>wl_surface_listener surface_listener = {</div>
<div class="line">  surface_enter,</div>
<div class="line">  surface_leave,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">some_pointer_type pter_to_data;</div>
<div class="line"><span class="keyword">struct </span>wl_surface *my_wl_surface;</div>
<div class="line">my_wl_surface = wl_compositor_create_surface(scr_driver-&gt;wl_compositor);</div>
<div class="line">wl_surface_add_listener(my_wl_surface, &amp;surface_listener, pter_to_data);</div>
</div><!-- fragment --><p> creates a Wayland object of type <code>struct wl_surface</code> (roughly, a window), and associates it with a 2-member listener called <code>surface_listener</code>. After this, Wayland is expected to call the 2 listener members, <code>surface_enter</code> or <code>surface_leave</code>, each time <code>my_wl_surface</code> will enter or leave, respectively, a display. The arguments of these calls, not detailed here, allow the member functions to identify which surface enters or leaves which display. The <code>wl_surface_add_listener()</code> call above also associates <code>pter_to_data</code> to <code>my_wl_surface</code> as <em>user data</em>. The <code>wl_surface</code> object's "user data" can be obtained later calling function <code>wl_surface_get_user_data()</code>.</p>
<p>Wayland function <code>wl_proxy_get_listener()</code> returns a pointer to a Wayland object's listener provided that object is transmitted cast to type <code>struct wl_proxy *</code>. This gives a handy way to distinguish FLTK-created Wayland objects from objects of other origin: the listener of an FLTK-created object is a known FLTK listener. For example, function <code>Fl_Wayland_Window_Driver::surface_to_window()</code> uses this possibility calling <code>wl_proxy_get_listener( (struct wl_proxy *)wl_surface )</code> for any object of type <code>struct wl_surface</code>: if that object was created as in the example above, this call returns a pointer to FLTK's <code>surface_listener</code> static variable.</p>
<h1><a class="anchor" id="wayland-connection"></a>
Opening a Wayland connection</h1>
<p>Establishing a Wayland connection requires environment variable <code>XDG_RUNTIME_DIR</code> to be defined and to point to a directory containing a socket connected to a Wayland compositor. This variable is usually set by the login procedure of Wayland-friendly desktops. Which socket-file to use within that directory is determined as follows:</p><ul>
<li>the client may call <code>Fl::display(const char *display_name)</code> before <code><a class="el" href="Fl_8cxx.html#a94ee21d83137569a6730e3e2e7305cbc">fl_open_display()</a></code> runs or use the <code>-display</code> command line argument and transmit there the socket name;</li>
<li>environment variable <code>WAYLAND_DISPLAY</code> can be defined to the socket name;</li>
<li>otherwise, <code>"wayland-0"</code> is used.</li>
</ul>
<p>Which socket is selected determines the compositor used by the client application: that at the other end of the socket.</p>
<p>Establishing the connection begins with a call to <code>wl_display_connect(const char *display_name) </code>. That call is done inside function <code>attempt_wayland()</code> mentioned before with a NULL argument, or when a non default Wayland display name is specified as explained above. That call returns a <code>struct wl_display</code> pointer or NULL in case of failure. Such NULL return is the hint that allows the FLTK display opening procedure of the Wayland/X11 hybrid to recognize when Wayland access is not possible and to fallback to X11. If the call is successful, its non-NULL return is assigned to class variable <code>Fl_Wayland_Screen_Driver::wl_display</code>.</p>
<p>The rest of the work is done in function <code>Fl_Wayland_Screen_Driver::open_display_platform()</code>. A call to <code>wl_registry_add_listener()</code> associates a 2-member listener, whose 1st member, <code>registry_handle_global()</code>, will be called by Wayland a number of times to indicate each time a protocol supported by the compositor or a system feature such as displays and keyboards.</p>
<p>FLTK runs this code to receive calls to <code>registry_handle_global()</code>: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> sync_done(<span class="keywordtype">void</span> *data, <span class="keyword">struct</span> wl_callback *cb, uint32_t time) {</div>
<div class="line">  *(<span class="keyword">struct </span>wl_callback **)data = NULL;</div>
<div class="line">  wl_callback_destroy(cb);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>wl_callback_listener sync_listener = {</div>
<div class="line">  sync_done</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>wl_callback *registry_cb = wl_display_sync(wl_display);</div>
<div class="line">wl_callback_add_listener(registry_cb, &amp;sync_listener, &amp;registry_cb);</div>
<div class="line"><span class="keywordflow">while</span> (registry_cb) wl_display_dispatch(wl_display);</div>
</div><!-- fragment --><p> A pointer to an object of type <code>struct wl_callback</code> created by function <code>wl_display_sync()</code> is assigned to variable <code>registry_cb</code>. Then a 1-member listener is attached to this object. Wayland will run this listener's member function, <code>sync_done()</code>, after all calls to <code>registry_handle_global()</code> have occurred. Function <code>sync_done()</code> sets to null variable <code>registry_cb</code> and destroys the <code>wl_callback</code>. Finally, function <code>wl_display_dispatch()</code> is called as long as variable <code>registry_cb</code> is not null. Thus, when <code>sync_done()</code> runs, FLTK has received all due calls to <code>registry_handle_global()</code>.</p>
<p>The prototype of function <code>registry_handle_global</code> is: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> registry_handle_global(<span class="keywordtype">void</span> *user_data, <span class="keyword">struct</span> wl_registry *wl_registry,</div>
<div class="line">           uint32_t <span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *interface, uint32_t version)</div>
</div><!-- fragment --><p> Each time Wayland calls <code>registry_handle_global()</code>, <code>interface</code> and <code>version</code> give the name and version of a component or feature of the Wayland system. Here is the list of the <code>interface</code> value for all protocols and system features FLTK uses: </p><table class="doxtable">
<tr>
<th>interface </th><th>use  </th></tr>
<tr>
<td>wl_compositor </td><td>create wl_surface objects   </td></tr>
<tr>
<td>wl_subcompositor </td><td>create subwindows   </td></tr>
<tr>
<td>wl_shm </td><td>create buffers and buffer factories  </td></tr>
<tr>
<td>wl_seat </td><td>create the unique "seat"  </td></tr>
<tr>
<td>wl_data_device </td><td>support of copy/paste/drag-n-drop  </td></tr>
<tr>
<td>wl_output </td><td>received once for each display   </td></tr>
<tr>
<td>xdg_wm_base </td><td>create mapped windows   </td></tr>
<tr>
<td>gtk_shell1 </td><td>signals Mutter is in use + titlebar gestures  </td></tr>
<tr>
<td>weston_desktop_shell </td><td>signals Weston is in use </td></tr>
<tr>
<td>org_kde_plasma_shell </td><td>signals KDE/Plasma is in use </td></tr>
<tr>
<td>zwp_text_input_manager_v3 </td><td>interface with Text Input Methods  </td></tr>
<tr>
<td>zxdg_decoration_manager_v1 </td><td>select between CSD and SSD modes  </td></tr>
</table>
<p>Wayland compositors typically support several other protocols (e.g., <code>zxdg_output_manager_v1</code>) that FLTK does not use.</p>
<p>Each time <code>registry_handle_global</code> runs with an <code>interface</code> from the table above, FLTK calls <code>wl_registry_bind()</code> which returns a pointer to a Wayland structure that will be the client's access point to the corresponding Wayland protocol or system feature. This pointer is stored in a dedicated member variable of the unique <code>Fl_Wayland_Screen_Driver</code> object of an FLTK app, or of another object accessible from this object. For example, when <code>interface</code> equals <code>"wl_compositor"</code>, the value returned by <code>wl_registry_bind()</code> is stored as member <code>wl_compositor</code> of the <code>Fl_Wayland_Screen_Driver</code> object. <code>registry_handle_global()</code> also identifies whether the Mutter, Weston, or KWin compositor is connected and stores this information in static member variable <code>Fl_Wayland_Screen_Driver::compositor</code>.</p>
<p>Wayland calls <code>registry_handle_global()</code> with its parameter <code>interface</code> equals to "wl_output" once for each screen connected to the system. Each time, an object of type <code>struct wl_output</code> is created, to which a 4-member listener is associated by function <code>wl_output_add_listener()</code>. The 3rd member of this 4-function listener, <code>output_done()</code>, runs after all initialization steps of the screen have completed and turns to <code>true</code> member <code>done</code> of a record of type <code>struct</code> <a class="el" href="wayland-devel.html#wayland-output">Fl_Wayland_Screen_Driver::output</a> associated to the screen. Function <code>sync_done()</code> mentioned above therefore also calls <code>wl_display_dispatch()</code> until the <code>done</code> member of all <code>Fl_Wayland_Screen_Driver::output</code> records are <code>true</code>. Overall, after return from function <code>sync_done()</code>, FLTK has been made aware of all optional protocols and features of its connected Wayland compositor, and has initialized all screens of the system.</p>
<p>Finally, function <code>wl_display_get_fd()</code> is called to obtain the file descriptor of the Wayland socket and a call to Fl::add_fd() makes FLTK listen to this descriptor in <code>FL_READ</code> mode and associates function <code>wayland_socket_callback()</code> from file <code>Fl_Wayland_Screen_Driver.cxx</code> with it. This function calls <code>wl_display_dispatch()</code> which reads and interprets data available from the file descriptor, and calls corresponding listeners. The <code>wl_display_dispatch()</code> call is repeated as long as data are available for reading.</p>
<p>The event loop is run by function <code>Fl_Unix_System_Driver::wait()</code> which is used by both the Wayland and X11 FLTK backends. Among various tasks, this function waits for data arriving on the file descriptors FLTK is listening. Overall, the event loop of the Wayland backend is nearly exactly the same as that used by the X11 backend. The Wayland backend differs only in the callback function handling data read from the Wayland connection socket, and in overridden functions <code>Fl_Wayland_Screen_Driver::poll_or_select_with_delay()</code> and <code>Fl_Wayland_Screen_Driver::poll_or_select()</code>.</p>
<h1><a class="anchor" id="wayland-surface"></a>
Wayland windows and surfaces</h1>
<p>Wayland defines objects called surfaces of type <code>struct wl_surface</code>. A Wayland surface "has a rectangular area which may be displayed on zero or more displays, present buffers,
receive user input, and define a local coordinate system". In short, surface is the name Wayland uses for a window. Buffers allow the client app to define the graphical content of surfaces (see <a class="el" href="wayland-devel.html#wayland-buffer">Wayland buffers</a>). FLTK creates a surface each time an Fl_Window is show()'n calling function <code>wl_compositor_create_surface()</code>. Static member function <code>Fl_Wayland_Window_Driver::surface_to_window(struct wl_surface *)</code> gives the <code>Fl_Window*</code> corresponding to the surface given in argument.</p>
<p>FLTK recognizes 4 mutually exclusive kinds of surfaces :</p><ul>
<li>DECORATED are toplevel windows with a titlebar;</li>
<li>UNFRAMED are toplevel windows without titlebar;</li>
<li>POPUP correspond to menus and tooltips;</li>
<li>SUBWINDOW correspond to an Fl_Window embedded in another Fl_Window.</li>
</ul>
<p>Function <code>Fl_Wayland_Window_Driver::makeWindow()</code> creates all these surfaces, creates for each a record of type <code>struct wld_window</code> (see <a class="el" href="wayland-devel.html#wld_window">wld_window</a>), and stores the window kind in member variable <code>kind</code> of this record. Member variable <code>xid</code> of the window's <code>Fl_X</code> record stores the adress of this record.</p>
<p>Except for SUBWINDOW's, each surface needs a Wayland object of type <code>struct xdg_surface</code> used to make it become a mapped window and stored in member <code>xdg_surface</code> of the window's <a class="el" href="wayland-devel.html#wld_window">wld_window</a> record. For DECORATED windows, this object is created inside libdecor and transmitted to FLTK by function <code>libdecor_frame_get_xdg_surface()</code>. For UNFRAMED and POPUP windows, it's created by function <code>xdg_wm_base_get_xdg_surface()</code>. Finally, each surface is also associated to one more Wayland object whose type varies with the window's kind. These explain this part of the <a class="el" href="wayland-devel.html#wld_window">wld_window</a> record: </p><div class="fragment"><div class="line"><span class="keyword">union </span>{</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_class" href="structlibdecor__frame.html">libdecor_frame</a> *frame; <span class="comment">// created for DECORATED by libdecor_decorate()</span></div>
<div class="line">  <span class="keyword">struct </span>wl_subsurface *subsurface; <span class="comment">// created for SUBWINDOW by wl_subcompositor_get_subsurface()</span></div>
<div class="line">  <span class="keyword">struct </span>xdg_popup *xdg_popup; <span class="comment">// created for POPUP by xdg_surface_get_popup()</span></div>
<div class="line">  <span class="keyword">struct </span>xdg_toplevel *xdg_toplevel; <span class="comment">// created for UNFRAMED by xdg_surface_get_toplevel()</span></div>
<div class="line">};</div>
<div class="ttc" id="astructlibdecor__frame_html"><div class="ttname"><a href="structlibdecor__frame.html">libdecor_frame</a></div><div class="ttdoc">A frame used for decorating a Wayland surface.</div><div class="ttdef"><b>Definition</b> libdecor-plugin.h:35</div></div>
</div><!-- fragment --><p>Except for SUBWINDOW's, each surface is associated to a 'configure' function that Wayland calls one or more times when the window is going to be mapped on the display. The 'configure' function of DECORATED surfaces is <code>handle_configure()</code> which is the 1st member of a 4-member listener named <code>libdecor_frame_iface</code> associated to a decorated window when it's created calling <code>libdecor_decorate()</code>. Finally, a call to <code>libdecor_frame_map()</code> triggers the process of mapping the newly created DECORATED surface on a display. Wayland calls <code>handle_configure()</code> twice during this process. The first <code>handle_configure()</code> run allows to set the window's <code>xdg_surface</code> object which is returned by function <code>libdecor_frame_get_xdg_surface()</code>. FLTK distinguishes the first from the second run of <code>handle_configure()</code> by looking at the <code>xdg_surface</code> member variable that's NULL at the beginning of the 1st run and not NULL later. Wayland calls <code>handle_configure()</code> also during operations such as resizing, minimizing (see below). With the help of a few calls to libdecor functions, FLTK obtains in this function all needed information about the size and state of the mapped window. The 'configure' functions of UNFRAMED and POPUP surfaces are <code>xdg_surface_configure()</code>, <code>xdg_toplevel_configure()</code> and <code>popup_configure()</code>. The mapping process of these surfaces is triggered by a call to <code>wl_surface_commit()</code>. These 'configure' functions transmit effective window size information to FLTK. Also, they are where the window's <code>Fl_Window_Driver::wait_for_expose_value</code> member variable is set to 0 to indicate that the window has been mapped to display. <b>Caution:</b> there are some small differences between how and when the various Wayland compositors call <code>handle_configure()</code>.</p>
<p>When a decorated window changes size, whatever the cause of it, Wayland calls <code>handle_configure()</code> which sets member variable <code>Fl_Wayland_Window_Driver::in_handle_configure</code> to true and calls the window's virtual <code>resize()</code> function which ultimately runs <code>Fl_Wayland_Window_Driver::resize()</code> which calls Fl_Group::resize() to perform FLTK's resize operations and <code>Fl_Wayland_Graphics_Driver::buffer_release()</code> to delete the existing window buffer that's not adequate for the new window size. At the end of the run of <code>handle_configure()</code>, <code>in_handle_configure</code> is set back to false. When the window size change is caused by the app itself calling the window's <code>resize()</code> function, <code>Fl_Wayland_Window_Driver::in_handle_configure</code> is false. This allows <code>Fl_Wayland_Window_Driver::resize()</code> to detect that Wayland needs be informed of the desired size change, which gets done by a call to <code>libdecor_frame_commit()</code>. Wayland later calls <code>handle_configure()</code> and events described above unfold.</p>
<p>Wayland generally does not provide a way to control where the compositor should map a window in the system displays. Nevertheless, for multi-display systems, Wayland allows to control on what display should the compositor map a fullscreen window. That is done inside function <code>handle_configure()</code> which calls <code>libdecor_frame_set_fullscreen()</code> for DECORATED windows and inside function <code>xdg_toplevel_configure()</code> which calls <code>xdg_toplevel_set_fullscreen()</code> for UNFRAMED. The <code>struct wl_output</code> pointer for the targeted display is transmitted as 2nd argument of these calls.</p>
<h1><a class="anchor" id="menu-windows"></a>
Menu windows and other popups</h1>
<p>Menu windows, tiny menu title windows, and tooltip windows are implemented using Wayland's popup mechanism which allows to position a popup window relatively to a previously mapped window, itself a popup or another kind of window, with the restriction that any popup must overlap or at least touch that other window. Member function <code>Fl_Wayland_Window_Driver::makeWindow</code> calls member function <code>Fl_Wayland_Window_Driver::process_menu_or_tooltip</code> to create all popups.</p>
<p>This function gets called after FLTK has computed using a given algorithm the desired <code></code>(x,y) position of the popup window's top-left corner, using coordinates centered on the top-left corner of the toplevel window from which the popup originates. This algorithm is able to prevent popups from being positioned beyond the screen borders under the assumption that the position of a toplevel window inside a screen is known. While this assumption holds for other platforms, it does not for the Wayland platform. The FLTK code for the Wayland platform therefore modifies the algorithm that FLTK uses to compute the position of menu windows. The key information used by this algorithm is obtained by member function <code>Fl_Window_Driver::menu_window_area</code> which computes the coordinates of the rectangle where menu windows are allowed to be positioned. Under other platforms, this function just returns the origin and size of the work area of the screen in use. In contrast, the Wayland platform handles two situations differently :</p><ul>
<li>For menu windows that are not taller than the display in use, the Wayland-overridden member function <code>Fl_Wayland_Window_Driver::menu_window_area</code> returns large negative origin and large width and height values. This lets the standard FLTK algorithm position the menu relatively to its window of origin without concern about screen limits, and relies on Wayland's constraint mechanism described below to prevent the menu from going beyond these limits, without FLTK having to know where they are.</li>
<li>Menu windows taller than the screen where they are mapped need special handling described in detail in a comment above the source code of function <code>Fl_Wayland_Window_Driver::process_menu_or_tooltip</code>.</li>
</ul>
<p>Function <code>Fl_Wayland_Window_Driver::process_menu_or_tooltip</code> first computes <code>origin_win</code>, pointer to the <code>Fl_Window</code> relatively to which the popup is to be positioned. Window <code>origin_win</code> is the parent menu window when the popup is a sub-menu; it's the tiny windowtitle when the popup is a menu with a title; otherwise, it's the window containing the point of origin of the popup. An object of type <code>struct xdg_positioner</code> created by function <code>xdg_wm_base_create_positioner()</code> is used to express the rules that will determine the popup position relatively to <code>origin_win</code> as follows:</p><ul>
<li>Function <code>xdg_positioner_set_anchor_rect()</code> determines a rectangle in <code>origin_win</code> relatively to which the popup is to be positioned. When the popup to be created is a menu window spawned by an Fl_Menu_Bar, that rectangle is the full area of the menu title window. Otherwise, that rectangle is an adequately located point.</li>
<li>Function <code>xdg_positioner_set_size()</code> sets the popup size.</li>
<li>The <code>xdg_positioner_set_anchor(positioner, XDG_POSITIONER_ANCHOR_BOTTOM_LEFT);</code> and <code>xdg_positioner_set_gravity(positioner, XDG_POSITIONER_GRAVITY_BOTTOM_RIGHT);</code> calls position the popup so that its top-left corner is initially below and at right of the bottom-left corner of the <code>origin_win</code> 's anchor rectangle.</li>
<li>The call to <code>xdg_positioner_set_offset()</code> further changes the popup vertical position.</li>
<li>The call to <code>xdg_positioner_set_constraint_adjustment()</code> uses constraint flags <code>XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_X</code> and <code>XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_SLIDE_Y</code> which mean that the compositor will move the popup horizontally and vertically if its initial position would make it expand beyond the edges of the screen. Furthermore, flag XDG_POSITIONER_CONSTRAINT_ADJUSTMENT_FLIP_Y is added when the popup is a menu window spawned by an Fl_Menu_Bar; this has the popup flipped above the Fl_Menu_Bar if there's not enough screen room below it for the popup.</li>
<li>Finally, a call to function <code>xdg_surface_get_popup()</code> creates the popup accounting for position rules listed above. The positioner is then deleted by <code>xdg_positioner_destroy()</code>, a listener is associated to the popup surface with <code>xdg_popup_add_listener()</code>, and a call to <code>wl_surface_commit()</code> triggers the mapping of the popup on the display.</li>
</ul>
<p>Overall, the expected coordinates of the top-left corner of the popup relatively to <code>origin_win</code> are <code>popup_x, popup_y</code>. They are memorized in a record of FLTK-defined type <code>struct <a class="el" href="structwin__positioner.html">win_positioner</a></code> that's associated to the popup listener. When the compositor maps the popup, function <code>popup_configure</code>, the first element of the popup listener, runs and receives as arguments the coordinates of the popup top left and its size. These values account for the positioning constraints of the popup which may have moved it to avoid screen borders. This function can therefore detect whether constraints applied have modified the effective popup location in comparison to the expected coordinates which are available as member variables of the <code>struct <a class="el" href="structwin__positioner.html">win_positioner</a></code> record mentioned above. That's key to the handling by FLTK of tall menu windows.</p>
<p>Groups of popups containing a menutitle, the associated menuwindow, and optionally a submenu window and that don't belong to an Fl_Menu_Bar are mapped in a different order: the menuwindow is mapped first, and the menutitle is mapped second above it as a child popup. Function <code>Fl_Window_Driver::is_floating_title()</code> detects when such a menutitle is created, static member variable <code>previous_floatingtitle</code> is assigned the value of this menutitle, and the menutitle is mapped only after the menuwindow has been mapped, as a child of it. This positions better the popup group in the display relatively to where the popup was created.</p>
<h1><a class="anchor" id="wayland-graphics-driver"></a>
Fl_Wayland_Graphics_Driver and Fl_Cairo_Graphics_Driver</h1>
<p>The Wayland platform of FLTK uses an <code>Fl_Wayland_Graphics_Driver</code> object for all its on-screen drawing operations. This object is created by function <code>Fl_Graphics_Driver::newMainGraphicsDriver()</code> called by <code>Fl_Display_Device::display_device()</code> when the library opens the display. New <code>Fl_Wayland_Graphics_Driver</code> objects are also created for each <code>Fl_Image_Surface</code> and each <code>Fl_Copy_Surface</code> used, and deleted when these objects are deleted.</p>
<p>Class <code>Fl_Wayland_Graphics_Driver</code> derives from class <code>Fl_Cairo_Graphics_Driver</code> which implements all the FLTK drawing API for a Cairo surface. Function <code>Fl_Wayland_Graphics_Driver::cairo_init()</code> creates the Cairo surface used by each <code>Fl_Wayland_Graphics_Driver</code> object by calling <code>cairo_image_surface_create_for_data()</code> for the window's or offscreen's <code>draw_buffer</code> (see below).</p>
<p>Class <code>Fl_Cairo_Graphics_Driver</code> is also used by the X11 leg of the hybrid Wayland-X11 platform because this leg draws to the display with an <code>Fl_X11_Cairo_Graphics_Driver</code> object which derives from class <code>Fl_Cairo_Graphics_Driver</code>. Finally, <code>Fl_Cairo_Graphics_Driver</code> is also used, in the form of an object from its derived class <code>Fl_PostScript_Graphics_Driver</code>, when the hybrid Wayland-X11 platform draws PDF or PostScript, or when the classic X11 platform uses Pango and draws PDF or PostScript. This happens when classes <code>Fl_PDF_File_Surface</code>, <code>Fl_PostScript_File_Device</code> and <code>Fl_Printer</code> are used.</p>
<h1><a class="anchor" id="wayland-buffer"></a>
Wayland buffers</h1>
<p>Wayland uses buffers, objects of type <code>struct wl_buffer</code>, to draw to surfaces. In principle, one or more buffers can be associated to a surface, and functions <code>wl_surface_attach()</code> and <code>wl_surface_commit()</code> are called to first attach one such buffer to the surface and then inform the compositor to map this buffer's graphics content on the display. Wayland buffers can use various memory layouts. FLTK uses WL_SHM_FORMAT_ARGB8888, which is the same layout as what Cairo calls CAIRO_FORMAT_ARGB32.</p>
<p>FLTK calls function <code>Fl_Wayland_Window_Driver::make_current()</code> before drawing to any Fl_Window. Member <code>buffer</code> of this Fl_Window's <code>struct wld_window</code> (see <a class="el" href="wayland-devel.html#wld_window">wld_window</a>) is NULL when the window has just been created or resized. In that case, FLTK calls <code>Fl_Wayland_Graphics_Driver::create_wld_buffer()</code> which returns a pointer to a <code>struct wld_buffer</code> containing</p><ul>
<li>a Wayland buffer, member <code>wl_buffer</code>;</li>
<li>a Cairo image surface, created by a call to <code>Fl_Wayland_Graphics_Driver::cairo_init()</code>.</li>
</ul>
<p>Each of these two objects encapsulates a byte array of the same size and the same memory layout destined to contain the Fl_Window's graphics. The Cairo image surface object is where FLTK draws. The Wayland buffer is what Wayland maps on the display. FLTK copies the Cairo surface's byte array to the Wayland buffer's byte array before beginning the mapping operation. If <code>width</code> and <code>height</code> are a window's dimensions in pixels, </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, width);</div>
<div class="line"><span class="keywordtype">int</span> size = stride * height;</div>
</div><!-- fragment --><p> give <code>size</code>, the common size of both byte arrays.</p>
<p>The effective creation of the <code>wl_buffer</code> object is delayed until function <code>Fl_Wayland_Graphics_Driver::buffer_commit()</code> gets called. Section <a class="el" href="wayland-devel.html#wayland-buffer-factory">Buffer factories</a> below details how FLTK creates <code>wl_buffer</code> objects.</p>
<p>The <code>struct Fl_Wayland_Graphics_Driver::wld_buffer</code> (see <a class="el" href="wayland-devel.html#wld_buffer">wld_buffer</a>) contains a pointer to the byte array of the Cairo image surface (member <code>draw_buffer.buffer</code>), information about the Wayland buffer (members <code>wl_buffer</code> and <code>data</code>), the common size of the Cairo surface's and Wayland buffer's byte arrays (member <code>draw_buffer.data_size</code>), and other information. A pointer to this <code>struct Fl_Wayland_Graphics_Driver::wld_buffer</code> is memorized as member <code>buffer</code> of the Fl_Window's <a class="el" href="wayland-devel.html#wld_window">wld_window</a>. All drawing operations to the Fl_Window then modify the content of the Cairo image surface.</p>
<p>Function <code>Fl_Wayland_Window_Driver::flush()</code> is in charge of sending FLTK graphics data to the display. That is done by calling function <code>Fl_Wayland_Graphics_Driver::buffer_commit()</code> which creates the <code>struct wl_buffer</code> object calling <code>create_shm_buffer()</code> if that was not done before, copies the byte array of the Cairo surface to the Wayland buffer's starting memory address, and calls functions <code>wl_surface_attach()</code> and <code>wl_surface_commit()</code>. Before calling Fl_Window::flush(), FLTK has computed a damaged region. If that region is not null, <code>Fl_Wayland_Graphics_Driver::buffer_commit()</code> copies only the damaged parts of the Cairo surface to the Wayland buffer and calls function <code>wl_surface_damage_buffer()</code> for these parts to inform the compositor of what parts of the surface need its attention.</p>
<h3>Wayland buffer deletion</h3>
<p>Each <a class="el" href="wayland-devel.html#wld_buffer">wld_buffer</a> record contains boolean member <code>in_use</code> which is set to <code>true</code> just before the buffer gets committed, and boolean member <code>released</code> which is set to <code>true</code> when FLTK no longer needs the buffer and calls <code>Fl_Wayland_Graphics_Driver::buffer_release()</code>. FLTK's buffer-creating function, <code>Fl_Wayland_Graphics_Driver::create_shm_buffer()</code>, attaches a 1-member listener to each buffer which Wayland calls after a commit operation to indicate the client is allowed to re-use the buffer. This listener's member function, <code>buffer_release_listener()</code>, turns to false member <code>in_use</code> of the buffer's <a class="el" href="wayland-devel.html#wld_buffer">wld_buffer</a> record. Since the two events 'FLTK no longer needs the buffer' and 'the client is allowed to re-use the buffer' can arrive in any order, FLTK deletes the <code>struct wl_buffer</code> object by running <code>do_buffer_release()</code> only after both events happened, that is, when <code>in_use</code> is <code>false</code> and <code>released</code> is <code>true</code>. That's why function <code>do_buffer_release()</code> is called by both functions <code>Fl_Wayland_Graphics_Driver::buffer_release()</code> and <code>buffer_release_listener()</code>.</p>
<h1><a class="anchor" id="throttling"></a>
Throttling window redraws</h1>
<p>FLTK uses Wayland's synchronization mechanism to make sure any committed <code>wl_buffer</code> is not changed while the compositor is using it and to refrain from calling <code>wl_surface_commit()</code> more frequently than the system can process it. Firstly, as seen above, Wayland calls function <code>buffer_release_listener()</code> when the client is free to reuse or destroy a given <code>wl_buffer</code>. FLTK won't change or destroy a committed <code>wl_buffer</code> before that call. Second, this 2-step mechanism prevents Wayland clients from committing new buffer states too frequently:</p><ul>
<li><code>Fl_Wayland_Graphics_Driver::buffer_commit()</code> first calls function <code>wl_surface_frame()</code> to obtain a pointer to a <code>struct wl_callback</code> object and stores it as member <code>frame_cb</code> of the surface's <a class="el" href="wayland-devel.html#wld_window">wld_window</a>. Then it calls <code>wl_callback_add_listener()</code> to associate this object to the FLTK-defined, callback function <code>surface_frame_done()</code>. It next calls <code>wl_surface_commit()</code>. Together, these 3 calls instruct Wayland to start mapping the buffer content to the display and to call <code>surface_frame_done()</code> later, when it will have become ready for another mapping operation.</li>
<li>Later, <code>surface_frame_done()</code> runs and destroys the <code>wl_callback</code> object by function <code>wl_callback_destroy()</code> and sets member <code>frame_cb</code> to NULL.</li>
</ul>
<p>Member variable <code>draw_buffer_needs_commit</code> of the <a class="el" href="wayland-devel.html#wld_buffer">wld_buffer</a> is also important in this mechanism : it informs FLTK that the graphics buffer has changed and needs being committed. This variable is turned <code>true</code> every time a graphics operation changes the buffer content and turned <code>false</code> when the buffer gets committed.</p>
<p>This procedure ensures that FLTK never calls <code>wl_surface_commit()</code> before the compositor becomes ready for a new commit because <code>Fl_Wayland_Window_Driver::flush()</code> calls <code>Fl_Wayland_Graphics_Driver::buffer_commit()</code> only if <code>frame_cb</code> is NULL. If it's not NULL, the exact content of function <code>surface_frame_done()</code> : </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> surface_frame_done(<span class="keywordtype">void</span> *data, <span class="keyword">struct</span> wl_callback *cb, uint32_t time) {</div>
<div class="line">  <span class="keyword">struct </span>wld_window *<a class="code hl_class" href="classwindow.html">window</a> = (<span class="keyword">struct </span>wld_window *)data;</div>
<div class="line">  wl_callback_destroy(cb);</div>
<div class="line">  <a class="code hl_class" href="classwindow.html">window</a>-&gt;frame_cb = NULL;</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_class" href="classwindow.html">window</a>-&gt;buffer &amp;&amp; <a class="code hl_class" href="classwindow.html">window</a>-&gt;buffer-&gt;draw_buffer_needs_commit) {</div>
<div class="line">    Fl_Wayland_Graphics_Driver::buffer_commit(<a class="code hl_class" href="classwindow.html">window</a>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclasswindow_html"><div class="ttname"><a href="classwindow.html">window</a></div><div class="ttdef"><b>Definition</b> animated.cxx:108</div></div>
</div><!-- fragment --><p> has the effect that when the mapping operation eventually completes, Wayland runs <code>surface_frame_done()</code>, which, if the buffer's <code>draw_buffer_needs_commit</code> member is true, calls <code>Fl_Wayland_Graphics_Driver::buffer_commit()</code> anew. The net result is that the screen shows the most recent surface content.</p>
<p>This synchronization mechanism is also used when performing an interactive window resize operation. During such operation, the compositor informs the client an interactive resize is being performed and sends window resize commands at high rate (~60 Hz) to the client via the socket. Libdecor turns on flag <code>LIBDECOR_WINDOW_STATE_RESIZING</code> to inform the client, and runs function <code>handle_configure()</code> for each received resize command. Before calling Fl_Group::resize() and later Fl_Window::draw(), <code>handle_configure()</code> tests whether <code>window-&gt;frame_cb</code> is NULL. When it's not because a previous resize operation is being performed, the current resize command is skipped. At the end of the interactive resize, flag <code>LIBDECOR_WINDOW_STATE_RESIZING</code> is off and Wayland sends a final resize command which is not skipped. Overall, this ensures the client program resizes its window as frequently as it can without falling behind resize commands sent by the compositor.</p>
<p>To account for a bug in Mutter (issue #878), the <code>window-&gt;frame_cb</code> object is not created when a toplevel window is being resized and is entirely covered by one subwindow.</p>
<h3>Progressive window drawing</h3>
<p>FLTK supports progressive drawing when an app calls function Fl_Window::make_current() at any time and then calls the FLTK drawing API. This is made possible in function <code>Fl_Wayland_Window_Driver::make_current()</code> with </p><div class="fragment"><div class="line"><span class="comment">// to support progressive drawing</span></div>
<div class="line"><span class="keywordflow">if</span> ( (!Fl_Wayland_Window_Driver::in_flush_) &amp;&amp; <a class="code hl_class" href="classwindow.html">window</a>-&gt;buffer &amp;&amp; (!<a class="code hl_class" href="classwindow.html">window</a>-&gt;frame_cb)</div>
<div class="line">    &amp;&amp; <a class="code hl_class" href="classwindow.html">window</a>-&gt;buffer-&gt;draw_buffer_needs_commit &amp;&amp; (!wait_for_expose_value) ) {</div>
<div class="line">  Fl_Wayland_Graphics_Driver::buffer_commit(<a class="code hl_class" href="classwindow.html">window</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Thus, <code>buffer_commit()</code> runs only when <code>frame_cb</code> is NULL. If an app rapidly performs calls to <code>Fl_Window::make_current()</code> and to drawing functions, FLTK will copy <code>draw_buffer</code> to the Wayland buffer and instruct Wayland to map it to the display when <code>frame_cb</code> is NULL which means that the compositor is ready to start performing a mapping operation. This occurs when the progressive drawing operation begins. Later, <code>frame_cb</code> is generally found non NULL when <code>Fl_Wayland_Window_Driver::make_current()</code> runs because the compositor is busy processing the previous Wayland buffer. When the compositor has completed this processing, the client app runs <code>surface_frame_done()</code> which, provided member variable <code>draw_buffer_needs_commit</code> is true, calls <code>Fl_Wayland_Graphics_Driver::buffer_commit()</code>. This makes the compositor map the Wayland buffer in its new, more advanced, state.</p>
<p>An example of progressive drawing is given by FLTK's mandelbrot test app. When set to fullscreen, this app can be seen to progressively fill its window from top to bottom by blocks of lines, each block appearing when the compositor is ready to map a new buffer. When the compositor is not ready, the app does not block but continues computing and drawing in memory but not on display more lines of the desired Mandelbrot graph.</p>
<h1><a class="anchor" id="wayland-buffer-factory"></a>
Buffer factories</h1>
<p>Wayland names <em>buffer factory</em> a software procedure that constructs objects of type <code>struct wl_buffer</code> for use by a client application. FLTK creates a <code>wl_buffer</code> object each time an Fl_Window is mapped on a display or resized. That's done by member function <code>Fl_Wayland_Graphics_Driver::create_shm_buffer()</code> which follows this 3-step procedure to create a "buffer factory" for FLTK and to construct Wayland buffers from it:</p><ul>
<li>Libdecor function <code>libdecor_os_create_anonymous_file(off_t size)</code> creates an adequate file and mmap's it. This file lives in RAM because it is created by function <code>memfd_create()</code>. FLTK sets this file size to 10 MB unless the size of the buffer to be created is larger; in that case the anonymous file is sized to twice the buffer size.</li>
<li>Wayland function <code>wl_shm_create_pool()</code> shares this mmap'ed memory with the Wayland compositor and returns an object of type <code>struct wl_shm_pool</code> which encapsulates this memory. A record of type <code>struct Fl_Wayland_Graphics_Driver::wld_shm_pool_data</code> is created and associated to the newly created <code>wl_shm_pool</code> by <code>wl_shm_pool_set_user_data()</code>. This record stores the starting address (<code>pool_memory</code>) and size (<code>pool_size</code>) of the pool's encapsulated memory. The record also contains member <code>buffers</code> of type <code>struct wl_list</code> which stores the access point to the linked list of <code>wl_buffer</code> objects that will be created from the <code>wl_shm_pool</code>.</li>
<li>A variable named <code>chunk_offset</code> represents the offset within the pool's shared memory available for the buffer being constructed. It equals 0 when the pool has just been created and is updated as detailed below each time a buffer is created from the pool. A record of type <code>struct Fl_Wayland_Graphics_Driver::wld_buffer</code> is created. This record will contain (member <code>wl_buffer</code>) the address of a <code>wl_buffer</code> object that's created by function <code>wl_shm_pool_create_buffer()</code>. This <code>wl_buffer</code> object encapsulates a section of a given size of the pool's shared memory beginning at offset <code>chunk_offset</code> in it. Quantity <code>pool_memory + chunk_offset</code> is therefore the address of the beginning of the mmap'ed memory section encapsulated by this <code>wl_buffer</code>. Member <code>shm_pool</code> of the newly constructed <code>Fl_Wayland_Graphics_Driver::wld_buffer</code> object is set to the address of the current <code>wl_shm_pool</code> object. This record is added to the head of the linked list of current pool's buffers by a call to <code>wl_list_insert()</code>. At that point, a <code>struct Fl_Wayland_Graphics_Driver::wld_buffer</code> record is part of the linked list of all such records corresponding to <code>wl_buffer</code> objects created from the same <code>wl_shm_pool</code> object, and member <code>shm_pool</code> of this record gives the address of this <code>wl_shm_pool</code>. When a new <code>struct Fl_Wayland_Graphics_Driver::wld_buffer</code> record is to be created, <div class="fragment"><div class="line"><span class="keyword">struct </span>wld_shm_pool_data *pool_data =</div>
<div class="line">    (<span class="keyword">struct </span>wld_shm_pool_data *)wl_shm_pool_get_user_data(pool);</div>
<div class="line"><span class="keyword">struct </span>Fl_Wayland_Graphics_Driver::wld_buffer *record = wl_container_of(pool_data-&gt;buffers.next, record, link);</div>
<div class="line"><span class="keywordtype">int</span> chunk_offset = ((<span class="keywordtype">char</span>*)record-&gt;data - pool_data-&gt;pool_memory) + record-&gt;data_size;</div>
</div><!-- fragment --> gives the offset within the current pool's mmap'ed memory available for a new <code>wl_buffer</code>. Macro <code>wl_container_of()</code> gives the address of a record belonging to a linked list of records of the same type.</li>
</ul>
<p>A window's <code>wl_buffer</code> is re-filled by graphics data and committed each time the window gets redrawn, and is set to be destroyed by function <code>Fl_Wayland_Graphics_Driver::buffer_release()</code> when <code>Fl_Window::hide()</code> runs or the window is resized. When the <code>wl_buffer</code> is no longer in use, function <code>do_buffer_release()</code> gets called as explained above. It destroys the <code>wl_buffer</code> with <code>wl_buffer_destroy()</code>, and removes the corresponding <code>Fl_Wayland_Graphics_Driver::wld_buffer</code> record from the linked list of buffers from the same <code>wl_shm_pool</code>. Since new <code>Fl_Wayland_Graphics_Driver::wld_buffer</code> records are added at the head of the linked list, and since the record at the head of this list is used to compute the offset within the pool's mmap'ed memory available for a new <code>wl_buffer</code>, destruction of the last created <code>wl_buffer</code> allows to re-use the destroyed buffer's pool's memory for a new <code>wl_buffer</code>.</p>
<p>When function <code>do_buffer_release()</code> finds the list of buffers from a given pool empty, two situations can occur. 1) This pool is the current pool. Its mmap'ed memory will be re-used from offset 0 to create future <code>wl_buffer</code> objects. 2) This pool is not current. It gets destroyed with <code>wl_shm_pool_destroy()</code>, the pool's mmap'ed memory is munmap'ed, and the pool's associated <code>struct wld_shm_pool_data</code> is freed. In situation 1) above, the next <code>wl_buffer</code> to be created can need more memory than the current pool's memory size. If so, the current pool gets destroyed and replaced by a new, larger pool.</p>
<p>If the sum of <code>chunk_offset</code> plus the buffer size is larger than the current pool's size when function <code>create_shm_buffer()</code> is called, <code>chunk_offset</code> is reset to 0, and a new <code>wl_shm_pool</code> object is created and used by FLTK's "buffer factory". This mechanism allows to access new mmap'ed memory when <code>chunk_offset</code> reaches the end of the previous mmap'ed section.</p>
<p>Wayland uses also <code>wl_buffer</code> objects to support cursors. FLTK uses the "buffer factory" described here when creating custom cursors (see <a class="el" href="wayland-devel.html#custom-cursor">custom-cursor</a>) with function <code>Fl_Wayland_Window_Driver::set_cursor(const Fl_RGB_Image *,…)</code> which calls <code>create_shm_buffer()</code> via <code>set_cursor_4args()</code>, <code>custom_offscreen()</code> and <code>create_wld_buffer()</code>. In contrast, standard shaped-cursors (e.g., FL_CURSOR_INSERT) use their own "buffer factory" inside Wayland functions such as <code>wl_cursor_theme_get_cursor()</code>. Therefore, the fact that the <code>wl_buffer</code> objects behind standard cursors are never destroyed doesn't prevent disused <code>struct wl_shm_pool</code> objects from being freed because those buffers come from a distinct "buffer factory". The "buffer factory" described here is also used by function <code>offscreen_from_text()</code> when displaying dragged text in a DnD operation.</p>
<h1><a class="anchor" id="wayland-display"></a>
Displays and HighDPI support</h1>
<p>Wayland uses the concept of <em>seat</em> of type <code>struct wl_seat</code> which encompasses displays, a keyboard, a mouse, and a trackpad. Although Wayland may be in principle able to deal with several seats, FLTK's Wayland platform is conceived for one seat only. That seat may contain one or more displays, which Wayland calls <em>outputs</em>, of type <code>struct wl_output</code>.</p>
<p>As written above, function <code>registry_handle_global()</code> discovers the available seat at start-up time. This function also associates a listener to each display connected to the system by calling function <code>wl_output_add_listener()</code>. This listener's member functions run at program startup when Wayland discovers its displays (see <a class="el" href="wayland-devel.html#wayland-connection">Opening a Wayland connection</a>). Member <code>output_mode</code> runs also when the display is resized and member <code>output_scale</code> also when the Wayland scale factor (see below) is changed. FLTK defines type <code>struct</code> <a class="el" href="wayland-devel.html#wayland-output">Fl_Wayland_Screen_Driver::output</a> to store display size and scaling information. One such record is created for each display. These records are put in a <code>struct wl_list</code> accessible from member <code>outputs</code> of the single <code>Fl_Wayland_Screen_Driver</code> object.</p>
<p>FLTK uses 2 distinct scaling parameters for each display:</p><ul>
<li><code>int wld_scale;</code>. This member variable of the <code>struct</code> <a class="el" href="wayland-devel.html#wayland-output">Fl_Wayland_Screen_Driver::output</a> record typically equals 1 for standard, and 2 for HighDPI displays. The effect of value <code>n</code> of variable <code>wld_scale</code> is that 1 Wayland graphics unit represents a block of <code>nxn</code> pixels. Another effect is that a drawing buffer for a surface of size WxH units contains <code>W * n * H * n * 4</code> bytes. Member function <code>output_scale()</code> mentioned above sets this value for each system's display at startup time. Member function <code>Fl_Wayland_Graphics_Driver::buffer_commit()</code> informs the Wayland compositor of the value of <code>wld_scale</code> calling <code>wl_surface_set_buffer_scale()</code> which is enough to make FLTK apps HighDPI-aware. Under the gnome and KDE desktops, this parameter is visible in the "Settings" app, "Displays" section, "Scale" parameter which is 200% on HighDPI displays.</li>
<li><code>float gui_scale;</code>. This other member variable is where FLTK's own GUI scaling mechanism with ctrl/+/-/0/ keystrokes and with environment variable FLTK_SCALING_FACTOR operates: when FLTK is scaled at 150%, <code>gui_scale</code> is assigned value 1.5. Function <code>Fl_Wayland_Screen_Driver::scale(int n, float f)</code> assigns value <code>f</code> to the <code>gui_scale</code> member variable of display # <code>n</code>. This variable is used by function <code>Fl_Wayland_Window_Driver::make_current()</code> when it calls <code>Fl_Wayland_Graphics_Driver::set_buffer()</code> that scales the graphics driver by this factor with <code>cairo_scale()</code>.</li>
</ul>
<p>Overall, an FLTK object, say an Fl_Window, of size <code>WxH</code> FLTK units occupies <code>int(W * gui_scale) * wld_scale x int(H * gui_scale) * wld_scale</code> pixels on the display.</p>
<p>When an <code>Fl_Window</code> is to be show()'n, <code>Fl_Wayland_Window_Driver::makeWindow()</code> creates a <code>struct wl_surface</code> with <code>wl_compositor_create_surface()</code> and associates it calling <code>wl_surface_add_listener()</code> with a 2-member listener called <code>surface_listener</code> encharged of managing as follows the list of displays where this <code>wl_surface</code> will map. The <code>Fl_Window</code> possesses an initially empty linked list of displays accessible at member <code>outputs</code> of the window's <a class="el" href="wayland-devel.html#wld_window">wld_window</a> record. When the <code>Fl_Window</code>, or more exactly its associated <code>struct wl_surface</code> is mapped on a display, member <code>surface_enter()</code> of <code>surface_listener</code> runs. This function adds the display where the surface belongs to <u>the end</u> of the linked list of displays for this surface. When a surface is dragged or enlarged across the edge of a display in a multi-display system and expands on a second display, <code>surface_enter()</code> runs again, and this surface's list of displays contains 2 items. When a surface leaves a display, member <code>surface_leave()</code> of <code>surface_listener</code> runs. It removes that display from the surface's list of displays. Each time <u>the first</u> item of a surface's list of displays changes, function <code>change_scale()</code> is called and applies that display's <code>gui_scale</code> value to that surface calling <code>Fl_Window_Driver::screen_num(int)</code>. When a window is unmapped by function <code>Fl_Wayland_Window_Driver::hide()</code>, the surface's list of displays is emptied.</p>
<h3>Fractional scaling</h3>
<p>The KWin and gnome compositors allow to use <em>fractional scaling</em> that can take values between 100% and 400% that are not a multiple of 100%. Wayland implements this rendering all <code>wl_surface</code>'s as if the scaling had the next value above that is a multiple of 100% (e.g., 175% --&gt; 200%), and downsizing them to the desired fractional scale value at the compositing stage. Seen from FLTK, everything runs with <code>wld_scale</code> having an integer value (1, 2, 3 or 4).</p>
<p>Some gnome versions may natively support fractional scaling. Others require to use these commands to make them accept/refuse fractional scaling: </p><div class="fragment"><div class="line">gsettings set org.gnome.mutter experimental-features <span class="stringliteral">&quot;[&#39;scale-monitor-framebuffer&#39;]&quot;</span></div>
<div class="line">gsettings reset org.gnome.mutter experimental-features</div>
</div><!-- fragment --><h1><a class="anchor" id="wayland-mouse"></a>
Mouse and trackpad handling</h1>
<p>FLTK receives information about mouse and pointer events via a 'listener' made up of 5 pointers to functions which Wayland calls when events listed in table below occur. These functions receive from Wayland enough information in their parameters to generate corresponding FLTK events, that is, calls to <code>Fl::handle(int event_type, Fl_Window *)</code>. </p><table summary="Mouse and pointer handling" border="1">
<tr>
<th>listener function</th><th>called by Wayland when</th><th>resulting FLTK events </th></tr>
<tr>
<td><code>pointer_enter</code> </td><td>pointer enters a window</td><td>FL_ENTER </td></tr>
<tr>
<td><code>pointer_leave</code> </td><td>pointer leaves a window</td><td>FL_LEAVE </td></tr>
<tr>
<td><code>pointer_motion</code> </td><td>pointer moves inside a window</td><td>FL_MOVE </td></tr>
<tr>
<td><code>pointer_button</code> </td><td>state of mouse buttons changes</td><td>FL_PUSH, FL_RELEASE </td></tr>
<tr>
<td><code>pointer_axis</code> </td><td>trackpad is moved vertically or horizontally </td><td>FL_MOUSEWHEEL </td></tr>
</table>
<p><code>pointer_listener</code> is installed by a call to function <code>wl_pointer_add_listener()</code> made by function <code>seat_capabilities()</code> which is itself another 'listener' made up of 2 function pointers </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>wl_seat_listener seat_listener = {</div>
<div class="line">  seat_capabilities,</div>
<div class="line">  seat_name</div>
<div class="line">};</div>
</div><!-- fragment --><p> installed by a call to function <code>wl_seat_add_listener()</code> made by function <code>registry_handle_global()</code> when it receives a <code>"wl_seat"</code> interface.</p>
<h3>Handling middle mouse button clicks on window titlebars</h3>
<p>The gnome desktop, via its <code>gnome-tweaks</code> application, allows to determine what happens when a middle mouse button click occurs on a window titlebar. To obey this setting, FLTK implements part of the <a href="https://wayland.app/protocols/gtk-shell">GTK Shell</a> protocol as follows. Mutter, gnome's Wayland compositor, declares its support of the <code>GTK Shell</code> protocol calling <code>registry_handle_global()</code> with its <code>interface</code> argument equal to <code>"gtk_shell1"</code>. FLTK initializes then member variable <code>seat-&gt;gtk_shell</code> of type <code>struct gtk_shell1*</code>.</p>
<p>Member functions of <code>pointer_listener</code> mentioned above run for all mouse events on all <code>wl_surface</code> objects. The table above describes what these functions do for mouse events on FLTK-created <code>wl_surface</code> objects. But they also run for the libdecor-created <code>wl_surface</code> objects corresponding to window titlebars. Thus, member function <code>pointer_enter()</code> runs when the mouse enters a titlebar. It calls <code>Fl_Wayland_Screen_Driver::event_coords_from_surface()</code> which calls <code>Fl_Wayland_Window_Driver::surface_to_window()</code> which, as mentioned above, can distinguish FLTK-created from non FLTK-created <code>wl_surface</code> objects. This allows <code>pointer_enter()</code> to identify the entered surface as a titlebar and to assign static global variable <code>gtk_shell_surface</code> with the titlebar's <code>wl_surface</code> when the mouse enters a titlebar. Similarly, member function <code>pointer_leave()</code> sets <code>gtk_shell_surface</code> to NULL when the mouse leaves this titlebar. When there's a click on a titlebar, member function <code>pointer_button()</code> runs this code </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (gtk_shell_surface &amp;&amp; state == WL_POINTER_BUTTON_STATE_PRESSED &amp;&amp; button == BTN_MIDDLE) {</div>
<div class="line">  <span class="keyword">struct </span>gtk_surface1 *gtk_surface = gtk_shell1_get_gtk_surface(<a class="code hl_struct" href="structseat.html">seat</a>-&gt;gtk_shell, gtk_shell_surface);</div>
<div class="line">  gtk_surface1_titlebar_gesture(gtk_surface, serial, <a class="code hl_struct" href="structseat.html">seat</a>-&gt;wl_seat, GTK_SURFACE1_GESTURE_MIDDLE_CLICK);</div>
<div class="line">  gtk_surface1_release(gtk_surface);</div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="ttc" id="astructseat_html"><div class="ttname"><a href="structseat.html">seat</a></div><div class="ttdef"><b>Definition</b> libdecor-cairo.c:133</div></div>
</div><!-- fragment --><p> which ensures that what <code>gnome-tweaks</code> has assigned to middle-click events is executed. At this point, FLTK obeys what <code>libdecor</code> decides for right-click (display the window menu) and double-click (maximize the window) events on titlebars which may diverge from <code>gnome-tweaks</code> settings.</p>
<h1><a class="anchor" id="wayland-cursor"></a>
Wayland cursors</h1>
<p>Wayland defines types <code>struct wl_cursor</code> and <code>struct wl_cursor_theme</code> to hold cursor-related data. FLTK uses function <code>init_cursors()</code> from file <code>Fl_Wayland_Screen_Driver.cxx</code> to obtain the 'cursor theme' name using function <code>libdecor_get_cursor_settings()</code> of library <code>libdecor</code>. Function <code>wl_cursor_theme_load()</code> then returns a pointer to an object of type <code>struct wl_cursor_theme</code> stored in member variable <code>cursor_theme</code> of the <a class="el" href="wayland-devel.html#wayland-seat">Fl_Wayland_Screen_Driver::seat</a> record. Function <code>init_cursors()</code> is itself called by a 'listener' called <code>seat_capabilities()</code> installed when function <code>registry_handle_global()</code> receives a <code>"wl_seat"</code> interface, at program startup. It is also called when the value of the Wayland scaling factor changes: <code>output_done()</code> calls <code>try_update_cursor()</code> calls <code>init_cursors()</code>. Function <code>output_done()</code> belongs to a 'listener' installed when function <code>registry_handle_global()</code> receives a <code>"wl_output"</code> interface.</p>
<p>Each time <code>Fl_Window::cursor(Fl_Cursor)</code> runs, FLTK calls <code>Fl_Wayland_Window_Driver::set_cursor(Fl_Cursor)</code> which calls <code>wl_cursor_theme_get_cursor()</code> to set the current cursor shape to one of the standard shapes from the <code>Fl_Cursor</code> enumeration. This Wayland function selects a cursor shape based on the current <code>wl_cursor_theme</code> object and a cursor name and returns a pointer to a <code>struct wl_cursor</code>. Under the gnome desktop, cursor names are the files of directory <code>/usr/share/icons/XXXX/cursors/</code> where <code>XXXX</code> is the 'gnome cursor theme' (default= Adwaita). For example, what FLTK calls <code>FL_CURSOR_INSERT</code> corresponds to file <code>xterm</code> therein. The full correspondance between <code>Fl_Cursor</code> values and names of files therein is found in function <code>Fl_Wayland_Window_Driver::set_cursor(Fl_Cursor)</code>. FLTK stores in member variable <code>default_cursor</code> of the <a class="el" href="wayland-devel.html#wayland-seat">Fl_Wayland_Screen_Driver::seat</a> record a pointer to the currently used <code>wl_cursor</code> object, and the current <code>Fl_Cursor</code> value in member <code>standard_cursor_</code> of the <code>Fl_Wayland_Window_Driver</code> object.</p>
<p>Finally, function do_set_cursor() of file <code>Fl_Wayland_Screen_Driver.cxx</code> makes the system pointer use the current <code>wl_cursor</code> object to draw its shape on screen. That's done with a call to <code>wl_pointer_set_cursor()</code> and a few other functions.</p>
<p><a class="anchor" id="custom-cursor"></a></p><h3>Custom cursor shapes</h3>
<p>To support custom cursors, FLTK presently uses a <u>non-public type</u>, <code>struct <a class="el" href="structcursor__image.html">cursor_image</a></code>, defined in file <code>Fl_Wayland_Window_Driver.cxx</code> as follows: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structcursor__image.html">cursor_image</a> {</div>
<div class="line">  <span class="keyword">struct </span>wl_cursor_image image;</div>
<div class="line">  <span class="keyword">struct </span>wl_cursor_theme *theme;</div>
<div class="line">  <span class="keyword">struct </span>wl_buffer *<a class="code hl_struct" href="structbuffer.html">buffer</a>;</div>
<div class="line">  <span class="keywordtype">int</span> offset;</div>
<div class="line">};</div>
<div class="ttc" id="astructbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer</a></div><div class="ttdef"><b>Definition</b> libdecor-cairo.c:174</div></div>
<div class="ttc" id="astructcursor__image_html"><div class="ttname"><a href="structcursor__image.html">cursor_image</a></div><div class="ttdef"><b>Definition</b> Fl_Wayland_Window_Driver.cxx:38</div></div>
</div><!-- fragment --><p> This definition has been copied to the FLTK source code from file <a href="https://gitlab.freedesktop.org/wayland/wayland/-/blob/main/cursor/wayland-cursor.c">wayland-cursor.c</a> of the Wayland project source code because it's not accessible via Wayland header files. It shows that a pointer to a <code><a class="el" href="structcursor__image.html">cursor_image</a></code> object can also be viewed as a pointer to the embedded <code>struct wl_cursor_image</code> object, this one being part of the public Wayland API. It also shows that a <code>struct <a class="el" href="structcursor__image.html">cursor_image</a></code> object has an associated <code>struct wl_buffer</code> object used to contain the cursor's graphics.</p>
<p>Function <code>Fl_Wayland_Window_Driver::set_cursor(const Fl_RGB_Image *rgb, int hotx, int hoty)</code> gives FLTK support of custom cursor shapes. It calls <code>Fl_Wayland_Window_Driver::set_cursor_4args()</code> that creates a <code><a class="el" href="structcursor__image.html">cursor_image</a></code> object, allocates the corresponding <code>wl_buffer</code> by a call to <code>Fl_Wayland_Graphics_Driver::create_shm_buffer()</code> via <code>custom_offscreen()</code> and <code>create_wld_buffer()</code> and draws the cursor shape into that buffer using the offscreen-drawing method of FLTK.</p>
<p>The public type <code>struct wl_cursor</code> is essentially an array of <code>wl_cursor_image</code> objects and a name: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>wl_cursor {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> image_count;</div>
<div class="line">  <span class="keyword">struct </span>wl_cursor_image **images;</div>
<div class="line">  <span class="keywordtype">char</span> *name;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Function <code>Fl_Wayland_Window_Driver::set_cursor_4args()</code> also creates a <code>struct wl_cursor</code> object containing a single <code>wl_cursor_image</code>, which is in fact the <code><a class="el" href="structcursor__image.html">cursor_image</a></code>. Finally, a <code>struct Fl_Wayland_Window_Driver::custom_cursor</code> (see <a class="el" href="wayland-devel.html#wld_window">wld_window</a>) is allocated and used to memorize the <code>struct wl_cursor</code> and the cursor's image and hotspot. A pointer to this <code>struct Fl_Wayland_Window_Driver::custom_cursor</code> object is stored in member <code>custom_cursor</code> of the window's <a class="el" href="wayland-devel.html#wld_window">wld_window</a>.</p>
<p>Function <code>Fl_Wayland_Window_Driver::set_cursor_4args()</code> is also called when a window with a custom cursor is moved between distinct displays or when a display is rescaled to adapt the cursor size to the new display's scale factor.</p>
<p>Static member function <code>Fl_Wayland_Window_Driver::delete_cursor()</code> is used to delete any custom cursor shape. This occurs when a window associated to a custom cursor is un-mapped and when such a window gets associated to a standard cursor or to a new custom cursor.</p>
<h1><a class="anchor" id="wayland-text"></a>
Keyboard support</h1>
<p>The "Mouse handling" section above mentioned function <code>seat_capabilities()</code> that Wayland calls when the app discovers its "seat". Presence of flag <code>WL_SEAT_CAPABILITY_KEYBOARD</code> in argument <code>capabilities</code> of this function indicates that a keyboard is available. In that case, a call to <code>wl_seat_get_keyboard()</code> returns a pointer stored in member <code>wl_keyboard</code> of the <a class="el" href="wayland-devel.html#wayland-seat">Fl_Wayland_Screen_Driver::seat</a> object, and a call to <code>wl_keyboard_add_listener()</code> installs a 6-member listener of type <code>struct wl_keyboard_listener</code>. These 6 FLTK-defined, callback functions are used as follows.</p>
<p>1) Function <code>wl_keyboard_keymap()</code> runs when the app starts and also if the keyboard layout is changed during run-time. It allows initialization of access to this keyboard. Noticeably, member <code>xkb_state</code> of type <code>struct xkb_state*</code> of the current <a class="el" href="wayland-devel.html#wayland-seat">Fl_Wayland_Screen_Driver::seat</a> record is adequately initialized.</p>
<p>2-3) Functions <code>wl_keyboard_enter()</code> and <code>wl_keyboard_leave()</code>, called when focus enters and leaves a surface, send <code>FL_FOCUS</code> and <code>FL_UNFOCUS</code> events to the <code>Fl_Window</code> object corresponding to this surface.</p>
<p>4) Function <code>wl_keyboard_key()</code> runs each time a keyboard key is pressed or released. Its argument <code>key</code>, to which 8 must be added, provides the keycode via function <code>xkb_state_key_get_one_sym()</code> and then the corresponding text via function <code>xkb_state_key_get_utf8()</code> which is put in <code>Fl::e_text</code>. Then, a few calls to functions whose name begin with <code>xkb_compose_</code> are necessary to support dead and compose keys. Finally a call to <code>Fl::handle()</code> sends an <code>FL_KEYDOWN</code> or <code>FL_KEYUP</code> event to the appropriate <code>Fl_Window</code>. Also, function <code>wl_keyboard_key()</code> uses global variable <code>Fl_Int_Vector key_vector</code> to record all currently pressed keys. This is the base of the implementation of <code>Fl_Wayland_Screen_Driver::event_key(int)</code>.</p>
<p>5) Function <code>wl_keyboard_modifiers()</code> runs when a modifier key (e.g., shift, control) is pressed or released. Calls to functions <code>xkb_state_update_mask()</code> and <code>xkb_state_mod_name_is_active()</code> allow FLTK to set <code>Fl::e_state</code> adequately.</p>
<p>6) Function <code>wl_keyboard_repeat_info()</code> does not run, for now, because this would require version 4 of the <code>wl_keyboard</code> object which is at version 2 in all tested Wayland compositors.</p>
<h1><a class="anchor" id="wayland-text-input"></a>
Support of text input methods</h1>
<p>When the connected Wayland compositor supports text input methods, function <code>registry_handle_global()</code> gets called with its <code>interface</code> argument equal to <code>zwp_text_input_manager_v3_interface.name</code>. The following call to <code>wl_registry_bind()</code> returns a pointer to type <code>struct zwp_text_input_manager_v3</code> that is stored as member <code>text_input_base</code> of the <code>Fl_Wayland_Screen_Driver</code> object.</p>
<p>Later, when function <code>seat_capabilities()</code> runs, <code>text_input_base</code> is found not NULL, which triggers a call to function <code>zwp_text_input_manager_v3_get_text_input()</code> returning a value of type <code>struct zwp_text_input_v3 *</code> and stored as member <code>text_input</code> of the <a class="el" href="wayland-devel.html#wayland-seat">Fl_Wayland_Screen_Driver::seat</a> object. Next, a call to <code>zwp_text_input_v3_add_listener()</code> associates this <code>text_input</code> with a 6-member listener of type <code>struct zwp_text_input_v3_listener</code>. These 6 FLTK-defined, callback functions are used as follows.</p>
<p>1-2) Functions <code>text_input_enter()</code> and <code>text_input_leave()</code> run when text input enters or leaves a surface.</p>
<p>3-4) Functions <code>text_input_preedit_string()</code> and <code>text_input_commit_string()</code> are called when the text input method prepares the client app to later insert 'marked' text or regular text, respectively. <a class="el" href="classComplex.html">Complex</a> text input often begins by inserting temporary text which is said to be 'marked' before replacing it with the text that will stay in the document. FLTK underlines marked text to distinguish it from regular text.</p>
<p>5) Function <code>text_input_done()</code> runs when it's time to send either regular or marked text to the client app. This is done by function <code>send_text_to_fltk()</code> which uses static variables <code>current_pre_edit</code>, <code>pending_pre_edit</code> and <code>pending_commit</code> to determine the sent text.</p>
<p>6) Function <code>text_input_delete_surrounding_text()</code> has no effect at present, without this preventing input methods that have been tested with FLTK from working satisfactorily.</p>
<p>It's necessary to inform the running text input method of the current location of the insertion point in the active surface. This information allows the input method to map its auxiliary window close to the insertion point. The flow of information on this topic is as follows:</p><ul>
<li>The two FLTK widgets supporting text input, Fl_Input_ and Fl_Text_Display, transmit to FLTK the window coordinates of the bottom of the current insertion point and the line height each time they change calling function <code>fl_set_spot()</code>.</li>
<li>fl_set_spot() calls the platform override of virtual member function <code>Fl_Screen_Driver::set_spot()</code>. Under Wayland, this just calls <code>Fl_Wayland_Screen_Driver::insertion_point_location(int x, int y, int height)</code> which calls <code>zwp_text_input_v3_set_cursor_rectangle()</code> to inform the text input method about the surface position and size of the insertion point and also memorizes this information in static member variables of class <code>Fl_Wayland_Screen_Driver</code>.</li>
<li>Callback function <code>text_input_enter()</code> calls <code>Fl_Wayland_Screen_Driver::insertion_point_location(int *x, int *y, int *height)</code> which gives it the stored position information, and then calls <code>zwp_text_input_v3_set_cursor_rectangle()</code> to inform the text input method about the position of the insertion point.</li>
</ul>
<h1><a class="anchor" id="wayland-libdecor"></a>
Interface with libdecor</h1>
<p>FLTK uses a library called <a href="https://gitlab.freedesktop.org/libdecor/libdecor/-/blob/master/README.md">libdecor</a> to determine whether the Wayland compositor uses CSD or SSD mode, and also to draw window titlebars when in CSD mode (see <a class="el" href="bundled-libs.html#bundled-libdecor">libdecor:</a>). <code>Libdecor</code> is conceived to be present in a shared library linked to the Wayland client application which itself, and if the running Wayland compositor uses CSD mode, loads another shared library intended to draw titlebars in a way that best matches the Desktop. As of late 2023, libdecor contains two titlebar-drawing plugins:</p><ul>
<li><code>libdecor-gtk</code> intended for the Gnome desktop;</li>
<li><code>libdecor-cairo</code> for other situations.</li>
</ul>
<p>On recent Linux distributions, FLTK uses the system <code>libdecor</code> shared library available via packages <code>libdecor-0-dev</code> and <code>libdecor-0-plugin-1-gtk</code>. On earlier Linux versions, or if CMake option <code>FLTK_USE_SYSTEM_LIBDECOR</code> is set to OFF, FLTK bundles the most recent source code of <code>libdecor</code> and its plugins. The libdecor code bundled inside FLTK is compiled and put in libfltk. FLTK uses <code>libdecor-gtk</code> when software package <code>libgtk-3-dev</code> is present in the build system, and <code>libdecor-cairo</code> otherwise. FLTK prefixes all symbols of its bundled libdecor with "fl_". This allows an FLTK client app to link to other libraries which may use the system version of libdecor.</p>
<p><code>Libdecor</code> uses the Wayland protocol <a href="https://wayland.app/protocols/xdg-decoration-unstable-v1">XDG decoration</a> to request being decorated by a supporting compositor. If the running compositor supports SSD, <code>libdecor</code> doesn't draw window titlebars because the compositor does it. That is what happens with the <code>KWin</code> and <code>Sway</code> compositors. However, if environment variable <code>LIBDECOR_FORCE_CSD</code> is defined to value <code>1</code> when an FLTK app runs, <code>libdecor</code> instructs an SSD-able compositor to refrain from decorating its windows and decorates windows itself.</p>
<p>Whatever the value of <code>FLTK_USE_SYSTEM_LIBDECOR</code>, FLTK and <code>libdecor</code> use environment variable <code>LIBDECOR_PLUGIN_DIR</code> as follows: if this variable is defined and points to the name of a directory, this directory is searched for a potential <code>libdecor</code> plugin in the form of a shared library; if one is found, FLTK and <code>libdecor</code> load it and use it.</p>
<p>The <code>libdecor</code> source code bundled in FLTK is identical to that of the <code>libdecor</code> repository. Nevertheless, FLTK uses this code with some minor changes. For example, except if <code>FLTK_USE_SYSTEM_LIBDECOR</code> is 1, FLTK needs to modify function <code>libdecor_new()</code> charged of loading the plugin, to make it use the plugin code that is included in libfltk if none is found as a dynamic library. This is done as follows in file <code>libdecor/build/fl_libdecor.c</code>: </p><div class="fragment"><div class="line"><span class="preprocessor">#define libdecor_new libdecor_new_orig</span></div>
<div class="line"><span class="preprocessor">#include &quot;../src/libdecor.c&quot;</span></div>
<div class="line"><span class="preprocessor">#undef libdecor_new</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> libdecor_new() { <span class="comment">// FLTK rewrite of this function</span></div>
<div class="line">  ……</div>
<div class="line">}</div>
</div><!-- fragment --><p> FLTK compiles file <code>fl_libdecor.c</code> which includes <code><a class="el" href="libdecor_8c_source.html">libdecor.c</a></code> to the effect that all of the <code>libdecor</code> code becomes part of libfltk except that function <code>libdecor_new()</code> is substituted by its FLTK rewrite, without file <code><a class="el" href="libdecor_8c_source.html">libdecor.c</a></code> being modified at all. This trick is also used to modify function <code>libdecor_frame_set_minimized()</code> to bypass a bug in the Weston compositor before version 10. Similarly, FLTK compiles file <code>fl_libdecor-plugins.c</code> which includes either <code>libdecor-gtk.c</code> or <code><a class="el" href="libdecor-cairo_8c_source.html">libdecor-cairo.c</a></code> to the effect that the desired plugin becomes part of libfltk.</p>
<p>To support function <code>Fl_Widget_Surface::draw_decorated_window()</code> that draws a mapped window and its titlebar, FLTK needs to perform two operations: 1) identify what plugin is operating, and 2) call a function that is specific of that plugin and that returns the pixels of the drawn titlebar.</p>
<p>FLTK performs operation 1) above using its function <code>get_libdecor_plugin_description()</code> of file <code>fl_libdecor-plugins.c</code> that returns a human readable string describing the running plugin. Each plugin puts its own string in member <code>description</code> of a record of type <code>struct <a class="el" href="structlibdecor__plugin__description.html">libdecor_plugin_description</a></code>. Although this type is public in header file <code><a class="el" href="libdecor-plugin_8h_source.html">libdecor-plugin.h</a></code>, accessing the symbol defined by the plugin to store a pointer to a value of this type is complicated for a reason and solved by a method detailed in a comment before function <code>get_libdecor_plugin_description()</code>.</p>
<p>Operation 2) above is done by FLTK-defined function <code>fl_libdecor_titlebar_buffer()</code> from file <code>fl_libdecor-plugins.c</code>. This function calls <code>get_libdecor_plugin_description()</code> seen above to get the running plugin's descriptive string. That is <code>"GTK3 plugin"</code> with <code>libdecor-gtk</code>. FLTK function <code>gtk_titlebar_buffer()</code> is then called, and returns a pointer to the start of a byte buffer containing the titlebar graphics. That is, again, not possible with the public <code>libdecor</code> API. Therefore, FLTK copies to <code>fl_libdecor-plugins.c</code> the definitions of several types given in <code>libdecor-gtk.c</code> or <code><a class="el" href="libdecor-cairo_8c_source.html">libdecor-cairo.c</a></code> such as type <code>struct <a class="el" href="structborder__component.html">border_component</a></code>.</p>
<h1><a class="anchor" id="wayland-clipboard"></a>
Copy/Paste/Drag-n-Drop</h1>
<p>FLTK follows the procedure that is very well described in item "Wayland clipboard and drag &amp;
drop" of the <a class="el" href="wayland-devel.html#wayland-doc">Documentation resources</a>. All corresponding source code is in file <code>src/drivers/Wayland/fl_wayland_clipboard_dnd.cxx</code>.</p>
<p>This part of the <a class="el" href="wayland-devel.html#wayland-seat">Fl_Wayland_Screen_Driver::seat</a> record stores pointers to Wayland objects used for clipboard and D-n-D operations: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>wl_data_device_manager *data_device_manager;</div>
<div class="line"><span class="keyword">struct </span>wl_data_device *data_device;</div>
<div class="line"><span class="keyword">struct </span>wl_data_source *data_source;</div>
</div><!-- fragment --><p>FLTK can copy or paste plain UTF-8 text or image data to/from the clipboard. Images are copied to the clipboard as <code>image/bmp</code> mime type. Images in <code>image/bmp</code> or <code>image/png</code> mime types from the clipboard can be pasted to FLTK apps.</p>
<p>Files dropped are received one pathname per line, with no <code>'\n'</code> after the last pathname.</p>
<h1><a class="anchor" id="wayland-egl"></a>
EGL as support for OpenGL</h1>
<p>Wayland uses <a href="https://www.khronos.org/api/egl">EGL™</a> to interface OpenGL with the underlying native platform window system. OpenGL-using FLTK apps are therefore linked to <code>libwayland-egl.so</code> and <code>libEGL.so</code> in addition to <code>libGL.so</code> and <code>libGLU.so</code>.</p>
<p>EGL completely hides the <code>wl_buffer</code> objects it uses to draw to GL windows. The <a class="el" href="wayland-devel.html#wld_buffer">wld_buffer</a> structure and the 'buffer factory' described previously are not used for <code>Fl_Gl_Window's</code> : the <code>buffer</code> member of an <code>Fl_Gl_Window's</code> <a class="el" href="wayland-devel.html#wld_window">wld_window</a> structure is always NULL.</p>
<p>EGL is initialized calling member function <code>Fl_Wayland_Gl_Window_Driver::init()</code> once, the first time the <code>Fl_Wayland_Gl_Window_Driver</code> c'tor runs. That is done with calls to <code>eglGetDisplay(), eglInitialize()</code>, and <code>eglBindAPI()</code>.</p>
<p>Member function <code>Fl_Wayland_Gl_Window_Driver::find()</code> calls <code>eglChooseConfig()</code> to filter the set of GL configurations that match the <code>Fl_Gl_Window's</code> mode(), and puts in the returned <code>Fl_Gl_Choice</code> object the first matching configuration. The filtering gets done with bits <code>EGL_WINDOW_BIT</code>, to support the creation of window surfaces, and <code>EGL_OPENGL_BIT</code>, to support the creation of OpenGL contexts.</p>
<p>EGL needs 2 more objects created for each <code>Fl_Gl_Window</code>. They have types <code>struct wl_egl_window</code> and <code>EGLSurface</code>, and are created by member function <code>Fl_Wayland_Gl_Window_Driver::make_current_before()</code> which runs at the beginning of <code>Fl_Gl_Window::make_current()</code>. The first argument of the call to <code>wl_egl_window_create()</code> therein has type <code>struct wl_surface *</code> and is what connects EGL with the targeted Wayland window.</p>
<p>EGL creates with <code>eglCreateContext()</code> an object of type <code>EGLContext</code> via member function <code>Fl_Wayland_Gl_Window_Driver::create_gl_context()</code> called by <code>Fl_Gl_Window::make_current()</code>. Types <code>EGLContext</code> and <code>GLContext</code> are 2 names for the same object. The call to <code>eglCreateContext()</code> is made asking for a GL context of version at least 2. This does not prevent from obtaining contexts of higher versions, namely above 3.2, which are compatible with version 2 (the so-called compatibility profile) under all tested Linux systems.</p>
<p>FLTK function <code>Fl_Gl_Window::make_current()</code> calls overridden function <code>Fl_Wayland_Gl_Window_Driver::set_gl_context()</code> which calls EGL function <code>eglMakeCurrent()</code> when the cached context changes.</p>
<p>FLTK calls function <code>Fl_Wayland_Gl_Window_Driver::swap_buffers()</code> each time it wants a GL context to be sent to the display. This function contains some pure GL code to emulate an overlay buffer to support Fl_Gl_Window objects overriding their <code>draw_overlay()</code> member function. Then, it calls function <code>eglSwapBuffers()</code>.</p>
<p>The overridden <code>Fl_Wayland_Gl_Window_Driver::resize()</code> function is implemented with calls to <code>wl_egl_window_get_attached_size()</code> and <code>wl_egl_window_resize()</code>.</p>
<p>Class <code>Fl_Wayland_Gl_Plugin</code> exists to allow <code>libfltk</code> to call functions from <code>libfltk_gl</code>, <code>libwayland-egl.so</code> or <code>libEGL.so</code> and without having <code>libfltk</code> force linking any FLTK app with these GL-related libraries. For example, <code>Fl_Wayland_Window_Driver::flush()</code> needs to call <code>Fl_Gl_Window::valid(0)</code>.</p>
<h3>Throttling GL window redraws</h3>
<p>Although no documentation covering this subject was found, the EGL library internally uses <code>wl_callback</code> objects to throttle GL window redraws, and FLTK needs not interfere with these operations. Nevertheless FLTK creates and uses <code>wl_callback</code> objects for GL windows in 2 cases:</p><ul>
<li>when a decorated GL window is being interactively resized. Function <code>Fl_Wayland_Gl_Window_Driver::resize()</code> creates a <code>wl_callback</code> object, assigns it to xid-&gt;frame_cb and calls <code>wl_callback_add_listener()</code> before calling <code>wl_egl_window_resize()</code>. This allows the mechanism described above that prevents surfaces from being resized too frequently to operate with decorated <code>Fl_GL_Window's</code> too.</li>
<li>when a GL subwindow is being refreshed by <code>Fl_Wayland_Gl_Window_Driver::swap_buffers()</code>. FLTK checks that <code>xid-&gt;frame_cb</code> is NULL and if so creates a <code>wl_callback</code> calling <code>wl_surface_frame()</code> before calling <code>eglSwapBuffers()</code>. This is useful if the GL subwindow becomes entirely out from the screen area. In that case, the Mutter compositor stops signaling that the subwindow is ready for new commits which FLTK detects because <code>xid-&gt;frame_cb</code> remains non-NULL. If the subwindow eventually re-appears partially on-screen, <code>xid-&gt;frame_cb</code> becomes NULL and FLTK calls <code>eglSwapBuffers()</code> to redraw the GL scene.</li>
</ul>
<h1><a class="anchor" id="wayland-type"></a>
FLTK-defined, Wayland-specific types</h1>
<p><a class="anchor" id="wld_window"></a></p><h3>struct wld_window</h3>
<p>Defined in <code>Fl_Wayland_Window_Driver.H</code>. One such record is created for each shown()'n Fl_Window by <code>Fl_Wayland_Window_Driver::makeWindow()</code>. Function <code>fl_wl_xid(Fl_Window*)</code> returns a pointer to the <code>struct wld_window</code> of its argument. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>wld_window {</div>
<div class="line">  Fl_Window *fl_win;</div>
<div class="line">  <span class="keyword">struct </span>wl_list outputs; <span class="comment">// linked list of displays where part or whole of window maps</span></div>
<div class="line">  <span class="keyword">struct </span>wl_surface *wl_surface; <span class="comment">// the window&#39;s surface</span></div>
<div class="line">  <span class="keyword">struct </span>wl_callback *frame_cb; <span class="comment">// non-NULL until Wayland can process new surface commit</span></div>
<div class="line">  <span class="keyword">struct </span>Fl_Wayland_Graphics_Driver::wld_buffer *<a class="code hl_struct" href="structbuffer.html">buffer</a>; <span class="comment">// see \ref wld_buffer</span></div>
<div class="line">  <span class="keyword">struct </span>xdg_surface *xdg_surface;</div>
<div class="line">  <span class="keyword">enum</span> Fl_Wayland_Window_Driver::kind kind; <span class="comment">// DECORATED or POPUP or SUBWINDOW or UNFRAMED</span></div>
<div class="line">  <span class="keyword">union </span>{</div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_class" href="structlibdecor__frame.html">libdecor_frame</a> *frame; <span class="comment">// for DECORATED windows</span></div>
<div class="line">    <span class="keyword">struct </span>wl_subsurface *subsurface; <span class="comment">// for SUBWINDOW windows</span></div>
<div class="line">    <span class="keyword">struct </span>xdg_popup *xdg_popup; <span class="comment">// for POPUP windows</span></div>
<div class="line">    <span class="keyword">struct </span>xdg_toplevel *xdg_toplevel; <span class="comment">// for UNFRAMED windows</span></div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">struct </span>Fl_Wayland_Window_Driver::custom_cursor {</div>
<div class="line">    <span class="keyword">struct </span>wl_cursor *wl_cursor;</div>
<div class="line">    <span class="keyword">const</span> Fl_RGB_Image *rgb;</div>
<div class="line">    <span class="keywordtype">int</span> hotx, hoty;</div>
<div class="line">  } *custom_cursor; <span class="comment">// non-null when using custom cursor</span></div>
<div class="line">  <span class="keywordtype">int</span> configured_width; <span class="comment">// used when negotiating window size with the compositor</span></div>
<div class="line">  <span class="keywordtype">int</span> configured_height;</div>
<div class="line">  <span class="keywordtype">int</span> floating_width; <span class="comment">// helps restoring size after un-maximizing</span></div>
<div class="line">  <span class="keywordtype">int</span> floating_height;</div>
<div class="line">  <span class="keywordtype">int</span> state; <span class="comment">// indicates whether window is fullscreen, maximized. Used otherwise for POPUPs</span></div>
<div class="line">  <span class="keywordtype">bool</span> covered; <span class="comment">// specially for Mutter and issue #878</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="draw_buffer"></a></p><h3>struct Fl_Wayland_Graphics_Driver::draw_buffer</h3>
<p>Defined in file <code>Fl_Wayland_Graphics_Driver.H</code>. One such record is created when an Fl_Image_Surface object is created. One such record is also embedded inside each <code>struct Fl_Wayland_Graphics_Driver::wld_buffer</code> record (see <a class="el" href="wayland-devel.html#wld_buffer">wld_buffer</a>).</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Fl_Wayland_Graphics_Driver::draw_buffer {</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code hl_struct" href="structbuffer.html">buffer</a>; <span class="comment">// address of the beginning of the Cairo image surface&#39;s byte array</span></div>
<div class="line">  cairo_t *cairo_; <span class="comment">// used when drawing to the Cairo image surface</span></div>
<div class="line">  <span class="keywordtype">size_t</span> data_size; <span class="comment">// of buffer and wl_buffer, in bytes</span></div>
<div class="line">  <span class="keywordtype">int</span> stride; <span class="comment">// bytes per line</span></div>
<div class="line">  <span class="keywordtype">int</span> width; <span class="comment">// in pixels</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> FLTK gives offscreen buffers the platform-dependent type <code>Fl_Offscreen</code> which is in fact member <code>cairo_</code> of <code>struct Fl_Wayland_Graphics_Driver::draw_buffer</code>. Thus, a variable with type <code>Fl_Offscreen</code> needs be cast to type <code>cairo_t*</code>. Static member function <code>struct draw_buffer *offscreen_buffer(Fl_Offscreen)</code> of class <code>Fl_Wayland_Graphics_Driver</code> returns the <code>draw_buffer</code> record corresponding to an <code>Fl_Offscreen</code> value.</p>
<p><a class="anchor" id="wld_buffer"></a></p><h3>struct Fl_Wayland_Graphics_Driver::wld_buffer</h3>
<p>Defined in file <code>Fl_Wayland_Graphics_Driver.H</code>. One such record is created by <code>Fl_Wayland_Graphics_Driver::create_wld_buffer()</code> when an Fl_Window is show()'n or resized, when a custom cursor shape is created, or when text is dragged. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Fl_Wayland_Graphics_Driver::wld_buffer {</div>
<div class="line">  <span class="keyword">struct </span>draw_buffer draw_buffer; <span class="comment">// see draw_buffer</span></div>
<div class="line">  <span class="keyword">struct </span>wl_list link; <span class="comment">// links all buffers from the same wl_shm_pool</span></div>
<div class="line">  <span class="keyword">struct </span>wl_buffer *wl_buffer; <span class="comment">// the Wayland buffer</span></div>
<div class="line">  <span class="keywordtype">void</span> *data; <span class="comment">// address of the beginning of the Wayland buffer&#39;s byte array</span></div>
<div class="line">  <span class="keyword">struct </span>wl_shm_pool *shm_pool; <span class="comment">// pter to wl_shm_pool from which this wl_buffer comes</span></div>
<div class="line">  <span class="keywordtype">bool</span> draw_buffer_needs_commit; <span class="comment">// true when draw_buffer has been modified but not yet committed</span></div>
<div class="line">  <span class="keywordtype">bool</span> in_use; <span class="comment">// true while being committed</span></div>
<div class="line">  <span class="keywordtype">bool</span> released; <span class="comment">// true after buffer_release() was called</span></div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="wayland-output"></a></p><h3>struct Fl_Wayland_Screen_Driver::output</h3>
<p>Defined in Fl_Wayland_Screen_Driver.H. One such record is created for each display of the system by function <code>registry_handle_global()</code> when it receives a <code>"wl_output"</code> interface. These records are kept in a linked list of them all, and an identifier of this linked list is stored in member <code>outputs</code> of the unique <code>Fl_Wayland_Screen_Driver</code> object FLTK uses. Thus, </p><div class="fragment"><div class="line">Fl_Wayland_Screen_Driver *scr_driver = (Fl_Wayland_Screen_Driver*)Fl::screen_driver();</div>
<div class="line"><span class="keyword">struct </span>wl_list list_of_all_displays = scr_driver-&gt;outputs;</div>
</div><!-- fragment --><p> gives access, the Wayland way, to the linked list of displays in the system. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Fl_Wayland_Screen_Driver::output { <span class="comment">// one record for each display</span></div>
<div class="line">  uint32_t id; <span class="comment">// an identifier of the display</span></div>
<div class="line">  <span class="keywordtype">int</span> x, y; <span class="comment">// logical position of the top-left of display</span></div>
<div class="line">  <span class="keywordtype">int</span> width; <span class="comment">// nber of horizontal pixels</span></div>
<div class="line">  <span class="keywordtype">int</span> height; <span class="comment">// nber of vertical pixels</span></div>
<div class="line">  <span class="keywordtype">float</span> dpi; <span class="comment">// at this point, always 96.</span></div>
<div class="line">  <span class="keyword">struct </span>wl_output *wl_output; <span class="comment">// the Wayland object for this display</span></div>
<div class="line">  <span class="keywordtype">int</span> wld_scale; <span class="comment">// Wayland scale factor</span></div>
<div class="line">  <span class="keywordtype">float</span> gui_scale; <span class="comment">// FLTK scale factor</span></div>
<div class="line">  <span class="keywordtype">bool</span> done; <span class="comment">// true means record members have been initialized</span></div>
<div class="line">  <span class="keyword">struct </span>wl_list link; <span class="comment">// links these records together</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> It's possible to get the FLTK-defined record associated to a display from the Wayland-associated object for the same display, say <code>struct wl_output *wl_output</code>, by this call: <code>(struct Fl_Wayland_Screen_Driver::output *)wl_output_get_user_data(wl_output)</code>.</p>
<p><a class="anchor" id="wayland-seat"></a></p><h3>struct Fl_Wayland_Screen_Driver::seat</h3>
<p>Defined in file <code>Fl_Wayland_Screen_Driver.H</code>. One record is created by function <code>registry_handle_global()</code> when it receives a <code>"wl_seat"</code> or <code>wl_data_device_manager_interface.name</code> interface. A pointer to this struct is stored in member <code>seat</code> of the client's unique <code>Fl_Wayland_Screen_Driver</code> object. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Fl_Wayland_Screen_Driver::seat {</div>
<div class="line">  <span class="keyword">struct </span>wl_seat *wl_seat;</div>
<div class="line">  <span class="keyword">struct </span>wl_pointer *wl_pointer;</div>
<div class="line">  <span class="keyword">struct </span>wl_keyboard *wl_keyboard;</div>
<div class="line">  uint32_t keyboard_enter_serial;</div>
<div class="line">  <span class="keyword">struct </span>wl_surface *keyboard_surface;</div>
<div class="line">  <span class="keyword">struct </span>wl_list pointer_outputs;</div>
<div class="line">  <span class="keyword">struct </span>wl_cursor_theme *cursor_theme;</div>
<div class="line">  <span class="keyword">struct </span>wl_cursor *default_cursor;</div>
<div class="line">  <span class="keyword">struct </span>wl_surface *cursor_surface;</div>
<div class="line">  <span class="keyword">struct </span>wl_surface *pointer_focus;</div>
<div class="line">  <span class="keywordtype">int</span> pointer_scale;</div>
<div class="line">  uint32_t serial;</div>
<div class="line">  uint32_t pointer_enter_serial;</div>
<div class="line">  <span class="keyword">struct </span>wl_data_device_manager *data_device_manager;</div>
<div class="line">  <span class="keyword">struct </span>wl_data_device *data_device;</div>
<div class="line">  <span class="keyword">struct </span>wl_data_source *data_source;</div>
<div class="line">  <span class="keyword">struct </span>xkb_state *xkb_state;</div>
<div class="line">  <span class="keyword">struct </span>xkb_context *xkb_context;</div>
<div class="line">  <span class="keyword">struct </span>xkb_keymap *xkb_keymap;</div>
<div class="line">  <span class="keyword">struct </span>xkb_compose_state *xkb_compose_state;</div>
<div class="line">  <span class="keywordtype">char</span> *name;</div>
<div class="line">  <span class="keyword">struct </span>zwp_text_input_v3 *text_input;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="wayland-doc"></a>
Documentation resources</h1>
<table summary="Wayland Documentation" width="100%" border="1">
<tr>
<td><a href="https://wayland-book.com/">The Wayland book</a>  </td><td>Extensive introduction to Wayland programming written by the author of the <em>sway</em> compositor, unfortunately unachieved. </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a href="https://wayland.app/protocols/">Wayland Explorer</a>  </td><td>Documentation of all Wayland protocols, both stable and unstable. A language-independent syntax is used which makes function names usable from C or C++ not always obvious. Some useful functions seem undocumented here for an unclear reason. </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a href="https://wayland.freedesktop.org/docs/html/apa.html">Wayland Protocol Specification</a>  </td><td>Documentation for all functions of the Wayland core protocol. </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a href="https://emersion.fr/blog/2020/wayland-clipboard-drag-and-drop/">Wayland clipboard and drag &amp; drop</a>  </td><td>Detailed explanation of how clipboard and drag-and-drop work under Wayland. </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a href="https://dcz_self.gitlab.io/posts/input_method/">Wayland and input methods</a>  </td><td>Blog article introducing to the issue of text input methods under Wayland. </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><a href="https://gitlab.freedesktop.org/wayland/wayland-protocols/-/issues/39">Input Method Hub</a>  </td><td>Entry page for input method support giving newcomers a first understanding of what input methods are and how they are implemented in Wayland. </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: Fl_Terminal Technical Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Fl_Terminal Technical Documentation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This chapter covers the vt100/xterm style "escape codes" used by <a class="el" href="classFl__Terminal.html" title="Terminal widget supporting Unicode/utf-8, ANSI/xterm escape codes with full RGB color control.">Fl_Terminal</a> for cursor positioning, text colors, and other display screen control features such as full or partial screen clearing, up/down scrolling, character insert/delete, etc.</p>
<h1><a class="anchor" id="Fl_Terminal_escape_codes"></a>
The Escape Codes Fl_Terminal Supports</h1>
<p>These are the escape codes <a class="el" href="classFl__Terminal.html" title="Terminal widget supporting Unicode/utf-8, ANSI/xterm escape codes with full RGB color control.">Fl_Terminal</a> actually supports, and is not the 'complete' list that e.g. xterm supports. Most of the important stuff has been implemented, but esoteric features (such as scroll regions) has not.</p>
<p>Features will be added as the widget matures.</p>
<div class="fragment"><div class="line">│    --------------------------------------------------------</div>
<div class="line">│    --- The CSI (Control Sequence Introducer, or &quot;ESC[&quot;) ---</div>
<div class="line">│    --------------------------------------------------------</div>
<div class="line">│</div>
<div class="line">│    ESC[#@ - (ICH) Insert blank Chars (default=1)</div>
<div class="line">│    ESC[#A - (CUU) Cursor Up, no scroll/wrap</div>
<div class="line">│    ESC[#B - (CUD) Cursor Down, no scroll/wrap</div>
<div class="line">│    ESC[#C - (CUF) Cursor Forward, no wrap</div>
<div class="line">│    ESC[#D - (CUB) Cursor Back, no wrap</div>
<div class="line">│    ESC[#E - (CNL) Cursor Next Line (crlf) xterm, !gnome</div>
<div class="line">│    ESC[#F - (CPL) Cursor Preceding Line: move to sol and up # lines</div>
<div class="line">│    ESC[#G - (CHA) Cursor Horizontal Absolute positioning</div>
<div class="line">│      │</div>
<div class="line">│      ├── ESC[G   - move to column 1 (start of line, sol)</div>
<div class="line">│      └── ESC[#G  - move to column #</div>
<div class="line">│</div>
<div class="line">│    ESC[#H - (CUP) Cursor Position (#&#39;s are 1 based)</div>
<div class="line">│      │</div>
<div class="line">│      ├── ESC[H    - go to row #1</div>
<div class="line">│      ├── ESC[#H   - go to (row #) (default=1)</div>
<div class="line">│      └── ESC[#;#H - go to (row# ; col#)</div>
<div class="line">│</div>
<div class="line">│    ESC[#I - (CHT) Cursor Horizontal Tab: tab forward</div>
<div class="line">│      │</div>
<div class="line">│      └── ESC[#I - tab # times (default 1)</div>
<div class="line">│</div>
<div class="line">│    ESC[#J - (ED) Erase in Display</div>
<div class="line">│      │</div>
<div class="line">│      ├── ESC[0J - clear to end of display (default)</div>
<div class="line">│      ├── ESC[1J - clear to start of display</div>
<div class="line">│      ├── ESC[2J - clear all lines</div>
<div class="line">│      └── ESC[3J - clear screen history</div>
<div class="line">│</div>
<div class="line">│    ESC[#K - (EL) Erase in line</div>
<div class="line">│      │</div>
<div class="line">│      ├── ESC[0K - clear to end of line (default)</div>
<div class="line">│      ├── ESC[1K - clear to start of line</div>
<div class="line">│      └── ESC[2K - clear current line</div>
<div class="line">│</div>
<div class="line">│    ESC[#L - (IL)  Insert # Lines (default=1)</div>
<div class="line">│    ESC[#M - (DL)  Delete # Lines (default=1)</div>
<div class="line">│    ESC[#P - (DCH) Delete # Chars (default=1)</div>
<div class="line">│    ESC[#S - (SU)  Scroll Up # lines (default=1)</div>
<div class="line">│    ESC[#T - (SD)  Scroll Down # lines (default=1)</div>
<div class="line">│    ESC[#X - (ECH) Erase Characters (default=1)</div>
<div class="line">│</div>
<div class="line">│    ESC[#Z - (CBT) Cursor Backwards Tab</div>
<div class="line">│      │</div>
<div class="line">│      └── ESC[#Z - backwards tab # times (default=1)</div>
<div class="line">│</div>
<div class="line">│    ESC[#a - (HPR) move cursor relative [columns] (default=[row,col+1]) (NOT IMPLEMENTED)</div>
<div class="line">│    ESC[#b - (REP) repeat prev graphics char # times                    (NOT IMPLEMENTED)</div>
<div class="line">│    ESC[#d - (VPA) Line Position Absolute [row]                         (NOT IMPLEMENTED)</div>
<div class="line">│    ESC[#e - (LPA) Line Position Relative [row]                         (NOT IMPLEMENTED)</div>
<div class="line">│    ESC[#f - (CUP) cursor position (#&#39;s 1 based), same as ESC[H</div>
<div class="line">│</div>
<div class="line">│    ESC[#g - (TBC)Tabulation Clear</div>
<div class="line">│      │</div>
<div class="line">│      ├── ESC[0g - Clear tabstop at cursor</div>
<div class="line">│      └── ESC[3g - Clear all tabstops</div>
<div class="line">│</div>
<div class="line">│    ESC[#m - (SGR) Set Graphic Rendition</div>
<div class="line">│      │</div>
<div class="line">│      │    *** Attribute Enable ***</div>
<div class="line">│      │</div>
<div class="line">│      ├──  ESC[0m - reset: normal attribs/default fg/bg color  (VT100)</div>
<div class="line">│      ├──  ESC[1m - bold                                       (VT100)</div>
<div class="line">│      ├──  ESC[2m - dim</div>
<div class="line">│      ├──  ESC[3m - italic</div>
<div class="line">│      ├──  ESC[4m - underline                                  (VT100)</div>
<div class="line">│      ├──  ESC[5m - blink (NOT IMPLEMENTED)                    (VT100)</div>
<div class="line">│      ├──  ESC[6m - (unused)</div>
<div class="line">│      ├──  ESC[7m - inverse                                    (VT100)</div>
<div class="line">│      ├──  ESC[8m - (unused)</div>
<div class="line">│      ├──  ESC[9m - strikeout</div>
<div class="line">│      ├──  ESC[21m - doubly underline (Currently this just does single underline)</div>
<div class="line">│      │</div>
<div class="line">│      │    *** Attribute Disable ***</div>
<div class="line">│      │</div>
<div class="line">│      ├──  ESC[22m - disable bold/dim</div>
<div class="line">│      ├──  ESC[23m - disable italic</div>
<div class="line">│      ├──  ESC[24m - disable underline</div>
<div class="line">│      ├──  ESC[25m - disable blink (NOT IMPLEMENTED)</div>
<div class="line">│      ├──  ESC[26m - (unused)</div>
<div class="line">│      ├──  ESC[27m - disable inverse</div>
<div class="line">│      ├──  ESC[28m - disable hidden</div>
<div class="line">│      ├──  ESC[29m - disable strikeout</div>
<div class="line">│      │</div>
<div class="line">│      │    *** Foreground Text &quot;8 Color&quot; ***</div>
<div class="line">│      │</div>
<div class="line">│      ├──  ESC[30m - fg Black</div>
<div class="line">│      ├──  ESC[31m - fg Red</div>
<div class="line">│      ├──  ESC[32m - fg Green</div>
<div class="line">│      ├──  ESC[33m - fg Yellow</div>
<div class="line">│      ├──  ESC[34m - fg Blue</div>
<div class="line">│      ├──  ESC[35m - fg Magenta</div>
<div class="line">│      ├──  ESC[36m - fg Cyan</div>
<div class="line">│      ├──  ESC[37m - fg White</div>
<div class="line">│      ├──  ESC[39m - fg default</div>
<div class="line">│      │</div>
<div class="line">│      │    *** Background Text &quot;8 Color&quot; ***</div>
<div class="line">│      │</div>
<div class="line">│      ├──  ESC[40m - bg Black</div>
<div class="line">│      ├──  ESC[41m - bg Red</div>
<div class="line">│      ├──  ESC[42m - bg Green</div>
<div class="line">│      ├──  ESC[43m - bg Yellow</div>
<div class="line">│      ├──  ESC[44m - bg Blue</div>
<div class="line">│      ├──  ESC[45m - bg Magenta</div>
<div class="line">│      ├──  ESC[46m - bg Cyan</div>
<div class="line">│      ├──  ESC[47m - bg White</div>
<div class="line">│      ├──  ESC[49m - bg default</div>
<div class="line">│      │</div>
<div class="line">│      │    *** Special RGB Color ***</div>
<div class="line">│      │</div>
<div class="line">│      └──  ESC [ 38 ; Red ; Grn ; Blue m   - where Red,Grn,Blu are decimal (0-255)</div>
<div class="line">│</div>
<div class="line">│    ESC[s     - save cursor pos (ansi.sys+xterm+gnome, but NOT vt100)</div>
<div class="line">│    ESC[u     - rest cursor pos (ansi.sys+xterm+gnome, but NOT vt100)</div>
<div class="line">│</div>
<div class="line">│    ESC[&gt;#q   - (DECSCA)  Set Cursor style (block/line/blink..) (NOT IMPLEMENTED)</div>
<div class="line">│    ESC[#;#r  - (DECSTBM) Set scroll Region top;bot             (NOT IMPLEMENTED)</div>
<div class="line">│    ESC[#..$t - (DECRARA)                                       (NOT IMPLEMENTED)</div>
<div class="line">│</div>
<div class="line">│    ------------------------</div>
<div class="line">│    --- C1 Control Codes ---</div>
<div class="line">│    ------------------------</div>
<div class="line">│</div>
<div class="line">│    &lt;ESC&gt;c    - (RIS) Reset term to Initial State</div>
<div class="line">│    &lt;ESC&gt;D    - (IND) Index: move cursor down a line, scroll if at bottom</div>
<div class="line">│    &lt;ESC&gt;E    - (NEL) Next Line: basically do a crlf, scroll if at bottom</div>
<div class="line">│    &lt;ESC&gt;H    - (HTS) Horizontal Tab Set: set a tabstop</div>
<div class="line">│    &lt;ESC&gt;M    - (RI)  Reverse Index (up w/scroll)</div>
<div class="line">│</div>
<div class="line">│ NOTE: Acronyms in parens are Digital Equipment Corporation&#39;s names these VT features.</div>
<div class="line">│</div>
</div><!-- fragment --><h1><a class="anchor" id="external_escape_codes"></a>
Useful Terminal Escape Code Documentation</h1>
<p>Useful links for reference:</p>
<ul>
<li><a href="https://vt100.net/docs/vt100-ug/chapter3.html">https://vt100.net/docs/vt100-ug/chapter3.html</a></li>
<li><a href="https://www.xfree86.org/current/ctlseqs.html">https://www.xfree86.org/current/ctlseqs.html</a></li>
<li><a href="https://www.x.org/docs/xterm/ctlseqs.pdf">https://www.x.org/docs/xterm/ctlseqs.pdf</a></li>
<li><a href="https://gist.github.com/justinmk/a5102f9a0c1810437885a04a07ef0a91">https://gist.github.com/justinmk/a5102f9a0c1810437885a04a07ef0a91</a> &lt;&ndash; alphabetic!</li>
<li><a href="https://invisible-island.net/xterm/ctlseqs/ctlseqs.html">https://invisible-island.net/xterm/ctlseqs/ctlseqs.html</a></li>
</ul>
<h1><a class="anchor" id="Fl_Terminal_design"></a>
Fl_Terminal Design Document</h1>
<p>When I started this project, I identified the key concepts needed to implement <a class="el" href="classFl__Terminal.html" title="Terminal widget supporting Unicode/utf-8, ANSI/xterm escape codes with full RGB color control.">Fl_Terminal</a>:</p>
<ul>
<li>Draw and manage multiline Unicode text in FLTK</li>
<li>Allow per-character colors and attributes</li>
<li>Efficient screen buffer to handle "scrollback history"</li>
<li>Efficient scrolling with vertical scrollbar for even large screen history</li>
<li>Mouse selection for copy/paste</li>
<li>Escape code management to implement VT100 style / ANSI escape codes.</li>
</ul>
<p>A class was created for each character, since characters can be either ASCII or Utf8 encoded byte sequences. This class is called Utf8Char, and handles the character, its fg and bg color, and any attributes like dim, bold, italic, etc.</p>
<p>For managing the screen, after various experiments, I decided a ring buffer was the best way to manage things, the ring split in two:</p>
<ul>
<li>'screen history' which is where lines scrolled off the top are saved</li>
<li>'display screen' displayed to the user at all times, and where the cursor lives</li>
</ul>
<p>Scrolling the display, either by scrollbar or by new text causing the display to scroll up one line, would simply change an 'offset' index# of where in the ring buffer the top of the screen is, automatically moving the top line into the history, all without moving memory around.</p>
<p>In fact the only time screen memory is moved around is during these infrequent operations:</p>
<ul>
<li>during scrolling "down"</li>
<li>character insert/delete operations within a line</li>
<li>changing the display size</li>
<li>changing the history size</li>
</ul>
<p>So a class "RingBuffer" is defined to manage the ring, and accessing its various parts, either as the entire entity ring, just the history, or just the display.</p>
<p>These three concepts, "ring", "history" and "display" are given abbreviated names in the RingBuffer class's API: </p><pre class="fragment"> ┌─────────────────────────────────────────┬──────────────────────────────┐
 │  NOTE: Abbreviations "hist" and "disp"  │                              │
 ├─────────────────────────────────────────┘                              │
 │                                                                        │
 │  "history" may be abbreviated as "hist", and "display" as "disp" in    │
 │  both this text and the source code. 4 character names are used so     │
 │  they line up cleanly in the source, e.g.                              │
 │                                                                        │
 │      ring_rows()     ring_cols()                                       │
 │      hist_rows()     hist_cols()                                       │
 │      disp_rows()     disp_cols()                                       │
 │      └─┬┘ └─┬┘       └─┬┘ └─┬┘                                         │
 │        └────┴──────────┴────┴───────── 4 characters                    │
 │                                                                        │
 └────────────────────────────────────────────────────────────────────────┘
</pre><p> These concepts were able to fit into C++ classes:</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Utf8Char</h2>
<p>Each character on the screen is a "Utf8Char" which can manage the UTF-8 encoding of any character as one or more bytes. Also in that class is a byte for an attribute (underline, bold, etc), and two integers for fg/bg color.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
RingBuffer</h2>
<p>The RingBuffer class keeps track of the buffer itself, a single array of Utf8Chars called "ring_chars" whose width is ring_cols() and whose height is ring_rows().</p>
<p>The "top" part of the ring is the history, whose width is hist_cols() and whose height is hist_rows(). hist_use_rows() is used to define what part of the history is currently in use.</p>
<p>The "bottom" part of the ring is the display, whose width is disp_cols() and whose height is disp_rows().</p>
<p>An index number called "offset" points to where in the ring buffer the top of the ring currently is. This index changes each time the screen is scrolled, and affects both where the top of the display is, and where the top of the history is.</p>
<p>The memory layout of the Utf8Char character array is: </p><pre class="fragment">    ring_chars[]:
                  ___________________   _ _
                 |                   |   ʌ
                 |                   |   |
                 |                   |   |
                 |   H i s t o r y   |   |  hist_rows
                 |                   |   |
                 |                   |   |
                 |___________________|  _v_
                 |                   |   ʌ
                 |                   |   |
                 |   D i s p l a y   |   |  disp_rows
                 |                   |   |
                 |___________________|  _v_

                 |&lt;-----------------&gt;|
                       ring_cols
                       hist_cols
                       disp_cols
</pre><p> So it's basically a single continuous array of Utf8Char instances where any character can generally be accessed by index# using the formula: </p><pre class="fragment">    ring_chars[ (row*ring_cols)+col ]
</pre><p> ..where 'row' is the desired row, 'col' is the desired column, and 'ring_cols' is how many columns "wide" the buffer is.</p>
<p>The "offset" index affects that formula as an extra row offset, and the resulting index is then clamped within the range of the ring buffer using modulus.</p>
<p>Methods are used to allow direct access to the characters in the buffer that automatically handle the offset and modulus formulas, namely: </p><pre class="fragment">    u8c_ring_row(row,col)   // access the entire ring by row/col
    u8c_hist_row(row,col)   // access just the history buffer
    u8c_disp_row(row,col)   // access just the display buffer
</pre><p> A key concept is the use of the simple 'offset' index integer to allow the starting point of the history and display to be moved around to implement 'text scrolling', such as when crlf at the screen bottom causes a 'scroll up'.</p>
<p>This is simply an "index offset" integer applied to the hist and disp indexes when drawing the display. So after scrolling two lines up, the offset is just increased by 2, redefining where the top of the history and display are, e.g. </p><pre class="fragment">      Offset is 0:           2    Offset now 2:
     ┌───────────────────┐ ──┐   ┌───────────────────┐
     │                   │   │   │   D i s p l a y   │
     │                   │   └─&gt; ├───────────────────┤
     │                   │       │                   │
     │   H i s t o r y   │       │                   │
     │                   │       │   H i s t o r y   │
     │                   │   2   │                   │
     ├───────────────────┤ ──┐   │                   │
     │                   │   │   │                   │
     │                   │   └─&gt; ├───────────────────┤
     │   D i s p l a y   │       │                   │
     │                   │       │    D i s p l a y  │
     │                   │       │                   │
     └───────────────────┘       └───────────────────┘
</pre><p> This 'offset' trivially implements "text scrolling", avoiding having to physically move memory around. Just the 'offset' changes, the text remains where it is in memory.</p>
<p>This also makes it appear the top line in the display is 'scrolled up' into the bottom of the scrollback 'history'.</p>
<p>If the offset exceeds the size of the ring buffer, it simply wraps around back to the beginning of the buffer with a modulo.</p>
<p>Indexes into the display and history are also modulo their respective rows, e.g. </p><pre class="fragment">act_ring_index = (hist_rows + disp_row + offset - scrollbar_pos) % ring_rows;
</pre><p> This way indexes for ranges can run beyond the bottom of the ring, and automatically wrap around the ring, e.g. </p><pre class="fragment">                    ┌───────────────────┐
              ┌─&gt; 2 │                   │
              │   3 │   D i s p l a y   │
              │   4 │                   │
              │     ├───────────────────┤  &lt;-- offset points here
              │     │                   │
        disp  │     │                   │
        index ┤     │   H i s t o r y   │
        wraps │     │                   │
              │     │                   │
              │     │                   │
              │     ├───────────────────┤
              │   0 │   D i s p l a y   │
              │   1 └───────────────────┘  &lt;- ring_rows points to end of ring
              └── 2 :                   :
                  3 :                   :
   disp_row(5) -&gt; 4 :...................:
</pre><p> The dotted lines show where the display would be if not for the fact it extends beyond the bottom of the ring buffer (due to the current offset), and therefore wraps up to the top of the ring.</p>
<p>So to find a particular row in the display, in this case a 5 line display whose lines lie between 0 and 4, some simple math calculates the row position into the ring: </p><pre class="fragment">   act_ring_index = (histrows      // the display exists AFTER the history, so offset the hist_rows
                     + offset      // include the scroll 'offset'
                     + disp_row    // add the desired row relative to the top of the display (0..disp_rows)
                    ) % ring_rows; // make sure the resulting index is within the ring buffer (0..ring_rows)
</pre><p> An additional bit of math makes sure if a negative result occurs, that negative value works relative to the end of the ring, e.g. </p><pre class="fragment">   if (act_ring_index &lt; 0) act_ring_index = ring_rows + act_ring_index;
</pre><p> This guarantees the act_ring_index is within the ring buffer's address space, with all offsets applied.</p>
<p>The math that implements this can be found in the u8c_xxxx_row() methods, where "xxxx" is one of the concept regions "ring", "hist" or "disp": </p><pre class="fragment">   Utf8Char *u8c;
   u8c = u8c_ring_row(rrow);    // address within ring, rrow can be 0..(ring_rows-1)
   u8c = u8c_hist_row(hrow);    // address within hist, hrow can be 0..(hist_rows-1)
   u8c = u8c_disp_row(drow);    // address within disp, drow can be 0..(disp_rows-1)
</pre><p> The small bit of math is only involved whenever a new row address is needed, so in a display that's 80x25, to walk all the characters in the screen, the math above would only be called 25 times, once for each row, and each column in the row is just a simple integer offset: </p><pre class="fragment">     for ( int row=0; row&lt;disp_rows(); row++ ) {    // walk rows: disp_rows = 25
       Utf8Char *u8c = u8c_disp_row(row);           // get first char in display 'row'
       for ( int col=0; col&lt;disp_cols(); col++ ) {  // walk cols: disp_cols = 80
         u8c[col].do_something();                   // work with the char at row/col
       }
     }
</pre><p> So to recap, the concepts here are:</p>
<ul>
<li>The ring buffer itself, a linear array that is conceptually split into a 2 dimensional array of rows and columns whose height and width are: <pre class="fragment">    ring_rows -- how many rows in the entire ring buffer
    ring_cols -- how many columns in the ring buffer
    nchars    -- total chars in ring, e.g. (ring_rows * ring_cols)
</pre></li>
<li>The "history" within the ring. For simplicity this is thought of as starting relative to the top of the ring buffer, occupying ring buffer rows: <pre class="fragment">    0 .. hist_rows()-1
</pre></li>
<li>The "display", or "disp", within the ring, just after the "history". It occupies the ring buffer rows: <pre class="fragment">    hist_rows() .. hist_rows()+disp_rows()-1
</pre> ..or similarly: <pre class="fragment">    (hist_rows)..(ring_rows-1)
</pre> The following convenience methods provide access to the start and end indexes within the ring buffer for each entity:</li>
</ul>
<p>Entire ring ring_srow() &ndash; start row index of the ring buffer (always 0) ring_erow() &ndash; end row index of the ring buffer</p>
<p>"history" part of ring hist_srow() &ndash; start row index of the screen history hist_erow() &ndash; end row index of the screen history</p>
<p>"display" part of ring disp_srow() &ndash; start row index of the display disp_erow() &ndash; end row index of the display</p>
<p>The values returned by these are as described above. For the hist_xxx() and disp_xxx() methods the 'offset' included into the forumula. (For this reason hist_srow() won't always be zero the way ring_srow() is, due to the 'offset')</p>
<p>The values returned by these methods can all be passed to the u8c_ring_row() function to access the actual character buffer's contents.</p>
<ul>
<li>An "offset" used to move the "history" and "display" around within the ring buffer to implement the "text scrolling" concept. The offset is applied when new characters are added to the buffer, and during drawing to find where the display actually is within the ring.</li>
<li>The "scrollbar", which only is used when redrawing the screen the user sees, and is simply an additional offset to all the above, where a scrollbar value of zero (the scrollbar tab at the bottom) shows the display rows, and as the scrollbar values increase as the user moves the scrollbar tab upwards, +1 per line, this is subtracted from the normal starting index to let the user work their way backwards into the scrollback history. Again, negative numbers wrap around within the ring buffer automatically.</li>
</ul>
<p>The ring buffer allows new content to simply be appended to the ring buffer, and the index# for the start of the display and start of scrollback history are simply incremented. So the next time the display is "drawn", it starts at a different position in the ring.</p>
<p>This makes scrolling content at high speed trivial, without memory moves. It also makes the concept of "scrolling" with the scrollbar simple as well, simply being an extra index offset applied during drawing.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Mouse Selection</h2>
<p>Dragging the mouse across the screen should highlight the text, allowing the user to extend the selection either beyond or before the point started. Extending the drag to the top of the screen should automatically 'scroll up' to select more lines in the scrollback history, or below the bottom to do the opposite.</p>
<p>The mouse selection is implemented as a class to keep track of the start/end row/col positions of the selection, and other details such as a flag indicating if a selection has been made, what color the fg/bg text should appear when text is selected, and methods that allow setting and extending the selection, clearing the selection, and "scrolling" the selection, to ensure the row/col indexes adjust correctly to track when the screen or scrollbar is scrolled.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Redraw Timer</h2>
<p>Knowing when to redraw is tricky with a terminal, because sometimes high volumes of input will come in asynchronously, so in that case we need to determine when to redraw the screen to show the new content; too quickly will cause the screen to spend more time redrawing itself, preventing new input from being added. Too slowly, the user won't see new information appear in a timely manner.</p>
<p>To solve this, a rate timer is used to prevent too many redraws:</p>
<ul>
<li>When new data comes in, a 1/10 sec timer is started and a modify flag is set.</li>
<li>redraw() is NOT called yet, allowing more data to continue to arrive quickly</li>
<li>When the 1/10th second timer fires, the callback checks the modify flag:<ul>
<li>if set, calls redraw(), resets the modify to 0, and calls <a class="el" href="classFl.html#a46e5695dca672130f615c438f2a067a3">Fl::repeat_timeout()</a> to repeat the callback in another 1/10th sec.</li>
<li>if clear, no new data came in, so DISABLE the timer, done.</li>
</ul>
</li>
</ul>
<p>In this way, redraws don't happen more than 10x per second, and redraw() is called only when there's new content to see.</p>
<p>The redraw rate can be set by the user application using the <a class="el" href="classFl__Terminal.html#a593739a13816ecb7e7592b4ea46b7687">Fl_Terminal::redraw_rate()</a>, 0.10 being the default.</p>
<p>Some terminal operations necessarily call redraw() directly, such as interactive mouse selection, or during user scrolling the terminal's scrollbar, where it's important there's no delay in what the user sees while interacting directly with the widget. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

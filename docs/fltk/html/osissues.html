<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: Operating System Issues</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">FLTK Programming Manual</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Operating System Issues</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This appendix describes the operating system specific interfaces in FLTK: </p><ul>
<li><a class="el" href="osissues.html#osissues_accessing">Accessing the OS Interfaces</a> </li>
<li><a class="el" href="osissues.html#osissues_wl_x11_hybrid">The Wayland/X11 hybrid library</a> </li>
<li><a class="el" href="osissues.html#osissues_unix">The UNIX (X11) Interface</a> </li>
<li><a class="el" href="osissues.html#osissues_win32">The Windows Interface</a> </li>
<li><a class="el" href="osissues.html#osissues_macos">The Apple OS X Interface</a> </li>
<li><a class="el" href="osissues.html#osissues_wayland">The Wayland Interface</a></li>
</ul>
<h1><a class="anchor" id="osissues_accessing"></a>
Accessing the OS Interfaces</h1>
<p>All programs that need to access the operating system specific interfaces must include the following header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FL/platform.H&gt;</span></div>
</div><!-- fragment --><p>This header file will define the appropriate interface for your environment. The pages that follow describe the functionality that is provided for each operating system.</p>
<dl class="section note"><dt>Note</dt><dd>These definitions used to be in <a class="el" href="x_8H_source.html">FL/x.H</a> up to FLTK 1.3.x. Usage of <a class="el" href="x_8H_source.html">FL/x.H</a> is deprecated since FLTK 1.4.0. You should replace all references of <a class="el" href="x_8H_source.html">FL/x.H</a> with <a class="el" href="platform_8H_source.html">FL/platform.H</a> if your target is FLTK 1.4 or later. <a class="el" href="x_8H_source.html">FL/x.H</a> will be retained for backwards compatibility for some releases but will be removed in a later (not yet specified) FLTK release.</dd></dl>
<center> <table width="90%" border="1" cellpadding="5" cellspacing="0" bgcolor="#cccccc">
<tr>
<td><p class="starttd"><b>WARNING:</b></p>
<p class="intertd">The interfaces provided by this header file may change radically in new FLTK releases. Use them only when an existing generic FLTK interface is not sufficient.</p>
<p class="endtd"></p>
</td></tr>
</table>
</center><h1><a class="anchor" id="osissues_wl_x11_hybrid"></a>
The Wayland/X11 hybrid library</h1>
<p>By default, the FLTK library is, under Linux and Unix, a Wayland/X11 hybrid which can run FLTK-based apps as Wayland clients or as X11 clients. The choice between running an app as a Wayland or an X11 client is done as follows, when the app runs function <code>fl_open_display()</code> (that function can be called explicitly by the app or implicitly by FLTK, for example the first time an <a class="el" href="classFl__Window.html">Fl_Window</a> is show()'n) :</p><ul>
<li>if the app contains a global boolean variable named fl_disable_wayland and this variable is true, X11 is used;</li>
<li>if environment variable FLTK_BACKEND is not defined, Wayland is used if a Wayland compositor is available, otherwise X11 is used;</li>
<li>if $FLTK_BACKEND equals "wayland", the library makes the app a Wayland client, and stops with error if no Wayland compositor is available;</li>
<li>if $FLTK_BACKEND equals "x11", the library makes the app an X11 client even if a Wayland compositor is available.</li>
</ul>
<p>The first condition listed above is meant to facilitate conversion of code written for FLTK 1.3.x and containing X11-specific code; add this single statement anywhere in the app's source code: </p><div class="fragment"><div class="line">FL_EXPORT <span class="keywordtype">bool</span> fl_disable_wayland = <span class="keyword">true</span>;</div>
</div><!-- fragment --><p> and the app will always run as an X11 client.</p>
<p>After function <code>fl_open_display()</code> has been called, exactly one of the functions <code><a class="el" href="wayland_8H.html#a53b288e95abde96a842bcc39f895df0a">fl_wl_display()</a></code> and <code>fl_x11_display()</code> returns a non-NULL value. When the former function does, the app runs as a Wayland client, and Wayland-specific functions and symbols described below (<a class="el" href="osissues.html#osissues_wayland">The Wayland Interface</a>) can be used, whereas X11-specific functions and symbols cannot. Otherwise, the app runs as an X11 client, and only X11-specific functions and symbols below (<a class="el" href="osissues.html#osissues_unix">The UNIX (X11) Interface</a>) can be used.</p>
<p>Because a single app can be expected to run either Wayland or X11, it's necessary to use distinct names for global variables and functions in the X11- and the Wayland-specific source code.</p>
<p>Non-default configurations of the FLTK library under Linux/Unix are described in file README.Wayland.txt.</p>
<h1><a class="anchor" id="osissues_unix"></a>
The UNIX (X11) Interface</h1>
<p>Cross-platform applications should bracket X11-specific source code between <code>#if defined(FLTK_USE_X11) / #endif</code> and should ensure function <code>fl_x11_display()</code> returns non-NULL before calling X11-specific functions and using X11-specific symbols.</p>
<p>The UNIX interface provides access to the X Window System state information and data structures.</p>
<h2><a class="anchor" id="osissues_x_events"></a>
Handling Other X Events</h2>
<p>void <a class="el" href="group__fl__events.html#ga50d1df4bc40158be2514f120f2f7e60c">Fl::add_handler</a>(int (*f)(int))</p>
<dl class="section user"><dt></dt><dd>Installs a function to parse unrecognized events. If FLTK cannot figure out what to do with an event, it calls each of these functions (most recent first) until one of them returns non-zero. If none of them returns non-zero then the event is ignored.</dd></dl>
<dl class="section user"><dt></dt><dd>FLTK calls this for any X events it does not recognize, or X events with a window ID that FLTK does not recognize. You can look at the X event in the <code>fl_xevent</code> variable.</dd></dl>
<dl class="section user"><dt></dt><dd>The argument is the FLTK event type that was not handled, or zero for unrecognized X events. These handlers are also called for global shortcuts and some other events that the widget they were passed to did not handle, for example <code>FL_SHORTCUT</code>.</dd></dl>
<p>extern XEvent *fl_xevent</p>
<dl class="section user"><dt></dt><dd>This variable contains the most recent X event.</dd></dl>
<p>extern ulong fl_event_time</p>
<dl class="section user"><dt></dt><dd>This variable contains the time stamp from the most recent X event that reported it; not all events do. Many X calls like cut and paste need this value.</dd></dl>
<p>Window fl_xid(const Fl_Window *)</p>
<dl class="section user"><dt></dt><dd>Returns the XID for a window, or zero if not <code>shown()</code>. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Kept for compatibility with FLTK versions before 1.4. Use preferentially fl_x11_xid(const Fl_Window *) with versions 1.4 and above.</dd></dl>
<p><a class="el" href="classFl__Window.html">Fl_Window</a> *fl_find(ulong xid)</p>
<dl class="section user"><dt></dt><dd>Returns the <a class="el" href="classFl__Window.html">Fl_Window</a> that corresponds to the given XID, or <code>NULL</code> if not found. This function uses a cache so it is slightly faster than iterating through the windows yourself. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Kept for compatibility with FLTK versions before 1.4. Use preferentially fl_x11_find(Window) with versions 1.4 and above.</dd></dl>
<p>int fl_handle(const XEvent &amp;)</p>
<dl class="section user"><dt></dt><dd>This call allows you to supply the X events to FLTK, which may allow FLTK to cooperate with another toolkit or library. The return value is non-zero if FLTK understood the event. If the window does not belong to FLTK and the <code>add_handler()</code> functions all return 0, this function will return false.</dd></dl>
<dl class="section user"><dt></dt><dd>Besides feeding events your code should call <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc">Fl::flush()</a> periodically so that FLTK redraws its windows.</dd></dl>
<dl class="section user"><dt></dt><dd>This function will call the callback functions. It will not return until they complete. In particular, if a callback pops up a modal window by calling fl_ask(), for instance, it will not return until the modal function returns.</dd></dl>
<h2><a class="anchor" id="osissues_drawing_xlib"></a>
Drawing using Xlib</h2>
<p>The following global variables are set before <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a">Fl_Widget::draw()</a> is called, or by <a class="el" href="classFl__Window.html#a65a2499309b3fdd1bed463cefa0cd1e2">Fl_Window::make_current()</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> Display *fl_display; <span class="comment">// for compatibility with previous FLTK versions</span></div>
<div class="line"><span class="keyword">extern</span> Display *fl_x11_display(); <span class="comment">// preferred access starting with FLTK 1.4</span></div>
<div class="line"><span class="keyword">extern</span> Window fl_window;</div>
<div class="line"><span class="keyword">extern</span> GC fl_gc; <span class="comment">// for compatibility with previous FLTK versions</span></div>
<div class="line"><span class="keyword">extern</span> GC fl_x11_gc(); <span class="comment">// preferred access starting with FLTK 1.4</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> fl_screen;</div>
<div class="line"><span class="keyword">extern</span> XVisualInfo *fl_visual;</div>
<div class="line"><span class="keyword">extern</span> Colormap fl_colormap;</div>
</div><!-- fragment --><p>You must use them to produce Xlib calls. Don't attempt to change them. A typical X drawing call is written like this:</p>
<div class="fragment"><div class="line">XDrawSomething(fl_display, fl_window, fl_gc, ...);</div>
</div><!-- fragment --><p>Other information such as the position or size of the X window can be found by looking at <a class="el" href="classFl__Window.html#af5e20a946ba316850cff08c09ed8e9e2">Fl_Window::current()</a>, which returns a pointer to the <a class="el" href="classFl__Window.html">Fl_Window</a> being drawn.</p>
<p>unsigned long <a class="el" href="group__fl__attributes.html#ga5c8dfa051e445cff49726b256b9f1ca0">fl_xpixel(Fl_Color i)</a> <br  />
 unsigned long <a class="el" href="group__fl__attributes.html#gabd4509f352a8ddc8b413acc244f6bb4a">fl_xpixel(uchar r, uchar g, uchar b)</a></p>
<dl class="section user"><dt></dt><dd>Returns the X pixel number used to draw the given FLTK color index or RGB color. This is the X pixel that <a class="el" href="drawing.html#drawing_colors">fl_color()</a> would use.</dd></dl>
<p>int fl_parse_color(const char* p, uchar&amp; r, uchar&amp; g, uchar&amp; b)</p>
<dl class="section user"><dt></dt><dd>Convert a name into the red, green, and blue values of a color by parsing the X11 color names. On other systems, <code>fl_parse_color()</code> can only convert names in hexadecimal encoding, for example <code>#ff8083</code>.</dd></dl>
<p>extern XFontStruct *fl_xfont</p>
<dl class="section user"><dt></dt><dd>Points to the font selected by the most recent <a class="el" href="drawing.html#drawing_fonts">fl_font()</a>. This is not necessarily the current font of <code>fl_gc</code>, which is not set until <a class="el" href="drawing.html#drawing_text">fl_draw()</a> is called. If FLTK was compiled with Xft support, <code>fl_xfont</code> will usually be 0 and <code>fl_xftfont</code> will contain a pointer to the <code>XftFont</code> structure instead.</dd></dl>
<p>extern void *fl_xftfont</p>
<dl class="section user"><dt></dt><dd>If FLTK was compiled with Xft support enabled, <code>fl_xftfont</code> points to the xft font selected by the most recent <a class="el" href="drawing.html#drawing_fonts">fl_font()</a>. Otherwise it will be 0. <code>fl_xftfont</code> should be cast to <code>XftFont*</code>.</dd></dl>
<h2><a class="anchor" id="osissues_xvisual"></a>
Changing the Display, Screen, or X Visual</h2>
<p>FLTK uses only a single display, screen, X visual, and X colormap. This greatly simplifies its internal structure and makes it much smaller and faster. You can change which it uses by setting global variables <em> before the first <a class="el" href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show()</a> is called. </em> You may also want to call <a class="el" href="classFl.html#a6d6deb3d4f76b538d508b36700dfb6b0">Fl::visual()</a>, which is a portable interface to get a full color and/or double buffered visual.</p>
<p>int <a class="el" href="classFl.html#a7c6847e1b7dd9628821656933ca8e79d">Fl::display(const char *)</a></p>
<dl class="section user"><dt></dt><dd>Set which X display to use. This actually does <code>putenv("DISPLAY=...")</code> so that child programs will display on the same screen if called with <code>exec()</code>. This must be done before the display is opened. This call is provided under MacOS and Windows but it has no effect.</dd></dl>
<p>extern Display *fl_display</p>
<dl class="section user"><dt></dt><dd>The open X display. This is needed as an argument to most Xlib calls. Don't attempt to change it! This is <code>NULL</code> before the display is opened.</dd></dl>
<p>void fl_open_display()</p>
<dl class="section user"><dt></dt><dd>Opens the display. Does nothing if it is already open. This will make sure <code>fl_display</code> is non-zero. You should call this if you wish to do X calls and there is a chance that your code will be called before the first <code>show()</code> of a window.</dd></dl>
<dl class="section user"><dt></dt><dd>This may call Fl::abort() if there is an error opening the display.</dd></dl>
<p>void fl_x11_use_display(Display *d) </p><dl class="section user"><dt></dt><dd>Directs FLTK to use a pre-established X11 connection.</dd></dl>
<p>void fl_close_display()</p>
<dl class="section user"><dt></dt><dd>This closes the X connection. You do <em>not</em> need to call this to exit, and in fact it is faster to not do so! It may be useful to call this if you want your program to continue without the X connection. You cannot open the display again, and probably cannot call any FLTK functions.</dd></dl>
<p>extern int fl_screen</p>
<dl class="section user"><dt></dt><dd>Which screen number to use. This is set by <code>fl_open_display()</code> to the default screen. You can change it by setting this to a different value immediately afterwards. It can also be set by changing the last number in the <a class="el" href="classFl.html#a7c6847e1b7dd9628821656933ca8e79d">Fl::display()</a> string to "host:0.#".</dd></dl>
<p>extern XVisualInfo *fl_visual <br  />
 extern Colormap fl_colormap</p>
<dl class="section user"><dt></dt><dd>The visual and colormap that FLTK will use for all windows. These are set by <code>fl_open_display()</code> to the default visual and colormap. You can change them before calling <code>show()</code> on the first window. Typical code for changing the default visual is: <div class="fragment"><div class="line"><a class="code hl_function" href="classFl.html#a115903daf3593748cdd36a5e78e74534">Fl::args</a>(argc, argv); <span class="comment">// do this first so $DISPLAY is set</span></div>
<div class="line">fl_open_display();</div>
<div class="line">fl_visual = find_a_good_visual(fl_display, fl_screen);</div>
<div class="line"><span class="keywordflow">if</span> (!fl_visual) Fl::abort(<span class="stringliteral">&quot;No good visual&quot;</span>);</div>
<div class="line">fl_colormap = make_a_colormap(fl_display, fl_visual-&gt;visual, fl_visual-&gt;depth);</div>
<div class="line"><span class="comment">// it is now ok to show() windows:</span></div>
<div class="line">window-&gt;show(argc, argv);</div>
<div class="ttc" id="aclassFl_html_a115903daf3593748cdd36a5e78e74534"><div class="ttname"><a href="classFl.html#a115903daf3593748cdd36a5e78e74534">Fl::args</a></div><div class="ttdeci">static int args(int argc, char **argv, int &amp;i, Fl_Args_Handler cb=0)</div><div class="ttdef"><b>Definition</b> Fl_arg.cxx:276</div></div>
</div><!-- fragment --></dd></dl>
<h2><a class="anchor" id="osissues_specialx"></a>
Using a Subclass of Fl_Window for Special X Stuff</h2>
<p>FLTK can manage an X window on a different screen, visual and/or colormap, you just can't use FLTK's drawing routines to draw into it. But you can write your own <code>draw()</code> method that uses Xlib (and/or OpenGL) calls only.</p>
<p>FLTK can also manage XID's provided by other libraries or programs, and call those libraries when the window needs to be redrawn.</p>
<p>To do this, you need to make a subclass of <a class="el" href="classFl__Window.html">Fl_Window</a> and override some of these virtual functions:</p>
<p>virtual void <a class="el" href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show()</a></p>
<dl class="section user"><dt></dt><dd>If the window is already <code>shown()</code> this must cause it to be raised, this can usually be done by calling <a class="el" href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show()</a>. If not <code>shown()</code> your implementation must call either Fl_X::set_xid() or Fl_X::make_xid().</dd></dl>
<dl class="section user"><dt></dt><dd>An example: <div class="fragment"><div class="line"><span class="keywordtype">void</span> MyWindow::show() {</div>
<div class="line">  <span class="keywordflow">if</span> (shown()) {<a class="code hl_function" href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show</a>(); <span class="keywordflow">return</span>;}  <span class="comment">// you must do this!</span></div>
<div class="line">  fl_open_display();    <span class="comment">// necessary if this is first window</span></div>
<div class="line">  <span class="comment">// we only calculate the necessary visual colormap once:</span></div>
<div class="line">  <span class="keyword">static</span> XVisualInfo *visual;</div>
<div class="line">  <span class="keyword">static</span> Colormap colormap;</div>
<div class="line">  <span class="keywordflow">if</span> (!visual) {</div>
<div class="line">    visual = figure_out_visual();</div>
<div class="line">    colormap = XCreateColormap(fl_display, RootWindow(fl_display,fl_screen),</div>
<div class="line">                               vis-&gt;visual, AllocNone);</div>
<div class="line">  }</div>
<div class="line">  Fl_X::make_xid(<span class="keyword">this</span>, visual, colormap);</div>
<div class="line">}</div>
<div class="ttc" id="aclassFl__Window_html_aa773a3f4d474e4f91d62064c1c829c1b"><div class="ttname"><a href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show</a></div><div class="ttdeci">void show() FL_OVERRIDE</div><div class="ttdef"><b>Definition</b> Fl_Window.cxx:546</div></div>
</div><!-- fragment --></dd></dl>
<pre class="fragment">Fl_X *Fl_X::set_xid(Fl_Window*, Window xid)
</pre><dl class="section user"><dt></dt><dd>Allocate a hidden class called an Fl_X, put the XID into it, and set a pointer to it from the <a class="el" href="classFl__Window.html">Fl_Window</a>. This causes <a class="el" href="classFl__Window.html#aa09300542b2d8b49fc69a037bdd3b742">Fl_Window::shown()</a> to return true.</dd></dl>
<p>void Fl_X::make_xid(Fl_Window*, XVisualInfo* = fl_visual, Colormap = fl_colormap)</p>
<dl class="section user"><dt></dt><dd>This static method does the most onerous parts of creating an X window, including setting the label, resize limitations, etc. It then does Fl_X::set_xid() with this new window and maps the window.</dd></dl>
<p>virtual void <a class="el" href="classFl__Window.html#a418cef08cf54f1dd794538501f15f08b">Fl_Window::flush()</a></p>
<dl class="section user"><dt></dt><dd>This virtual function is called by <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc">Fl::flush()</a> to update the window. For FLTK's own windows it does this by setting the global variables <code>fl_window</code> and <code>fl_gc</code> and then calling the <code>draw()</code> method. For your own windows you might just want to put all the drawing code in here.</dd></dl>
<dl class="section user"><dt></dt><dd>The X region that is a combination of all <code>damage()</code> calls done so far is in <code>Fl_X::flx(this)-&gt;region</code>. If <code>NULL</code> then you should redraw the entire window. The undocumented function <code>fl_clip_region(XRegion)</code> will initialize the FLTK clip stack with a region or <code>NULL</code> for no clipping. You must set region to <code>NULL</code> afterwards as <code><a class="el" href="group__fl__drawings.html#ga259fc45a0997b1bae7660c01af943457">fl_clip_region()</a></code> will own and delete it when done.</dd></dl>
<dl class="section user"><dt></dt><dd>If <code>damage() &amp; FL_DAMAGE_EXPOSE</code> then only X expose events have happened. This may be useful if you have an undamaged image (such as a backing buffer) around.</dd></dl>
<dl class="section user"><dt></dt><dd>Here is a sample where an undamaged image is kept somewhere: <div class="fragment"><div class="line"><span class="keywordtype">void</span> MyWindow::flush() {</div>
<div class="line">  <a class="code hl_function" href="group__fl__drawings.html#ga259fc45a0997b1bae7660c01af943457">fl_clip_region</a>(Fl_X::flx(<span class="keyword">this</span>)-&gt;region);</div>
<div class="line">  Fl_X::flx(<span class="keyword">this</span>)-&gt;region = 0;</div>
<div class="line">  <span class="keywordflow">if</span> (damage() != 2) {... draw things into backing store ...}</div>
<div class="line">  ... copy backing store to window ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__fl__drawings_html_ga259fc45a0997b1bae7660c01af943457"><div class="ttname"><a href="group__fl__drawings.html#ga259fc45a0997b1bae7660c01af943457">fl_clip_region</a></div><div class="ttdeci">Fl_Region fl_clip_region()</div><div class="ttdef"><b>Definition</b> fl_draw.H:206</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For compatibility with FLTK versions before 1.4, member function <code>Fl_X::flx(Fl_Window*)</code> can also be written <code>Fl_X::i(Fl_Window*)</code>.</dd></dl>
<p>virtual void <a class="el" href="classFl__Window.html#a90c9895f5421e13fa0370611be5942ae">Fl_Window::hide()</a></p>
<dl class="section user"><dt></dt><dd>Destroy the window server copy of the window. Usually you will destroy contexts, pixmaps, or other resources used by the window, and then call <a class="el" href="classFl__Window.html#a90c9895f5421e13fa0370611be5942ae">Fl_Window::hide()</a> to get rid of the main window identified by <code>xid()</code>. If you override this, you must also override the destructor as shown: <div class="fragment"><div class="line"><span class="keywordtype">void</span> MyWindow::hide() {</div>
<div class="line">  <span class="keywordflow">if</span> (mypixmap) {</div>
<div class="line">    XFreePixmap(fl_display,mypixmap);</div>
<div class="line">    mypixmap = 0;</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_function" href="classFl__Window.html#a90c9895f5421e13fa0370611be5942ae">Fl_Window::hide</a>(); <span class="comment">// you must call this</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassFl__Window_html_a90c9895f5421e13fa0370611be5942ae"><div class="ttname"><a href="classFl__Window.html#a90c9895f5421e13fa0370611be5942ae">Fl_Window::hide</a></div><div class="ttdeci">void hide() FL_OVERRIDE</div><div class="ttdef"><b>Definition</b> Fl_Window.cxx:564</div></div>
</div><!-- fragment --></dd></dl>
<p>virtual void <a class="el" href="classFl__Window.html#a75b94c3386351a44a0ef97b8e435eecb">Fl_Window::~Fl_Window()</a></p>
<dl class="section user"><dt></dt><dd>Because of the way C++ works, if you override <code>hide()</code> you <em>must</em> override the destructor as well (otherwise only the base class <code>hide()</code> is called): <div class="fragment"><div class="line">MyWindow::~MyWindow() {</div>
<div class="line">  hide();</div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Access to the Fl_X hidden class requires to #define FL_INTERNALS before compilation.</dd></dl>
<h2><a class="anchor" id="osissues_x_icon"></a>
Setting the Icon of a Window</h2>
<p>FLTK recommends to set window icons using these platform-independent methods: <a class="el" href="classFl__Window.html#a508f3acd43f9b365d35897b5ec197dbe">Fl_Window::icon(const Fl_RGB_Image *)</a> and <a class="el" href="classFl__Window.html#a2c67d0656099b902c17525dfb9b1ebe5">Fl_Window::icons(const Fl_RGB_Image *[], int)</a>. See also methods setting default window icons <a class="el" href="classFl__Window.html#aaf849aeb0878174971fdb6dab5388873">Fl_Window::default_icon(const Fl_RGB_Image *)</a> and <a class="el" href="classFl__Window.html#ab26c3813e4c519ea2912c08bb1dcdb72">Fl_Window::default_icons(const Fl_RGB_Image *[], int)</a>.</p>
<p>FLTK on X11 also supports, for backward compatibility, use of the deprecated method <a class="el" href="classFl__Window.html#aebe49571396c9d9e88e6006e0d4899a1">Fl_Window::icon(const void *)</a> as follows : <br  />
 Sets the icon for the window to the passed pointer. You will need to cast the icon <code>Pixmap</code> to a <code>char*</code> when calling this method. To set a monochrome icon using a bitmap compiled with your application use: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;icon.xbm&quot;</span></div>
<div class="line"> </div>
<div class="line">fl_open_display(); <span class="comment">// needed if display has not been previously opened</span></div>
<div class="line"> </div>
<div class="line">Pixmap p = XCreateBitmapFromData(fl_display, DefaultRootWindow(fl_display),</div>
<div class="line">                                 icon_bits, icon_width, icon_height);</div>
<div class="line"> </div>
<div class="line">window-&gt;icon((<span class="keyword">const</span> <span class="keywordtype">void</span>*)p);</div>
</div><!-- fragment --><p>To use a multi-colored icon, the XPM format and library should be used as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;X11/xpm.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;icon.xpm&quot;</span></div>
<div class="line"> </div>
<div class="line">fl_open_display();                <span class="comment">// needed if display has not been previously opened</span></div>
<div class="line"> </div>
<div class="line">Pixmap p, mask;</div>
<div class="line"> </div>
<div class="line">XpmCreatePixmapFromData(fl_display, DefaultRootWindow(fl_display),</div>
<div class="line">                                 icon_xpm, &amp;p, &amp;mask, NULL);</div>
<div class="line"> </div>
<div class="line">window-&gt;icon((<span class="keyword">const</span> <span class="keywordtype">void</span> *)p);</div>
</div><!-- fragment --><p>When using the Xpm library, be sure to include it in the list of libraries that are used to link the application (usually "-lXpm").</p>
<center> <table width="90%" border="1" cellpadding="5" cellspacing="0" bgcolor="#cccccc">
<tr>
<td><p class="starttd"><b>NOTE:</b></p>
<p class="intertd">You must call <a class="el" href="classFl__Window.html#a0d75dfcdc8fb797f9247482da1e0152b">Fl_Window::show(int argc, char** argv)</a> for the icon to be used. The <a class="el" href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show()</a> method does not bind the icon to the window.</p>
<p class="endtd"></p>
</td></tr>
</table>
</center><p>Any window icon must be set with the above methods before the window is shown.</p>
<h2><a class="anchor" id="osissues_xresources"></a>
X Resources</h2>
<p>When the <a class="el" href="classFl__Window.html#a0d75dfcdc8fb797f9247482da1e0152b">Fl_Window::show(int argc, char** argv)</a> method is called, FLTK looks for the following X resources:</p>
<ul>
<li><code>background</code> - The default background color for widgets (color).</li>
</ul>
<ul>
<li><code>dndTextOps</code> - The default setting for drag and drop text operations (boolean).</li>
</ul>
<ul>
<li><code>foreground</code> - The default foreground (label) color for widgets (color).</li>
</ul>
<ul>
<li><code>scheme</code> - The default scheme to use (string).</li>
</ul>
<ul>
<li><code>selectBackground</code> - The default selection color for menus, etc. (color).</li>
</ul>
<ul>
<li><code>Text.background</code> - The default background color for text fields (color).</li>
</ul>
<ul>
<li><code>tooltips</code> - The default setting for tooltips (boolean).</li>
</ul>
<ul>
<li><code>visibleFocus</code> - The default setting for visible keyboard focus on non-text widgets (boolean).</li>
</ul>
<p>Resources associated with the first window's <a class="el" href="classFl__Window.html#a5f4838ae3f1100495d1f4eeca6c33397">Fl_Window::xclass()</a> string are queried first, or if no class has been specified then the class "fltk" is used (e.g. <code>fltk.background</code>). If no match is found, a global search is done (e.g. <code>*background</code>).</p>
<h2><a class="anchor" id="osissues_x_scaling"></a>
Display Scaling Factor</h2>
<p>FLTK uses the value of the Xft.dpi resource divided by 96. to initialize the display scaling factor. That is also what is done by the gnome and KDE desktops.</p>
<h1><a class="anchor" id="osissues_win32"></a>
The Windows Interface</h1>
<p>Cross-platform applications should bracket Windows-specific source code between <code>#ifdef _WIN32 / #endif</code>.</p>
<p>The Windows interface provides access to the Windows GDI state information and data structures.</p>
<h2><a class="anchor" id="non_ascii_filenames"></a>
Using filenames with non-ASCII characters</h2>
<p>In FLTK, all strings, including filenames, are UTF-8 encoded. The utility functions <a class="el" href="group__fl__unicode.html#ga8a457e9f251d83d565a62fb3c88cf32e">fl_fopen()</a> and <a class="el" href="group__fl__unicode.html#ga070365398f64a04b75e4e004a82c8611">fl_open()</a> allow to open files potentially having non-ASCII names in a cross-platform fashion, whereas the standard fopen()/open() functions fail to do so.</p>
<h2><a class="anchor" id="osissues_wm_quit"></a>
Responding to WM_QUIT</h2>
<p>FLTK will intercept WM_QUIT messages that are directed towards the thread that runs the main loop. These are converted to SIGTERM signals via <code>raise()</code>. This allows you to deal with outside termination requests with the same code on both Windows and UNIX systems. Other processes can send this message via <code>PostThreadMessage()</code> in order to request, rather than force your application to terminate.</p>
<h2><a class="anchor" id="osissues_win32_messages"></a>
Handling Other Windows API Messages</h2>
<p>By default a single WNDCLASSEX called "FLTK" is created. All <a class="el" href="classFl__Window.html">Fl_Window</a>'s are of this class unless you use <a class="el" href="classFl__Window.html#a5f4838ae3f1100495d1f4eeca6c33397">Fl_Window::xclass()</a>. The window class is created the first time <a class="el" href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show()</a> is called.</p>
<p>You can probably combine FLTK with other libraries that make their own window classes. The easiest way is to call <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312">Fl::wait()</a>, as it will call <code>DispatchMessage()</code> for all messages to the other windows. If necessary you can let the other library take over as long as it calls <code>DispatchMessage()</code>, but you will have to arrange for the function <a class="el" href="classFl.html#a08d29d807ea3874b8bb16f7457f64bdc">Fl::flush()</a> to be called regularly so that widgets are updated, timeouts are handled, and the idle functions are called.</p>
<p>extern MSG fl_msg</p>
<dl class="section user"><dt></dt><dd>This variable contains the most recent message read by <code>GetMessage()</code>, which is called by <a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312">Fl::wait()</a>. This may not be the most recent message sent to an FLTK window, because silly Windows calls the handle procedures directly for some events (sigh).</dd></dl>
<p>void <a class="el" href="group__fl__events.html#ga50d1df4bc40158be2514f120f2f7e60c">Fl::add_handler</a>(int (*f)(int))</p>
<dl class="section user"><dt></dt><dd>Installs a function to parse unrecognized messages sent to FLTK windows. If FLTK cannot figure out what to do with a message, it calls each of these functions (most recent first) until one of them returns non-zero. The argument passed to the functions is the FLTK event that was not handled or zero for unknown messages. If all the handlers return zero then FLTK calls <code>DefWindowProc()</code>.</dd></dl>
<p>HWND fl_xid(const Fl_Window *)</p>
<dl class="section user"><dt></dt><dd>Returns the window handle for a <a class="el" href="classFl__Window.html">Fl_Window</a>, or zero if not <code>shown()</code>.</dd></dl>
<p><a class="el" href="classFl__Window.html">Fl_Window</a> *fl_find(HWND xid)</p>
<dl class="section user"><dt></dt><dd>Returns the <a class="el" href="classFl__Window.html">Fl_Window</a> that corresponds to the given window handle, or <code>NULL</code> if not found. This function uses a cache so it is slightly faster than iterating through the windows yourself.</dd></dl>
<h2><a class="anchor" id="osissues_win32_gdi"></a>
Drawing Things Using the Windows GDI</h2>
<p>When the virtual function <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a">Fl_Widget::draw()</a> is called, FLTK stores all the extra arguments you need to make a proper GDI call in some global variables:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> HINSTANCE fl_display; <span class="comment">// for compatibility with previous FLTK versions</span></div>
<div class="line"><span class="keyword">extern</span> HINSTANCE fl_win32_display(); <span class="comment">// preferred access starting with FLTK 1.4</span></div>
<div class="line"><span class="keyword">extern</span> HWND fl_window;</div>
<div class="line"><span class="keyword">extern</span> HDC fl_gc;  <span class="comment">// for compatibility with previous FLTK versions</span></div>
<div class="line"><span class="keyword">extern</span> HDC fl_win32_gc(); <span class="comment">// preferred access starting with FLTK 1.4</span></div>
<div class="line">COLORREF fl_RGB();</div>
<div class="line">HPEN fl_pen();</div>
<div class="line">HBRUSH fl_brush();</div>
</div><!-- fragment --><p>These global variables are set before <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a">Fl_Widget::draw()</a> is called, or by <a class="el" href="classFl__Window.html#a65a2499309b3fdd1bed463cefa0cd1e2">Fl_Window::make_current()</a>. You can refer to them when needed to produce GDI calls, but don't attempt to change them. The functions return GDI objects for the current color set by <a class="el" href="drawing.html#drawing_colors">fl_color()</a> and are created as needed and cached. A typical GDI drawing call is written like this:</p>
<div class="fragment"><div class="line">DrawSomething(fl_gc, ..., fl_brush());</div>
</div><!-- fragment --><p>It may also be useful to refer to <a class="el" href="classFl__Window.html#af5e20a946ba316850cff08c09ed8e9e2">Fl_Window::current()</a> to get the window's size or position.</p>
<h2><a class="anchor" id="osissues_windows_highdpi"></a>
HighDPI support</h2>
<p>FLTK apps for the Windows platform are by default "Per-monitor DPI-aware V2". This means that any window automatically adjusts its physical size in relation to the scaling factor of the display where it maps. This also means that all drawings (e.g., text, lines, images) take advantage of the full resolution of the display in use. FLTK apps may also use the manifest mechanism to declare their level of DPI awareness. The FLTK library adapts to the DPI awareness level set in the app's manifest, which can be lower than the default level if the manifest sets it so.</p>
<h2><a class="anchor" id="osissues_windows_scaling"></a>
Display Scaling Factor</h2>
<p>FLTK uses the value given by function GetDpiForMonitor() divided by 96. to initialize the scaling factor of each display in the system. This matches the value of "Change the size of text, apps and other items" found in section "System" subsection "Display" of Windows settings.</p>
<h2><a class="anchor" id="osissues_icon_windows"></a>
Setting the Icon of a Window</h2>
<p>FLTK recommends to set window icons using these platform-independent methods: <a class="el" href="classFl__Window.html#a508f3acd43f9b365d35897b5ec197dbe">Fl_Window::icon(const Fl_RGB_Image *)</a> and <a class="el" href="classFl__Window.html#a2c67d0656099b902c17525dfb9b1ebe5">Fl_Window::icons(const Fl_RGB_Image *[], int)</a>. See also methods setting default window icons <a class="el" href="classFl__Window.html#aaf849aeb0878174971fdb6dab5388873">Fl_Window::default_icon(const Fl_RGB_Image *)</a> and <a class="el" href="classFl__Window.html#ab26c3813e4c519ea2912c08bb1dcdb72">Fl_Window::default_icons(const Fl_RGB_Image *[], int)</a>.</p>
<p>FLTK on Windows also supports, for backward compatibility, use of the deprecated method <a class="el" href="classFl__Window.html#aebe49571396c9d9e88e6006e0d4899a1">Fl_Window::icon(const void *)</a> as follows : <br  />
Set the icon for the window to the passed pointer. You will need to cast the <code>HICON</code> handle to a <code>char*</code> when calling this method. To set the icon using an icon resource compiled with your application use: </p><div class="fragment"><div class="line">window-&gt;icon((<span class="keyword">const</span> <span class="keywordtype">void</span> *)LoadIcon(fl_display, MAKEINTRESOURCE(IDI_ICON)));</div>
</div><!-- fragment --><p>You can also use the <code>LoadImage()</code> and related functions to load specific resolutions or create the icon from bitmap data.</p>
<center> <table width="90%" border="1" cellpadding="5" cellspacing="0" bgcolor="#cccccc">
<tr>
<td><p class="starttd"><b>NOTE:</b></p>
<p class="intertd">You must call <a class="el" href="classFl__Window.html#a0d75dfcdc8fb797f9247482da1e0152b">Fl_Window::show(int argc, char** argv)</a> for the icon to be used. The <a class="el" href="classFl__Window.html#aa773a3f4d474e4f91d62064c1c829c1b">Fl_Window::show()</a> method does not bind the icon to the window.</p>
<p class="endtd"></p>
</td></tr>
</table>
</center><p>Any window icon must be set with the above methods before the window is shown.</p>
<h2><a class="anchor" id="osissues_msdos_console"></a>
How to Not Get a MSDOS Console Window</h2>
<p>Windows has a really stupid mode switch stored in the executables that controls whether or not to make a console window.</p>
<p>To always get a console window you simply create a console application (the "/SUBSYSTEM:CONSOLE" option for the linker). For a GUI-only application create a Windows application (the "/SUBSYSTEM:WINDOWS" option for the linker).</p>
<p>FLTK includes a <code>WinMain()</code> function that calls the ANSI standard <code>main()</code> entry point for you. <em> This function creates a console window when you use the debug version of the library. </em></p>
<p>Windows applications without a console cannot write to <code>stdout</code> or <code>stderr</code>, even if they are run from a console window. Any output is silently thrown away. Additionally, Windows applications are run in the background by the console, although you can use "start /wait program" to run them in the foreground.</p>
<h2><a class="anchor" id="osissues_win32_problems"></a>
Known Windows Bugs and Problems</h2>
<p>The following is a list of known bugs and problems in the Windows version of FLTK:</p>
<ul>
<li>If a program is deactivated, <code><a class="el" href="classFl.html#a108a84216f0b3fa1cb0c46ab7449a312">Fl::wait()</a></code> does not return until it is activated again, even though many events are delivered to the program. This can cause idle background processes to stop unexpectedly. This also happens while the user is dragging or resizing windows or otherwise holding the mouse down. We were forced to remove most of the efficiency FLTK uses for redrawing in order to get windows to update while being moved. This is a design error in Windows and probably impossible to get around.</li>
</ul>
<ul>
<li><code>Fl_Gl_Window::can_do_overlay()</code> returns true until the first time it attempts to draw an overlay, and then correctly returns whether or not there is overlay hardware.</li>
</ul>
<ul>
<li><code>SetCapture</code> (used by <code><a class="el" href="group__fl__windows.html#gabe4356666946421cd56f3678889d92bd">Fl::grab()</a></code>) doesn't work, and the main window title bar turns gray while menus are popped up.</li>
</ul>
<ul>
<li>Compilation with <code>gcc 3.4.4</code> and <code>-Os</code> exposes an optimisation bug in gcc. The symptom is that when drawing filled circles only the perimeter is drawn. This can for instance be seen in the symbols demo. Other optimisation options such as -O2 and -O3 seem to work OK. More details can be found in STR#1656</li>
</ul>
<h1><a class="anchor" id="osissues_macos"></a>
The Apple OS X Interface</h1>
<p>Cross-platform applications should bracket macOS-specific source code between <code>#if defined(__APPLE__) &amp;&amp; !defined(FLTK_USE_X11) / #endif</code>.</p>
<p>FLTK supports Apple OS X using the Apple Cocoa library. Older versions of MacOS are no longer supported.</p>
<p>Control, Option, and Command Modifier Keys</p>
<dl class="section user"><dt></dt><dd>FLTK maps the Mac 'control' key to <code>FL_CTRL</code>, the 'option' key to <code>FL_ALT</code> and the 'Apple' key to <code>FL_META</code>. Furthermore, <code>FL_COMMAND</code> designates the 'Apple' key on Mac OS X and the 'control' key on other platforms. Keyboard events return the key name in <a class="el" href="group__fl__events.html#ga1ac131e3cd5ca674cc022b1f77233449">Fl::event_key()</a> and the keystroke translation in <a class="el" href="group__fl__events.html#gae5cf69191d2381f0333dbc83bdd32f75">Fl::event_text()</a>. For example, typing Option-Y on a Mac US keyboard will set <code>FL_ALT</code> in <a class="el" href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed">Fl::event_state()</a>, set <a class="el" href="group__fl__events.html#ga1ac131e3cd5ca674cc022b1f77233449">Fl::event_key()</a> to 'y' and return the Yen symbol in <a class="el" href="group__fl__events.html#gae5cf69191d2381f0333dbc83bdd32f75">Fl::event_text()</a>.</dd></dl>
<p>Right Click simulation with Ctrl Click </p><dl class="section user"><dt></dt><dd>The Apple HIG guidelines indicate applications should support 'Ctrl Click' to simulate 'Right Click' for e.g. context menus, so users with one-button mice and one-click trackpads can still access right-click features. However, paraphrasing <a href="https://www.fltk.org/newsgroups.php?gfltk.coredev+v:14725">Manolo's comment on the fltk.coredev newsgroup</a>: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li>
<em>FLTK does /not/ support Ctrl-Click == Right Click itself because Mac OS X event processing doesn't support this at the system level: the system reports left-clicks with the ctrl modifier when the user ctrl-clicks, and OS X system preferences don't allow changing this behavior. Therefore, applications must handle simulation of Right Click with Ctrl Click in the application code.</em> </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Ian MacArthur provided the following handle() method code snippet showing an example of how to do this: <div class="fragment"><div class="line">    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="Enumerations_8H.html#ad16daf120d9a0501cccaee563af0b9a3a44972d76423f3e380ae12c36827944e3">FL_PUSH</a>:</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> btn = <a class="code hl_function" href="group__fl__events.html#ga7ae6d99ceb1a2afb8a1dc4455ac941cd">Fl::event_button</a>();</div>
<div class="line"><span class="preprocessor">#ifdef __APPLE__</span></div>
<div class="line">        <span class="keywordtype">int</span> ev_state = <a class="code hl_function" href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed">Fl::event_state</a>();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Context menu can be called up in one of two ways: -</span></div>
<div class="line">        <span class="comment">//     1 - right click, as normally used on Windows and Linux</span></div>
<div class="line">        <span class="comment">//     2 - Ctrl + left click, as sometimes used on Mac</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line"><span class="preprocessor">#ifdef __APPLE__</span></div>
<div class="line">        <span class="comment">// On apple, check right click, and ctrl+left click</span></div>
<div class="line">        <span class="keywordflow">if</span> ((btn == <a class="code hl_define" href="Enumerations_8H.html#ace3b88a65f6aabab96b0bcc411470c77">FL_RIGHT_MOUSE</a>) || (ev_state == (<a class="code hl_define" href="Enumerations_8H.html#a29324ec5ac8c1d87950127d387dc83e8">FL_CTRL</a> | <a class="code hl_define" href="Enumerations_8H.html#afe37a4db5e516754bb8963cd341bf415">FL_BUTTON1</a>)))</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">        <span class="comment">// On other platforms, only check right click as ctrl+left is used for selections</span></div>
<div class="line">        <span class="keywordflow">if</span> (btn == <a class="code hl_define" href="Enumerations_8H.html#ace3b88a65f6aabab96b0bcc411470c77">FL_RIGHT_MOUSE</a>)</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Did we right click on the object?..</span></div>
<div class="ttc" id="aEnumerations_8H_html_a29324ec5ac8c1d87950127d387dc83e8"><div class="ttname"><a href="Enumerations_8H.html#a29324ec5ac8c1d87950127d387dc83e8">FL_CTRL</a></div><div class="ttdeci">#define FL_CTRL</div><div class="ttdoc">One of the ctrl keys is down.</div><div class="ttdef"><b>Definition</b> Enumerations.H:572</div></div>
<div class="ttc" id="aEnumerations_8H_html_ace3b88a65f6aabab96b0bcc411470c77"><div class="ttname"><a href="Enumerations_8H.html#ace3b88a65f6aabab96b0bcc411470c77">FL_RIGHT_MOUSE</a></div><div class="ttdeci">#define FL_RIGHT_MOUSE</div><div class="ttdoc">The right mouse button.</div><div class="ttdef"><b>Definition</b> Enumerations.H:553</div></div>
<div class="ttc" id="aEnumerations_8H_html_ad16daf120d9a0501cccaee563af0b9a3a44972d76423f3e380ae12c36827944e3"><div class="ttname"><a href="Enumerations_8H.html#ad16daf120d9a0501cccaee563af0b9a3a44972d76423f3e380ae12c36827944e3">FL_PUSH</a></div><div class="ttdeci">@ FL_PUSH</div><div class="ttdef"><b>Definition</b> Enumerations.H:211</div></div>
<div class="ttc" id="aEnumerations_8H_html_afe37a4db5e516754bb8963cd341bf415"><div class="ttname"><a href="Enumerations_8H.html#afe37a4db5e516754bb8963cd341bf415">FL_BUTTON1</a></div><div class="ttdeci">#define FL_BUTTON1</div><div class="ttdoc">Mouse button 1 is pushed (L)</div><div class="ttdef"><b>Definition</b> Enumerations.H:582</div></div>
<div class="ttc" id="agroup__fl__events_html_ga7ae6d99ceb1a2afb8a1dc4455ac941cd"><div class="ttname"><a href="group__fl__events.html#ga7ae6d99ceb1a2afb8a1dc4455ac941cd">Fl::event_button</a></div><div class="ttdeci">static int event_button()</div><div class="ttdef"><b>Definition</b> Fl.H:713</div></div>
<div class="ttc" id="agroup__fl__events_html_gafa17a5b4d8d9163631c88142e60447ed"><div class="ttname"><a href="group__fl__events.html#gafa17a5b4d8d9163631c88142e60447ed">Fl::event_state</a></div><div class="ttdeci">static int event_state()</div><div class="ttdef"><b>Definition</b> Fl.H:754</div></div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>There is a thread about this subject on fltk.coredev (Aug 1-14, 2014) entitled "[RFC] Right click emulation for one button mouse on Mac".</dd></dl>
<p>Apple "Quit" Event</p>
<dl class="section user"><dt></dt><dd>When the user presses Cmd-Q or requests a termination of the application, FLTK sends an <code>FL_CLOSE</code> event to all open windows. If any window remains open, the termination request aborts. If all windows close, the application's event loop terminates, that is, <a class="el" href="classFl.html#a7a3b1236b41800d24267288c564b187a">Fl::run()</a> returns. The application can then follow FLTK's normal termination path executing cleanup code that may be programmed after termination of the event loop, and returning from main(). Function <a class="el" href="classFl.html#a2e47798ab952686bc084e061a4a88da7">Fl::program_should_quit()</a> allows to detect whether the event loop terminated because of a program termination request.</dd></dl>
<p>Apple "Open" Event</p>
<dl class="section user"><dt></dt><dd>Whenever the user drops a file onto an application icon, OS X generates an Apple Event of the type "Open". You can have FLTK notify you of an Open event by calling the <a class="el" href="group__group__macosx.html#ga0702a54934d10f5b72157137cf291296">fl_open_callback()</a> function.</dd></dl>
<p>void fl_open_display()</p>
<dl class="section user"><dt></dt><dd>Opens the display. Does nothing if it is already open. You should call this if you wish to do Cocoa or Quartz calls and there is a chance that your code will be called before the first <code>show()</code> of a window.</dd></dl>
<p>Window fl_xid(const Fl_Window *)</p>
<dl class="section user"><dt></dt><dd>Returns the window reference for an <a class="el" href="classFl__Window.html">Fl_Window</a>, or <code>NULL</code> if the window has not been shown. This reference is a pointer to an instance of the subclass <a class="el" href="interfaceFLWindow.html">FLWindow</a> of Cocoa's NSWindow class.</dd></dl>
<p><a class="el" href="classFl__Window.html">Fl_Window</a> *fl_find(Window xid)</p>
<dl class="section user"><dt></dt><dd>Returns the <a class="el" href="classFl__Window.html">Fl_Window</a> that corresponds to the given window reference, or <code>NULL</code> if not found.</dd></dl>
<p>void <a class="el" href="group__group__macosx.html#gac2ba4bfc66f7bc9792dffa2aeb53064e">fl_mac_set_about( Fl_Callback *cb, void *user_data, int shortcut)</a></p>
<dl class="section user"><dt></dt><dd>Attaches the callback <code>cb</code> to the "About myprog" item of the system application menu. <code>cb</code> will be called with NULL first argument and <code>user_data</code> second argument. This MacOS-specific function is deprecated in FLTK 1.4 and replaced by <a class="el" href="classFl__Sys__Menu__Bar.html#ada6ae6955dc0363fe16efadf2169e8fb">Fl_Sys_Menu_Bar::about(Fl_Callback *cb, void *data)</a> which is cross-platform.</dd></dl>
<p><a class="el" href="classFl__Sys__Menu__Bar.html">Fl_Sys_Menu_Bar</a> class</p>
<dl class="section user"><dt></dt><dd>The <a class="el" href="classFl__Sys__Menu__Bar.html">Fl_Sys_Menu_Bar</a> class allows to build menu bars that, on Mac OS X, are placed in the system menu bar (at top-left of display), and, on other platforms, at a user-chosen location of a user-chosen window.</dd></dl>
<h2><a class="anchor" id="osissues_icon_osx"></a>
Setting the icon of an application</h2>
<ul>
<li>First, create a .icns file containing several copies of your icon of decreasing sizes. This can be done using the Preview application or the Icon Composer application available in "Graphics Tools for Xcode". To create a high resolution icon file, it is necessary to use the iconutil command-line utility. </li>
<li>Put your .icns file in the Resources subdirectory of your application bundle. </li>
<li>Add these two lines to the Info.plist file of your application bundle <pre class="fragment">&lt;key&gt;CFBundleIconFile&lt;/key&gt;
&lt;string&gt;foo.icns&lt;/string&gt;
</pre> replacing <code>foo</code> by your application name. If you use Xcode, just add your .icns file to your application target.</li>
</ul>
<h2><a class="anchor" id="osissues_quartz"></a>
Drawing Things Using Quartz</h2>
<p>All code inside <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a">Fl_Widget::draw()</a> is expected to call Quartz drawing functions. The Quartz coordinate system is flipped to match FLTK's coordinate system. The origin for all drawing is in the top left corner of the enclosing <a class="el" href="classFl__Window.html">Fl_Window</a>. The function <code><a class="el" href="group__group__macosx.html#gaed6a0a639f023f384b15e1efe8a0345c">fl_mac_gc()</a></code> returns the appropriate Quartz 2D drawing environment (of type <code>CGContextRef</code>). For compatibility with previous FLTK versions, deprecated global variable <code>fl_gc</code> gives the same value.</p>
<p>Include <a class="el" href="platform_8H_source.html">FL/platform.H</a> to declare the <code><a class="el" href="group__group__macosx.html#gaed6a0a639f023f384b15e1efe8a0345c">fl_mac_gc()</a></code> function (or the <code>fl_gc</code> variable).</p>
<h2><a class="anchor" id="osissues_localize"></a>
Internationalization</h2>
<p>All FLTK programs contain an application menu with, e.g., the About xxx, Hide xxx, and Quit xxx items. This menu can be internationalized/localized by any of two means. </p><ul>
<li>using the <a class="el" href="classFl__Mac__App__Menu.html">Fl_Mac_App_Menu</a> class. </li>
<li>using the standard Mac OS X localization procedure. Create a language-specific .lproj directory (e.g., <code>German.lproj</code>) in the Resources subdirectory of the application bundle. Create therein a <code>Localizable.strings</code> file that translates all menu items to this language. The German <code>Localizable.strings</code> file, for example, contains: <pre class="fragment">"About %@" = "Über %@";
"Print Front Window"="Frontfenster drucken";
"Services" = "Dienste";
"Hide %@"="%@ ausblenden";
"Hide Others"="Andere ausblenden";
"Show All"="Alle einblenden";
"Quit %@"="%@ beenden";
</pre> Set <code>"Print Front Window" = "";</code> therein so the application menu doesn't show a "Print Front Window" item. To localize the application name itself, create a file <code>InfoPlist.strings</code> in each .lproj directory and put <code>CFBundleName = "localized name";</code> in each such file.</li>
</ul>
<h2><a class="anchor" id="osissues_retina"></a>
OpenGL and 'retina' displays</h2>
<p>It is possible to have OpenGL produce graphics at the high pixel resolution allowed by the so-called 'retina' displays present on recent Apple hardware. For this, call </p><pre class="fragment">Fl::use_high_res_GL(1);
</pre><p> before any <a class="el" href="classFl__Gl__Window.html">Fl_Gl_Window</a> is shown. Also, adapt your <a class="el" href="classFl__Gl__Window.html#a4b83cda632bc997e79ca1c365701fb69">Fl_Gl_Window::draw()</a> and Fl_Gl_Window::draw_overlay() methods replacing </p><pre class="fragment">glViewport(0, 0, w(), h());
</pre><p> by </p><pre class="fragment">glViewport(0, 0, pixel_w(), pixel_h());
</pre><p> making use of the <a class="el" href="classFl__Gl__Window.html#a91671f6172a8c01f61dbff75afdea864">Fl_Gl_Window::pixel_w()</a> and <a class="el" href="classFl__Gl__Window.html#a080d304174ec7658ea82328044ce20ce">Fl_Gl_Window::pixel_h()</a> methods that return the width and height of the GL scene in pixels: if the <a class="el" href="classFl__Gl__Window.html">Fl_Gl_Window</a> is mapped on a retina display, these methods return twice as much as reported by <a class="el" href="classFl__Widget.html#ad59ece778aaf15acc4dd01a8bf5f8012">Fl_Widget::w()</a> and <a class="el" href="classFl__Widget.html#aeeabd61e2d10c76cd6600dbbfe951f71">Fl_Widget::h()</a>; if it's mapped on a regular display, they return the same values as w() and h(). These methods dynamically change their values if the window is moved into/out from a retina display. If Fl::use_high_res_GL(1) is not called, all <a class="el" href="classFl__Gl__Window.html">Fl_Gl_Window</a> 's are drawn at low resolution. These methods are useful on all platforms because <a class="el" href="classFl__Widget.html#ad59ece778aaf15acc4dd01a8bf5f8012">Fl_Gl_Window::w()</a> and <a class="el" href="classFl__Widget.html#aeeabd61e2d10c76cd6600dbbfe951f71">Fl_Gl_Window::h()</a> don't return, on HighDPI displays, the quantitites in pixels necessary to OpenGL functions .</p>
<p>The Fl_Gl_Window::pixels_per_unit() method is useful when the OpenGL code depends on the pixel dimension of the GL scene. This occurs, e.g., if a window's handle() method uses <a class="el" href="group__fl__events.html#ga91585fcbaa1e79f7452fd2d16a82136e">Fl::event_x()</a> and <a class="el" href="group__fl__events.html#ga192a0c5a37f33b9d117a69f20977c2a1">Fl::event_y()</a> whose returned values should be multiplied by Fl_Gl_Window::pixels_per_unit() to obtain the adequate pixel units. This method may also be useful, for example, to adjust the width of a line in a high resolution GL scene.</p>
<h2><a class="anchor" id="double_window"></a>
Fl_Double_Window</h2>
<p>OS X double-buffers all windows automatically. On OS X, <a class="el" href="classFl__Window.html">Fl_Window</a> and <a class="el" href="classFl__Double__Window.html">Fl_Double_Window</a> are handled internally in the same way.</p>
<h2><a class="anchor" id="osissues_mac_files"></a>
Mac File System Specifics</h2>
<dl class="section user"><dt>Resource Forks (OS X pre 10.6)</dt><dd></dd></dl>
<p>FLTK does not access the resource fork of an application. However, a minimal resource fork must be created for OS X applications. Starting with OS X 10.6, resource forks are no longer needed.</p>
<center> <table width="80%" border="1" bgcolor="#cccccc" cellpadding="5">
<tr>
<td><p class="starttd"><b>Caution (OS X 10.2 and older):</b></p>
<p class="endtd">When using UNIX commands to copy or move executables, OS X will NOT copy any resource forks! For copying and moving use CpMac and MvMac respectively. For creating a tar archive, all executables need to be stripped from their Resource Fork before packing, e.g. "DeRez fluid &gt; fluid.r". After unpacking the Resource Fork needs to be reattached, e.g. "Rez fluid.r -o
fluid". </p>
</td></tr>
</table>
</center><p>It is advisable to use the Finder for moving and copying and Mac archiving tools like Sit for distribution as they will handle the Resource Fork correctly.</p>
<dl class="section user"><dt>Mac File Paths</dt><dd></dd></dl>
<p>FLTK uses UTF-8-encoded UNIX-style filenames and paths.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__macosx.html">Mac OS X-specific symbols</a></dd></dl>
<h1><a class="anchor" id="osissues_wayland"></a>
The Wayland Interface</h1>
<p>Cross-platform applications should bracket Wayland-specific source code between <code>#ifdef FLTK_USE_WAYLAND / #endif</code> and should ensure function <code><a class="el" href="wayland_8H.html#a53b288e95abde96a842bcc39f895df0a">fl_wl_display()</a></code> returns non-NULL before calling Wayland-specific functions and using Wayland-specific symbols.</p>
<p>extern struct wl_display *fl_wl_display(); </p><dl class="section user"><dt></dt><dd>After fl_open_display() has run, function <code><a class="el" href="wayland_8H.html#a53b288e95abde96a842bcc39f895df0a">fl_wl_display()</a></code> returns a pointer to the struct wl_display representing the connection between the application and Wayland. For example, <code>wl_display_get_fd(fl_wl_display())</code> gives the file descriptor one can use to communicate with the Wayland compositor according to the Wayland protocol.</dd></dl>
<p>struct <a class="el" href="structwld__window.html">wld_window</a> *fl_wl_xid(const <a class="el" href="classFl__Window.html">Fl_Window</a> *) </p><dl class="section user"><dt></dt><dd>Returns a pointer to an <u>FLTK-defined</u> structure holding Wayland-related data created when a window gets show()'n, or NULL if not show()'n.</dd></dl>
<p><a class="el" href="classFl__Window.html">Fl_Window</a> *fl_wl_find(struct <a class="el" href="structwld__window.html">wld_window</a> * wld_win) </p><dl class="section user"><dt></dt><dd>Returns the <a class="el" href="classFl__Window.html">Fl_Window</a> that corresponds to the given Window, or NULL if not found.</dd></dl>
<p>struct wl_surface *fl_wl_surface(struct <a class="el" href="structwld__window.html">wld_window</a> *wld_win) </p><dl class="section user"><dt></dt><dd>Returns a pointer to the struct wl_surface corresponding to a show()'n top-level window or subwindow.</dd></dl>
<p>cairo_t *fl_wl_gc() </p><dl class="section user"><dt></dt><dd>Drawing natively to a Wayland window : Within an overridden <a class="el" href="classFl__Widget.html#a1acb38c6b3cb40452ad02ccfeedbac8a">Fl_Widget::draw()</a> method, or after a call to <a class="el" href="classFl__Window.html#a65a2499309b3fdd1bed463cefa0cd1e2">Fl_Window::make_current()</a>, it's possible to draw <u>using the Cairo library</u>. Function <code><a class="el" href="wayland_8H.html#ac65aea1abda98c0d76fec26ad07b7969">fl_wl_gc()</a></code> returns the adequate <code>cairo_t*</code> value. Regular FLTK coordinates, with top-left origin, are to be used. All FLTK-defined drawing functions (e.g., <a class="el" href="group__fl__drawings.html#ga690c83e11f49fa837b563f4c0bc4fd1b">fl_rect()</a>, fl_draw()) can be used too.</dd></dl>
<p>void fl_close_display() </p><dl class="section user"><dt></dt><dd>This closes the Wayland connection. You do not need to call this to exit. It may be useful to call this if you want your program to continue without the Wayland connection. You cannot open the display again, and cannot call any FLTK functions.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="wayland_8H.html#wayland_H">wayland.H</a> for all functions specific of the Wayland platform.</dd></dl>
<h2><a class="anchor" id="osissues_wayland_scaling"></a>
HiDPI display support</h2>
<p>FLTK Wayland apps automatically scale according to the Wayland-defined, integer-valued scale factor. On a HiDPI display, it's enough to set this factor to 2 for any FLTK app to be drawn using twice as many pixels and thus to be as readable as it is on a regular display. With the gnome and KDE-plasma desktops, that is achieved in the "Displays" section of the "Settings" application, selecting 200 % for the "Scale" parameter. In addition to this, FLTK apps can also be scaled up or down typing ctrl/+/-/0/ and with the <code>FLTK_SCALING_FACTOR</code> environment variable.</p>
<h2><a class="anchor" id="osissues_wayland_window_icon"></a>
Window icons</h2>
<p>Standard FLTK functions <a class="el" href="classFl__Window.html#a508f3acd43f9b365d35897b5ec197dbe">Fl_Window::icon(const Fl_RGB_Image*)</a>, <a class="el" href="classFl__Window.html#a2c67d0656099b902c17525dfb9b1ebe5">Fl_Window::icons(const Fl_RGB_Image*[], int)</a>, <a class="el" href="classFl__Window.html#aaf849aeb0878174971fdb6dab5388873">Fl_Window::default_icon(const Fl_RGB_Image*)</a> and <a class="el" href="classFl__Window.html#ab26c3813e4c519ea2912c08bb1dcdb72">Fl_Window::default_icons(const Fl_RGB_Image*[], int)</a> have no effect on the Wayland platform. The equivalent of a call to <a class="el" href="classFl__Window.html#aaf849aeb0878174971fdb6dab5388873">Fl_Window::default_icon(const Fl_RGB_Image*)</a> to set the application-specific window icon can be obtained as follows, using FLTK's editor app as an example:</p><ul>
<li>create a text file named <code>editor.desktop</code> containing : <pre>[Desktop Entry]
Version=1.0
Type=Application
Name=Editor
Name[fr]=Editeur
Comment=FLTK editor
Exec=editor %F
Icon=/path/to/icon/file/editor.svg
MimeType=text/plain
</pre></li>
<li>The <code>Name=</code> line therein determines the string displayed when the app runs.</li>
<li>Optionally, one or more <code>Name[<em>locale</em>]=</code> lines can be used to set locale-specific app names.</li>
<li>The <code>Icon=</code> line accepts also <code></code>.png files.</li>
<li>Put this file in <code>/usr/local/share/applications/</code> so it's available to all system users or in <code>$HOME/.local/share/applications/</code> so it's available to a single user.</li>
</ul>
<h2><a class="anchor" id="osissues_wayland_decoration"></a>
Window titlebars</h2>
<p>Wayland supports both client-side window decoration (CSD), where client applications are responsible for drawing window titlebars, and server-side window decoration (SSD), where the Wayland compositor itself draws window titlebars. Among 4 tested Wayland compositors, Mutter (gnome's compositor) and Weston use CSD mode whereas the KWin and Sway compositors use SSD mode. When running in CSD mode, FLTK uses a library called <a href="https://gitlab.freedesktop.org/libdecor/libdecor">libdecor</a> to draw titlebars. The libdecor library has been conceived to use various plug-in's to draw titlebars in various fashions intended to match any desktop's preferred titlebar style. FLTK supports drawing titlebars with any libdecor plug-in via an environment variable called <code>LIBDECOR_PLUGIN_DIR</code> which can be given the name of a directory containing the desired plug-in. When <code>LIBDECOR_PLUGIN_DIR</code> is not defined, or points to a directory that doesn't contain a libdecor plug-in, FLTK uses its built-in plug-in to draw titlebars. That is the most common situation, until libdecor plug-in's become available for popular UNIX desktops.</p>
<p> 
<hr>
<table summary="navigation bar" width="100%" border="0">
<tr>
  <td width="45%" align="LEFT">
    <a class="el" href="forms.html">
    [Prev]
    Forms Compatibility
    </a>
  </td>
  <td width="10%" align="CENTER">
    <a class="el" href="index.html">[Index]</a>
  </td>
  <td width="45%" align="RIGHT">
    <a class="el" href="migration_1_4.html">
    Migrating Code from FLTK 1.3 to 1.4
    [Next]
    </a>
  </td>
</tr>
</table>
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

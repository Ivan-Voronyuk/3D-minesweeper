<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: Using OpenGL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">FLTK Programming Manual</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Using OpenGL</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This chapter discusses using FLTK for your OpenGL applications.</p>
<h1><a class="anchor" id="opengl_using"></a>
Using OpenGL in FLTK</h1>
<p>The easiest way to make an OpenGL display is to subclass Fl_Gl_Window. Your subclass must implement a <code>draw()</code> method which uses OpenGL calls to draw the display. Your main program should call <code>redraw()</code> when the display needs to change, and (somewhat later) FLTK will call <code>draw()</code>.</p>
<p>With a bit of care you can also use OpenGL to draw into normal FLTK windows (see <a class="el" href="opengl.html#opengl_normal">Using OpenGL in Normal FLTK Windows</a> below). This allows you to use Gouraud shading for drawing your widgets. To do this you use the <a class="el" href="opengl.html#opengl_gl_start">gl_start()</a> and <a class="el" href="opengl.html#opengl_gl_finish">gl_finish()</a> functions around your OpenGL code.</p>
<p>You must include FLTK's <code>&lt;<a class="el" href="gl_8h.html">FL/gl.h</a>&gt;</code> header file. It will include the file <code>&lt;GL/gl.h&gt;</code> (on macOS: <code>&lt;OpenGL/gl.h&gt;</code>), define some extra drawing functions provided by FLTK, and include the <code>&lt;windows.h&gt;</code> header file needed by Windows applications.</p>
<p>Some simple coding rules (see <a class="el" href="opengl.html#opengl_highdpi">OpenGL and support of HighDPI displays</a>) allow to write cross-platform code that will support OpenGL run on HighDPI displays (including the 'retina' displays of Apple hardware).</p>
<h1><a class="anchor" id="opengl_subclass"></a>
Making a Subclass of Fl_Gl_Window</h1>
<p>To make a subclass of Fl_Gl_Window, you must provide:</p>
<ul>
<li>A class definition. </li>
<li>A <code>draw()</code> method. </li>
<li>A <code>handle()</code> method if you need to receive input from the user.</li>
</ul>
<p>If your subclass provides static controls in the window, they must be redrawn whenever the <code>FL_DAMAGE_ALL</code> bit is set in the value returned by <code>damage()</code>.</p>
<h2><a class="anchor" id="opengl_defining"></a>
Defining the Subclass</h2>
<p>To define the subclass you just subclass the Fl_Gl_Window class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classMyWindow.html">MyWindow</a> : <span class="keyword">public</span> Fl_Gl_Window {</div>
<div class="line">  <span class="keywordtype">void</span> draw();</div>
<div class="line">  <span class="keywordtype">int</span> handle(<span class="keywordtype">int</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_class" href="classMyWindow.html">MyWindow</a>(<span class="keywordtype">int</span> X, <span class="keywordtype">int</span> Y, <span class="keywordtype">int</span> W, <span class="keywordtype">int</span> H, <span class="keyword">const</span> <span class="keywordtype">char</span> *L)</div>
<div class="line">    : Fl_Gl_Window(X, Y, W, H, L) {}</div>
<div class="line">};</div>
<div class="ttc" id="aclassMyWindow_html"><div class="ttname"><a href="classMyWindow.html">MyWindow</a></div><div class="ttdef"><b>Definition</b> keyboard.h:23</div></div>
</div><!-- fragment --><p>The <code>draw()</code> and <code>handle()</code> methods are described below. Like any widget, you can include additional private and public data in your class (such as scene graph information, etc.)</p>
<h2><a class="anchor" id="opengl_draw"></a>
The draw() Method</h2>
<p>The <code>draw()</code> method is where you actually do your OpenGL drawing:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyWindow::draw() {</div>
<div class="line">  <span class="keywordflow">if</span> (!valid()) {</div>
<div class="line">    ... set up projection, viewport, etc ...</div>
<div class="line">    ... <a class="code hl_class" href="classwindow.html">window</a> size is in w() and h().</div>
<div class="line">    ... valid() is turned on by FLTK after draw() returns</div>
<div class="line">  }</div>
<div class="line">  ... draw ...</div>
<div class="line">}</div>
<div class="ttc" id="aclasswindow_html"><div class="ttname"><a href="classwindow.html">window</a></div><div class="ttdef"><b>Definition</b> animated.cxx:108</div></div>
</div><!-- fragment --><h2><a class="anchor" id="opengl_handle"></a>
The handle() Method</h2>
<p>The <code>handle()</code> method handles mouse and keyboard events for the window:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> MyWindow::handle(<span class="keywordtype">int</span> event) {</div>
<div class="line">  <span class="keywordflow">switch</span>(event) {</div>
<div class="line">  <span class="keywordflow">case</span> FL_PUSH:</div>
<div class="line">    ... mouse down <span class="keyword">event</span> ...</div>
<div class="line">    ... position in Fl::event_x() and Fl::event_y()</div>
<div class="line">    return 1;</div>
<div class="line">  case FL_DRAG:</div>
<div class="line">    ... mouse moved while down event ...</div>
<div class="line">    return 1;</div>
<div class="line">  case FL_RELEASE:</div>
<div class="line">    ... mouse up event ...</div>
<div class="line">    return 1;</div>
<div class="line">  case FL_FOCUS :</div>
<div class="line">  case FL_UNFOCUS :</div>
<div class="line">    ... Return 1 if you want keyboard events, 0 otherwise</div>
<div class="line">    return 1;</div>
<div class="line">  case FL_KEYBOARD:</div>
<div class="line">    ... keypress, key is in Fl::event_key(), ascii in Fl::event_text()</div>
<div class="line">    ... Return 1 if you understand/use the keyboard event, 0 otherwise...</div>
<div class="line">    return 1;</div>
<div class="line">  case FL_SHORTCUT:</div>
<div class="line">    ... shortcut, key is in Fl::event_key(), ascii in Fl::event_text()</div>
<div class="line">    ... Return 1 if you understand/use the shortcut event, 0 otherwise...</div>
<div class="line">    return 1;</div>
<div class="line">  default:</div>
<div class="line">    <span class="comment">// pass other events to the base class...</span></div>
<div class="line">    return Fl_Gl_Window::handle(event);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>When <code>handle()</code> is called, the OpenGL context is not set up! If your display changes, you should call <code>redraw()</code> and let <code>draw()</code> do the work. Don't call any OpenGL drawing functions from inside <code>handle()!</code> </p>
<p>You can call <em>some</em> OpenGL stuff like hit detection and texture loading functions by doing:</p>
<div class="fragment"><div class="line"><span class="keywordflow">case</span> FL_PUSH:</div>
<div class="line">  make_current();     <span class="comment">// make OpenGL context current</span></div>
<div class="line">  <span class="keywordflow">if</span> (!valid()) {</div>
<div class="line"> </div>
<div class="line">    ... set up projection exactly the same as draw ...</div>
<div class="line"> </div>
<div class="line">    valid(1);         <span class="comment">// stop it from doing this next time</span></div>
<div class="line">  }</div>
<div class="line">  ... ok to call NON-DRAWING OpenGL <a class="code hl_struct" href="structcode.html">code</a> here, such as hit</div>
<div class="line">  detection, loading textures, etc...</div>
<div class="ttc" id="astructcode_html"><div class="ttname"><a href="structcode.html">code</a></div><div class="ttdef"><b>Definition</b> inftrees.h:24</div></div>
</div><!-- fragment --><p>Your main program can now create one of your windows by doing <code>new <a class="el" href="classMyWindow.html">MyWindow(...)</a></code>.</p>
<p>You can also use your new window class in FLUID by:</p>
<ol type="1">
<li>Putting your class definition in a <code>MyWindow.H</code> file.</li>
<li>Creating a Fl_Box widget in FLUID.</li>
<li>In the widget panel fill in the "class" field with <code><a class="el" href="classMyWindow.html">MyWindow</a></code>. This will make FLUID produce constructors for your new class.</li>
<li>In the "Extra Code" field put <code>#include "MyWindow.H"</code>, so that the FLUID output file will compile.</li>
</ol>
<p>You must put <code>glwindow-&gt;show()</code> in your main code after calling <code>show()</code> on the window containing the OpenGL window.</p>
<h1><a class="anchor" id="opengl_highdpi"></a>
OpenGL and support of HighDPI displays</h1>
<p>HighDPI displays (including the so-called 'retina' displays of Apple hardware) are supported by FLTK in such a way that 1 unit of an FLTK quantity (say, the value given by Fl_Gl_Window::w()) corresponds to more than 1 pixel on the display. Conversely, when a program specifies the width and height of the OpenGL viewport, it is necessary to use an API that returns quantities expressed in pixels. That can be done as follows: </p><div class="fragment"><div class="line">Fl_Gl_Window *glw = ...;</div>
<div class="line">glViewport(0, 0, glw-&gt;pixel_w(), glw-&gt;pixel_h());</div>
</div><!-- fragment --><p> which makes use of the Fl_Gl_Window::pixel_w() and Fl_Gl_Window::pixel_h() methods giving the size in pixels of an Fl_Gl_Window that is potentially mapped to a HighDPI display. Method Fl_Gl_Window::pixels_per_unit() can also be useful in this context. </p><dl class="section note"><dt>Note</dt><dd>A further coding rule is necessary to properly support retina displays and OpenGL under macOS (see <a class="el" href="osissues.html#osissues_retina">OpenGL and 'retina' displays</a>)</dd></dl>
<h1><a class="anchor" id="opengl_normal"></a>
Using OpenGL in Normal FLTK Windows</h1>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classDrawing.html">Drawing</a> both with OpenGL and Quartz in a normal FLTK window is not possible with the macOS platform. This technique is therefore not useful under macOS because it permits nothing more than what is possible with class Fl_Gl_Window.</dd></dl>
<p>You can put OpenGL code into the <code>draw()</code> method, as described in <a class="el" href="subclassing.html#subclassing_drawing">Drawing the Widget</a> in the previous chapter, or into the code for a <a class="el" href="common.html#common_boxtypes">boxtype</a> or other places with some care.</p>
<p>Most importantly, before you show <em>any</em> windows, including those that don't have OpenGL drawing, you <b>must</b> initialize FLTK so that it knows it is going to use OpenGL. You may use any of the symbols described for <code>Fl_Gl_Window::mode()</code> to describe how you intend to use OpenGL:</p>
<div class="fragment"><div class="line">Fl::gl_visual(FL_RGB);</div>
</div><!-- fragment --><p><a class="anchor" id="opengl_gl_start"></a><a class="anchor" id="opengl_gl_finish"></a>You can then put OpenGL drawing code anywhere you can draw normally by surrounding it with gl_start() and gl_finish() to set up, and later release, an OpenGL context with an orthographic projection so that 0,0 is the lower-left corner of the window and each pixel is one unit. The current clipping is reproduced with OpenGL <code>glScissor()</code> commands. These functions also synchronize the OpenGL graphics stream with the drawing done by other X, Windows, or FLTK functions.</p>
<div class="fragment"><div class="line">gl_start();</div>
<div class="line">... put your OpenGL <a class="code hl_struct" href="structcode.html">code</a> here ...</div>
<div class="line">gl_finish();</div>
</div><!-- fragment --><p>The same context is reused each time. If your code changes the projection transformation or anything else you should use <code>glPushMatrix()</code> and <code>glPopMatrix()</code> functions to put the state back before calling <code>gl_finish()</code>.</p>
<p>You may want to use <code>Fl_Window::current()-&gt;h()</code> to get the drawable height so that you can flip the Y coordinates.</p>
<p>Unfortunately, there are a bunch of limitations you must adhere to for maximum portability:</p>
<ul>
<li>You must choose a default visual with Fl::gl_visual().</li>
</ul>
<ul>
<li>You cannot pass <code>FL_DOUBLE</code> to Fl::gl_visual().</li>
</ul>
<ul>
<li>You cannot use Fl_Double_Window or Fl_Overlay_Window.</li>
</ul>
<p>Do <em>not</em> call <code>gl_start()</code> or <code>gl_finish()</code> when drawing into an Fl_Gl_Window !</p>
<h1><a class="anchor" id="opengl_with_fltk_widgets"></a>
Using FLTK widgets in OpenGL Windows</h1>
<p>FLTK widgets can be added to <code>Fl_Gl_Window</code>s just as they would be added to <code>Fl_Window</code>s. They are rendered as an overlay over the user defined OpenGL graphics using 'fl_..' graphics calls that are implemented in GL.</p>
<p><code>Fl_Gl_Window</code> does not add subsequent widgets as children by default as <code>Fl_Window</code> does. Call <code>myGlWindow-&gt;begin()</code> after creating the GL window to automatically add following widgets. Remember to call <code>myGlWindow-&gt;end()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>My_Gl_Window : <span class="keyword">public</span> Fl_Gl_Window {</div>
<div class="line">...</div>
<div class="line">  <span class="keywordtype">void</span> draw();</div>
<div class="line">...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">myGlWindow = <span class="keyword">new</span> My_Gl_Window(0, 0, 500, 500);</div>
<div class="line">myGlWindow-&gt;begin();</div>
<div class="line">myButton = <span class="keyword">new</span> Fl_Button(10, 10, 120, 24, <span class="stringliteral">&quot;Hello!&quot;</span>);</div>
<div class="line">myGlWindow-&gt;end();</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">void My_Gl_Window::draw() {</div>
<div class="line">  <span class="comment">// ... user GL drawing code</span></div>
<div class="line">  Fl_Gl_Window::draw(); <span class="comment">// Draw FLTK child widgets.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Users can draw into the overlay by using GL graphics calls as well as all <code>fl_...</code> graphics calls from the "Drawing Fast Shapes" section.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> My_Gl_Window::draw() {</div>
<div class="line">  <span class="comment">// ... user GL drawing code</span></div>
<div class="line">  Fl_Gl_Window::draw_begin(); <span class="comment">// Set up 1:1 projection</span></div>
<div class="line">  Fl_Window::draw();          <span class="comment">// Draw FLTK children</span></div>
<div class="line">  fl_color(FL_RED);</div>
<div class="line">  fl_rect(10, 10, 100, 100);</div>
<div class="line">  Fl_Gl_Window::draw_end();   <span class="comment">// Restore GL state</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Widgets can be drawn with transparencies by assigning an alpha value to a colormap entry and using that color in the widget.</p>
<div class="fragment"><div class="line">Fl::set_color(FL_FREE_COLOR, 255, 255, 0, 127); <span class="comment">// 50% transparent yellow</span></div>
<div class="line">myGlWindow = <span class="keyword">new</span> My_Gl_Window(0, 0, 500, 500);</div>
<div class="line">myGlWindow-&gt;begin();</div>
<div class="line">myButton = <span class="keyword">new</span> Fl_Button(10, 10, 120, 24, <span class="stringliteral">&quot;Hello!&quot;</span>);</div>
<div class="line">myButton-&gt;box(FL_BORDER_BOX);</div>
<div class="line">myButton-&gt;color(FL_FREE_COLOR);</div>
<div class="line">myGlWindow-&gt;end();</div>
</div><!-- fragment --><p>Transparencies can also be set directly when drawing. This can be used to create custom box types and RGB overlay drawings with an alpha channel.</p>
<div class="fragment"><div class="line">fl_color(0, 255, 0, 127); <span class="comment">// 50% transparent green</span></div>
<div class="line">fl_rectf(10, 10, 100, 100);</div>
<div class="line">fl_color(FL_RED); <span class="comment">// back to opaque red</span></div>
<div class="line">fl_rect(20, 20, 80, 80);</div>
</div><!-- fragment --><h1><a class="anchor" id="opengl_drawing"></a>
OpenGL Drawing Functions</h1>
<p>FLTK provides some useful OpenGL drawing functions. They can be freely mixed with any OpenGL calls, and are defined by including <code>&lt;<a class="el" href="gl_8h.html">FL/gl.h</a>&gt;</code> which you should include instead of the OpenGL header <code>&lt;GL/gl.h&gt;</code>.</p>
<p>void gl_color(Fl_Color)</p>
<dl class="section user"><dt></dt><dd>Sets the current OpenGL color to a FLTK color. <em>For color-index modes it will use <code>fl_xpixel(c)</code>, which is only right if this window uses the default colormap!</em></dd></dl>
<p>void gl_rect(int x, int y, int w, int h) <br  />
 void gl_rectf(int x, int y, int w, int h)</p>
<dl class="section user"><dt></dt><dd>Outlines or fills a rectangle with the current color. If Fl_Gl_Window::ortho() has been called, then the rectangle will exactly fill the pixel rectangle passed.</dd></dl>
<p>void gl_font(Fl_Font fontid, int size)</p>
<dl class="section user"><dt></dt><dd>Sets the current OpenGL font to the same font you get by calling <a class="el" href="drawing.html#drawing_fonts">fl_font()</a>.</dd></dl>
<p>int gl_height() <br  />
 int gl_descent() <br  />
 float gl_width(const char *s) <br  />
 float gl_width(const char *s, int n) <br  />
 float gl_width(uchar c)</p>
<dl class="section user"><dt></dt><dd>Returns information about the current OpenGL font.</dd></dl>
<p>void gl_draw(const char *s) <br  />
 void gl_draw(const char *s, int n)</p>
<dl class="section user"><dt></dt><dd>Draws a nul-terminated string or an array of <code>n</code> characters in the current OpenGL font at the current raster position.</dd></dl>
<p>void gl_draw(const char *s, int x, int y) <br  />
 void gl_draw(const char *s, int n, int x, int y) <br  />
 void gl_draw(const char *s, float x, float y) <br  />
 void gl_draw(const char *s, int n, float x, float y)</p>
<dl class="section user"><dt></dt><dd>Draws a nul-terminated string or an array of <code>n</code> characters in the current OpenGL font at the given position.</dd></dl>
<p>void gl_draw(const char *s, int x, int y, int w, int h, Fl_Align)</p>
<dl class="section user"><dt></dt><dd>Draws a string formatted into a box, with newlines and tabs expanded, other control characters changed to ^X, and aligned with the edges or center. Exactly the same output as <a class="el" href="drawing.html#drawing_text">fl_draw()</a>.</dd></dl>
<h1><a class="anchor" id="opengl_speed"></a>
Speeding up OpenGL</h1>
<p>Performance of Fl_Gl_Window may be improved on some types of OpenGL implementations, in particular MESA and other software emulators, by setting the <code>GL_SWAP_TYPE</code> environment variable. This variable declares what is in the backbuffer after you do a swapbuffers.</p>
<ul>
<li><code>setenv GL_SWAP_TYPE COPY</code> <br  />
 <br  />
 This indicates that the back buffer is copied to the front buffer, and still contains its old data. This is true of many hardware implementations. Setting this will speed up emulation of overlays, and widgets that can do partial update can take advantage of this as <code>damage()</code> will not be cleared to -1.</li>
</ul>
<ul>
<li><code>setenv GL_SWAP_TYPE NODAMAGE</code> <br  />
 <br  />
 This indicates that nothing changes the back buffer except drawing into it. This is true of MESA and Win32 software emulation and perhaps some hardware emulation on systems with lots of memory.</li>
</ul>
<ul>
<li>All other values for <code>GL_SWAP_TYPE</code>, and not setting the variable, cause FLTK to assume that the back buffer must be completely redrawn after a swap.</li>
</ul>
<p>This is easily tested by running the <a class="el" href="examples.html#examples_gl_overlay">gl_overlay</a> demo program and seeing if the display is correct when you drag another window over it or if you drag the window off the screen and back on. You have to exit and run the program again for it to see any changes to the environment variable.</p>
<h1><a class="anchor" id="opengl_optimizer"></a>
Using OpenGL Optimizer with FLTK</h1>
<p><a href="http://www.sgi.com/software/optimizer">OpenGL Optimizer</a> is a scene graph toolkit for OpenGL available from Silicon Graphics for IRIX and Microsoft Windows. It allows you to view large scenes without writing a lot of OpenGL code.</p>
<dl class="section user"><dt>OptimizerWindow Class Definition</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>To use <a href="http://www.sgi.com/software/optimizer">OpenGL Optimizer</a> with FLTK you'll need to create a subclass of Fl_Gl_Widget that includes several state variables:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">class </span>OptimizerWindow : <span class="keyword">public</span> Fl_Gl_Window {</div>
<div class="line">  csContext *context_; <span class="comment">// Initialized to 0 and set by draw()...</span></div>
<div class="line">  csDrawAction *draw_action_; <span class="comment">// Draw action...</span></div>
<div class="line">  csGroup *scene_; <span class="comment">// Scene to draw...</span></div>
<div class="line">  csCamara *camera_; <span class="comment">// Viewport for scene...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> draw();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  OptimizerWindow(<span class="keywordtype">int</span> X, <span class="keywordtype">int</span> Y, <span class="keywordtype">int</span> W, <span class="keywordtype">int</span> H, <span class="keyword">const</span> <span class="keywordtype">char</span> *L)</div>
<div class="line">    : Fl_Gl_Window(X, Y, W, H, L) {</div>
<div class="line">      context_ = (csContext *)0;</div>
<div class="line">      draw_action_ = (csDrawAction *)0;</div>
<div class="line">      scene_ = (csGroup *)0;</div>
<div class="line">      camera_ = (csCamera *)0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> scene(csGroup *g) { scene_ = g; redraw(); }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> camera(csCamera *c) {</div>
<div class="line">    camera_ = c;</div>
<div class="line">    <span class="keywordflow">if</span> (context_) {</div>
<div class="line">      draw_action_-&gt;setCamera(camera_);</div>
<div class="line">      camera_-&gt;draw(draw_action_);</div>
<div class="line">      redraw();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section user"><dt>The camera() Method</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>The <code>camera()</code> method sets the camera (projection and viewpoint) to use when drawing the scene. The scene is redrawn after this call.</dd></dl>
<dl class="section user"><dt>The draw() Method</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>The <code>draw()</code> method performs the needed initialization and does the actual drawing:</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> OptimizerWindow::draw() {</div>
<div class="line">  <span class="keywordflow">if</span> (!context_) {</div>
<div class="line">    <span class="comment">// This is the first time we&#39;ve been asked to draw; create the</span></div>
<div class="line">    <span class="comment">// Optimizer context for the scene...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line">    context_ = <span class="keyword">new</span> csContext((HDC)fl_getHDC());</div>
<div class="line">    context_-&gt;ref();</div>
<div class="line">    context_-&gt;makeCurrent((HDC)fl_getHDC());</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    context_ = <span class="keyword">new</span> csContext(fl_display, fl_visual);</div>
<div class="line">    context_-&gt;ref();</div>
<div class="line">    context_-&gt;makeCurrent(fl_display, fl_window);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// _WIN32</span></div>
<div class="line"> </div>
<div class="line">    ... perform other context setup as desired ...</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Then create the draw action to handle drawing things...</span></div>
<div class="line"> </div>
<div class="line">    draw_action_ = <span class="keyword">new</span> csDrawAction;</div>
<div class="line">    <span class="keywordflow">if</span> (camera_) {</div>
<div class="line">      draw_action_-&gt;setCamera(camera_);</div>
<div class="line">      camera_-&gt;draw(draw_action_);</div>
<div class="line">    }</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line">    context_-&gt;makeCurrent((HDC)fl_getHDC());</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    context_-&gt;makeCurrent(fl_display, fl_window);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// _WIN32</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!valid()) {</div>
<div class="line">    <span class="comment">// Update the viewport for this context...</span></div>
<div class="line">    context_-&gt;setViewport(0, 0, w(), h());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Clear the window...</span></div>
<div class="line">  context_-&gt;clear(csContext::COLOR_CLEAR | csContext::DEPTH_CLEAR,</div>
<div class="line">                  0.0f,         <span class="comment">// Red</span></div>
<div class="line">                  0.0f,         <span class="comment">// Green</span></div>
<div class="line">                  0.0f,         <span class="comment">// Blue</span></div>
<div class="line">                  1.0f);        <span class="comment">// Alpha</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Then draw the scene (if any)...</span></div>
<div class="line">  <span class="keywordflow">if</span> (scene_)</div>
<div class="line">    draw_action_-&gt;apply(scene_);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section user"><dt>The scene() Method</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>The <code>scene()</code> method sets the scene to be drawn. The scene is a collection of 3D objects in a <code>csGroup</code>. The scene is redrawn after this call.</dd></dl>
<h1><a class="anchor" id="opengl3"></a>
Using OpenGL 3.0 (or higher versions)</h1>
<p>The examples subdirectory contains OpenGL3test.cxx, a toy program showing how to use OpenGL 3.0 (or higher versions) with FLTK in a cross-platform fashion. It contains also OpenGL3-glut-test.cxx which shows how to use FLTK's GLUT compatibility and OpenGL 3.</p>
<p>To access OpenGL 3.0 (or higher versions), use the <code>FL_OPENGL3</code> flag when calling Fl_Gl_Window::mode(int a) or glutInitDisplayMode().</p>
<p><b>On the Windows and Linux platforms</b>, FLTK creates contexts implementing the highest OpenGL version supported by the hardware. Such contexts may also be compatible with lower OpenGL versions. Access to functions from OpenGL versions above 1.1 requires to load function pointers at runtime on these platforms. FLTK recommends to use the GLEW library to perform this. It is therefore necessary to install the GLEW library (see below).</p>
<p><b>On the macOS platform</b>, MacOS 10.7 or above is required; GLEW is possible but not necessary. FLTK creates contexts for OpenGL versions 1 and 2 without the FL_OPENGL3 flag and for OpenGL versions 3.2 and above (<b>but not below</b>) with it.</p>
<dl class="section user"><dt>GLEW installation (Linux and Windows platforms)</dt><dd>FLTK needs a header file, <code>GL/glew.h</code>, and a library, <code>libGLEW</code>.* or equivalent, to support OpenGL 3 and above. <br  />
These can be obtained for most Linux distributions by installing package libglew-dev. <br  />
For the Windows platform : <ul>
<li>
the header and a Visual Studio static library (glew32.lib) can be downloaded from <a href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a> ; </li>
<li>
a MinGW-style static library (libglew32.a) can be built from source (same web site) with the make command. Alternatively, pre-built files are available for these architectures : <ul>
<li>
x86: download files <a href="https://github.com/McNopper/OpenGL/blob/42fa2736e2b37db1df99c2b205279855ec6f2b1d/External/x86/Windows/MinGW/include/GL/glew.h">glew.h</a> and <a href="https://github.com/McNopper/OpenGL/blob/42fa2736e2b37db1df99c2b205279855ec6f2b1d/External/x86/Windows/MinGW/lib/libglew32.a">libglew32.a</a>; </li>
<li>
x86_64: install GLEW as an MSYS2 package with command : <div class="fragment"><div class="line">pacman -S mingw-w64-x86_64-glew</div>
</div><!-- fragment --> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Source-level changes for OpenGL 3:</dt><dd><ul>
<li>Put this in all OpenGL-using source files (instead of, or before if needed, #include &lt;<a class="el" href="gl_8h.html">FL/gl.h</a>&gt;, and before #include &lt;FL/glut.h&gt; if you use GLUT): <div class="fragment"><div class="line"><span class="preprocessor">#if defined(__APPLE__)</span></div>
<div class="line"><span class="preprocessor">#  include &lt;OpenGL/gl3.h&gt;</span> <span class="comment">// defines OpenGL 3.0+ functions</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">#  if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor">#    define GLEW_STATIC 1</span></div>
<div class="line"><span class="preprocessor">#  endif</span></div>
<div class="line"><span class="preprocessor">#  include &lt;GL/glew.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> </li>
<li>Add the <code>FL_OPENGL3</code> flag when calling Fl_Gl_Window::mode(int a) or glutInitDisplayMode(). </li>
<li>Put this in the <code>handle(int event)</code> member function of the first to be created among your Fl_Gl_Window-derived classes: <div class="fragment"><div class="line"><span class="preprocessor">#ifndef __APPLE__</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> first = 1;</div>
<div class="line">    <span class="keywordflow">if</span> (first &amp;&amp; event == FL_SHOW &amp;&amp; shown()) {</div>
<div class="line">      first = 0;</div>
<div class="line">      make_current();</div>
<div class="line">      glewInit(); <span class="comment">// defines pters to functions of OpenGL V 1.2 and above</span></div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> </li>
<li>Alternatively, if you use GLUT, put <div class="fragment"><div class="line"><span class="preprocessor">#ifndef __APPLE__</span></div>
<div class="line">  glewInit(); <span class="comment">// defines pters to functions of OpenGL V 1.2 and above</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> after the first glutCreateWindow() call.</li>
</ul>
If GLEW is installed on the Mac OS development platform, it is possible to use the same code for all platforms, with one exception: put <div class="fragment"><div class="line"><span class="preprocessor">#ifdef __APPLE__</span></div>
<div class="line">glewExperimental = GL_TRUE;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --> before the glewInit() call.</dd></dl>
<dl class="section user"><dt>Testing for success of the glewInit() call</dt><dd>Testing whether the glewInit() call is successful is to be done as follows: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FL/platform.H&gt;</span> <span class="comment">// defines FLTK_USE_WAYLAND under the Wayland platform</span></div>
<div class="line"><span class="preprocessor">#include &lt;FL/Fl.H&gt;</span> <span class="comment">// for Fl::warning()</span></div>
<div class="line"><span class="preprocessor">#ifndef __APPLE__</span></div>
<div class="line"><span class="preprocessor">#  if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor">#    define GLEW_STATIC 1</span></div>
<div class="line"><span class="preprocessor">#  endif</span></div>
<div class="line"><span class="preprocessor">#  include &lt;GL/glew.h&gt;</span></div>
<div class="line"> </div>
<div class="line">  GLenum err = glewInit(); <span class="comment">// defines pters to functions of OpenGL V 1.2 and above</span></div>
<div class="line"><span class="preprocessor">#  ifdef FLTK_USE_WAYLAND</span></div>
<div class="line">      <span class="comment">// glewInit returns GLEW_ERROR_NO_GLX_DISPLAY with Wayland</span></div>
<div class="line">      <span class="keywordflow">if</span> (fl_wl_display() &amp;&amp; err == GLEW_ERROR_NO_GLX_DISPLAY) err = GLEW_OK;</div>
<div class="line"><span class="preprocessor">#  endif</span></div>
<div class="line">  <span class="keywordflow">if</span> (err != GLEW_OK) Fl::warning(<span class="stringliteral">&quot;glewInit() failed returning %u&quot;</span>, err);</div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ! __APPLE__</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Changes in the build process</dt><dd>Link with libGLEW.so (with X11 or Wayland), libglew32.a (with MinGW) or glew32.lib (with MS Visual Studio); no change is needed on the Mac OS platform.</dd></dl>
<p> 
<hr>
<table summary="navigation bar" width="100%" border="0">
<tr>
  <td width="45%" align="LEFT">
    <a class="el" href="subclassing.html">
    [Prev]
    Adding and Extending Widgets
    </a>
  </td>
  <td width="10%" align="CENTER">
    <a class="el" href="index.html">[Index]</a>
  </td>
  <td width="45%" align="RIGHT">
    <a class="el" href="fltk-options.html">
    FLTK Runtime Options
    [Next]
    </a>
  </td>
</tr>
</table>
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

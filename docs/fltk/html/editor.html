<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: Designing a Simple Text Editor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">FLTK Programming Manual</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Designing a Simple Text Editor</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This chapter guides you through the design of a simple FLTK-based text editor. The complete source code for our text editor can be found in the test/editor.cxx file.</p>
<p>The tutorial comprises multiple chapters, and you can activate the relevant code by adjusting the TUTORIAL_CHAPTER macro at the top of the source file to match the chapter number.</p>
<p>Each chapter builds on the previous one. The documentation, as well as the source code, can be read sequentially, maintaining a consistent program structure while introducing additional features step by step.</p>
<dl class="section note"><dt>Note</dt><dd>The tutorial uses several global variables for brevity. Additionally, the order of code blocks is rather uncommon but helps to keep related features within a chapter.</dd></dl>
<h1><a class="anchor" id="editor_goals"></a>
Determining the Goals of the Text Editor</h1>
<p>As our first step, we define what we want our text editor to do:</p>
<ol type="1">
<li>Edit a single text document.</li>
<li>Provide a menubar/menus for all functions.</li>
<li>Load from a file.</li>
<li>Save to a file.</li>
<li>Keep track of when the file has been changed.</li>
<li>Cut/copy/delete/paste menus.</li>
<li>Search and replace functionality.</li>
<li>Multiple views of the same text.</li>
<li>"C" language syntax highlighting.</li>
</ol>
<h1><a class="anchor" id="editor_main_window"></a>
Chapter 1: A Minimal App</h1>
<p>Let's ensure that we can set up our build process to compile and verify our code as we add features. We begin by writing a minimal program with no other purpose than opening a window.</p>
<p>The code for that is barely longer than a "Hello, world" program and is marked in the source code as <code>TUTORIAL_CHAPTER = 1</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FL/Fl_Double_Window.H&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FL/Fl.H&gt;</span></div>
<div class="line"> </div>
<div class="line">Fl_Double_Window *app_window = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tut1_build_app_window() {</div>
<div class="line">  app_window = <span class="keyword">new</span> Fl_Double_Window(640, 480, <span class="stringliteral">&quot;FLTK Editor&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  tut1_build_app_window();</div>
<div class="line">  app_window-&gt;show(argc, argv);</div>
<div class="line">  <span class="keywordflow">return</span> Fl::run();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Passing <code>argc</code> and <code>argv</code> to <code>Fl_Double_Window::show()</code> allows FLTK to parse command line options, providing the user with the ability to change the color or graphical scheme of the editor at launch time.</p>
<p><code>Fl::run()</code> will return when no more windows in the app are visible. In other words, if all windows in an app are closed, hidden, or deleted. Pressing "Escape" or clicking the "Close" button in the window frame will close our only window, prompting <code>Fl::run()</code> to return, effectively ending the app.</p>
<p>When building FLTK from source, the <code>CMake</code> environment includes the necessary rules to build the editor. You can find more information on how to write your own <code>CMake</code> files in the <code>README.CMake.txt</code> text in the top FLTK directory.</p>
<p>For Linux and macOS, FLTK comes with the <code>fltk-config</code> script that generates the compiler commands for you:</p>
<div class="fragment"><div class="line">fltk-<a class="code hl_struct" href="structconfig__s.html">config</a> --compile editor.cxx</div>
<div class="ttc" id="astructconfig__s_html"><div class="ttname"><a href="structconfig__s.html">config_s</a></div><div class="ttdef"><b>Definition</b> deflate.c:98</div></div>
</div><!-- fragment --><p>If the code compiles and links correctly, running the app will pop up an empty application window on the desktop screen. You can close the window and quit the app by pressing the 'Escape' key or by clicking the "Close" button in the window frame.</p>
<p>Congratulations, you've just built a minimal FLTK app.</p>
<h1><a class="anchor" id="editor_main_menu"></a>
Chapter 2: Adding a Menu Bar</h1>
<p>In this chapter, we will handle the window title and add the main menu bar with a File menu and a Quit button.</p>
<p>We need to declare a variable to track track changes in the text, and a buffer for the current filename.</p>
<div class="fragment"><div class="line"><span class="comment">// remove `main()` from chapter 1, but keep the rest of the code, then add...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;FL/Fl_Menu_Bar.H&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FL/fl_ask.H&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FL/filename.H&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fl__string__functions_8h.html">FL/fl_string_functions.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">Fl_Menu_Bar *app_menu_bar = NULL;</div>
<div class="line"><span class="keywordtype">bool</span> text_changed = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordtype">char</span> app_filename[FL_PATH_MAX] = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="ttc" id="afl__string__functions_8h_html"><div class="ttname"><a href="fl__string__functions_8h.html">fl_string_functions.h</a></div></div>
</div><!-- fragment --><p>The window title is either "FLTK Editor" if the text is not saved in any file, or the filename, followed by an <code>*</code> if the text changed. Note that we have two ways to set the label of a widget. <code>label()</code> will link a static text, and <code>copy_label()</code> which will copy and manage the label text.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> update_title() {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *fname = NULL;</div>
<div class="line">  <span class="keywordflow">if</span> (app_filename[0])</div>
<div class="line">    fname = <a class="code hl_function" href="fluid__filename_8cxx.html#a759dc8f4db57c592bc53e334e1f8827d">fl_filename_name</a>(app_filename);</div>
<div class="line">  <span class="keywordflow">if</span> (fname) {</div>
<div class="line">    <span class="keywordtype">char</span> buf[FL_PATH_MAX + 3];</div>
<div class="line">    <span class="keywordflow">if</span> (text_changed) {</div>
<div class="line">      snprintf(buf, FL_PATH_MAX+2, <span class="stringliteral">&quot;%s *&quot;</span>, fname);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      snprintf(buf, FL_PATH_MAX+2, <span class="stringliteral">&quot;%s&quot;</span>, fname);</div>
<div class="line">    }</div>
<div class="line">    app_window-&gt;copy_label(buf);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    app_window-&gt;label(<span class="stringliteral">&quot;FLTK Editor&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="afluid__filename_8cxx_html_a759dc8f4db57c592bc53e334e1f8827d"><div class="ttname"><a href="fluid__filename_8cxx.html#a759dc8f4db57c592bc53e334e1f8827d">fl_filename_name</a></div><div class="ttdeci">Fl_String fl_filename_name(const Fl_String &amp;filename)</div><div class="ttdef"><b>Definition</b> fluid_filename.cxx:48</div></div>
</div><!-- fragment --><p>Now instead of writing directly to <code>text_changed</code>, we write a function that can set and clear the flag, and update the title accordingly.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_changed(<span class="keywordtype">bool</span> v) {</div>
<div class="line">  <span class="keywordflow">if</span> (v != text_changed) {</div>
<div class="line">    text_changed = v;</div>
<div class="line">    update_title();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let's do the same for changing the filename. If the new filename is NULL, the window title will revert to "FLTK Editor".</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="group__globals.html#ga6d69964bb621a0a6b7c83b7bfa250709">set_filename</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *new_filename) {</div>
<div class="line">  <span class="keywordflow">if</span> (new_filename) {</div>
<div class="line">    fl_strlcpy(app_filename, new_filename, FL_PATH_MAX);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    app_filename[0] = 0;</div>
<div class="line">  }</div>
<div class="line">  update_title();</div>
<div class="line">}</div>
<div class="ttc" id="agroup__globals_html_ga6d69964bb621a0a6b7c83b7bfa250709"><div class="ttname"><a href="group__globals.html#ga6d69964bb621a0a6b7c83b7bfa250709">set_filename</a></div><div class="ttdeci">void set_filename(const char *c)</div><div class="ttdef"><b>Definition</b> fluid.cxx:2027</div></div>
</div><!-- fragment --><p>But enough of managing window titles. The following code will add the first widget to our window. A menubar is created at the top and all across the main window.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_quit_callback(Fl_Widget *, <span class="keywordtype">void</span> *) { <span class="comment">/* TODO */</span> }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tut2_build_app_menu_bar() {</div>
<div class="line">  app_window-&gt;begin();</div>
<div class="line">  app_menu_bar = <span class="keyword">new</span> Fl_Menu_Bar(0, 0, app_window-&gt;w(), 25);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;File/Quit Editor&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;q&#39;</span>, menu_quit_callback);</div>
<div class="line">  app_window-&gt;callback(menu_quit_callback);</div>
<div class="line">  app_window-&gt;end();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  tut1_build_app_window();</div>
<div class="line">  tut2_build_app_menu_bar();</div>
<div class="line">  app_window-&gt;show(argc, argv);</div>
<div class="line">  <span class="keywordflow">return</span> Fl::run();</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>begin()</code> tells FLTK to add all widgets created hereafter to our <code>app_window</code>. In this particular case, it is redundant because creating the window in the previous chapter already called <code>begin()</code> for us.</p>
<p>In the next line, we create the menu bar and add our first menu item to it. Menus can be constructed like file paths, with forward slashes '/' separating submenus from menu items.</p>
<p>Our basic callback is simple:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_quit_callback(Fl_Widget *, <span class="keywordtype">void</span> *) {</div>
<div class="line">  Fl::hide_all_windows();</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>Fl::hide_all_windows()</code> will make all windows invisible, causing <code>Fl::run()</code> to return and <code>main</code> to exit.</p>
<p>The next line, <code>app_window-&gt;callback(menu_quit_callback)</code> links the same <code>menu_quit_callback</code> to the <code>app_window</code> as well. Assigning the window callback removes the default "Escape" key handling and allows the <code>menu_quit_callback</code> to handle that keypress with a friendly dialog box instead of just quitting the app.</p>
<p>The <code>Fl_Widget*</code> parameter in the callback will either be <code>app_window</code> if called through the window callback, or <code>app_menu_bar</code> if called by one of the menu items.</p>
<p>One of our goals was to keep track of text changes. If we know the text changed and is unsaved, we should notify the user that she is about to lose her work. We achieve this by adding a dialog box in the Quit callback that queries if the user really wants to quit, even if text was changed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_quit_callback(Fl_Widget *, <span class="keywordtype">void</span> *) {</div>
<div class="line">  <span class="keywordflow">if</span> (text_changed) {</div>
<div class="line">    <span class="keywordtype">int</span> c = <a class="code hl_function" href="group__group__comdlg.html#ga36c19b29fcd5c261f3eafdf9f7126b16">fl_choice</a>(<span class="stringliteral">&quot;Changes in your text have not been saved.\n&quot;</span></div>
<div class="line">                      <span class="stringliteral">&quot;Do you want to quit the editor anyway?&quot;</span>,</div>
<div class="line">                      <span class="stringliteral">&quot;Quit&quot;</span>, <span class="stringliteral">&quot;Cancel&quot;</span>, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (c == 1) <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  Fl::hide_all_windows();</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__comdlg_html_ga36c19b29fcd5c261f3eafdf9f7126b16"><div class="ttname"><a href="group__group__comdlg.html#ga36c19b29fcd5c261f3eafdf9f7126b16">fl_choice</a></div><div class="ttdeci">int fl_choice(const char *fmt, const char *b0, const char *b1, const char *b2,...)</div><div class="ttdef"><b>Definition</b> fl_ask.cxx:217</div></div>
</div><!-- fragment --><h1><a class="anchor" id="editor_text_widget"></a>
Chapter 3: Adding a Text Editor widget</h1>
<p>FLTK comes with a pretty capable builtin text editing widget. We will use this <code>Fl_Text_Editor</code> widget here to allow users to edit their documents.</p>
<p><code>Fl_Text_Editor</code> needs an <code>Fl_Text_Buffer</code> to do anything useful. What might seem like an unnecessary extra step is a great feature: we can assign one text buffer to multiple text editors. In a later chapter, we will use this feature to implement a split editor window.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FL/Fl_Text_Buffer.H&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FL/Fl_Text_Editor.H&gt;</span></div>
<div class="line"> </div>
<div class="line">Fl_Text_Editor *app_editor = NULL;</div>
<div class="line">Fl_Text_Editor *app_split_editor = NULL; <span class="comment">// for later</span></div>
<div class="line">Fl_Text_Buffer *app_text_buffer = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... callbacks go here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tut3_build_main_editor() {</div>
<div class="line">  app_window-&gt;begin();</div>
<div class="line">  app_text_buffer = <span class="keyword">new</span> Fl_Text_Buffer();</div>
<div class="line">  app_text_buffer-&gt;add_modify_callback(text_changed_callback, NULL);</div>
<div class="line">  app_editor = <span class="keyword">new</span> Fl_Text_Editor(0, app_menu_bar-&gt;h(),</div>
<div class="line">    app_window-&gt;w(), app_window-&gt;h() - app_menu_bar-&gt;h());</div>
<div class="line">  app_editor-&gt;buffer(app_text_buffer);</div>
<div class="line">  app_editor-&gt;textfont(FL_COURIER);</div>
<div class="line">  app_window-&gt;resizable(app_editor);</div>
<div class="line">  app_window-&gt;end();</div>
<div class="line">}</div>
</div><!-- fragment --><p>By setting the <code>app_editor</code> to be the <code>resizable()</code> property of <code>app_window</code>, we make our application window resizable on the desktop, and we ensure that resizing the window will only resize the text editor vertically, but not our menu bar.</p>
<p>To keep track of changes to the document, we add a callback to the text editor that will be called whenever text is added or deleted. The text modify callback sets our <code>text_changed</code> flag if text was changed:</p>
<div class="fragment"><div class="line"><span class="comment">// insert before tut3_build_main_editor()</span></div>
<div class="line"><span class="keywordtype">void</span> text_changed_callback(<span class="keywordtype">int</span>, <span class="keywordtype">int</span> n_inserted, <span class="keywordtype">int</span> n_deleted, <span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">void</span>*) {</div>
<div class="line">  <span class="keywordflow">if</span> (n_inserted || n_deleted)</div>
<div class="line">    set_changed(<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>To wrap this chapter up, we add a "File/New" menu and link it to a callback that clears the text buffer, clears the current filename, and marks the buffer as unchanged.</p>
<div class="fragment"><div class="line"><span class="comment">// insert before tut3_build_main_editor()</span></div>
<div class="line"><span class="keywordtype">void</span> menu_new_callback(Fl_Widget*, <span class="keywordtype">void</span>*) {</div>
<div class="line">  app_text_buffer-&gt;text(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">  set_changed(<span class="keyword">false</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// insert at the end of tut3_build_main_editor()</span></div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// find the Quit menu and insert the New menu there</span></div>
<div class="line">  <span class="keywordtype">int</span> ix = app_menu_bar-&gt;find_index(menu_quit_callback);</div>
<div class="line">  app_menu_bar-&gt;insert(ix, <span class="stringliteral">&quot;New&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;n&#39;</span>, menu_new_callback);</div>
<div class="line">  ...</div>
</div><!-- fragment --><h1><a class="anchor" id="editor_file_support"></a>
Chapter 4: Reading and Writing Files</h1>
<p>In this chapter, we will add support for loading and saving text files, so we need three more menu items in the File menu: Open, Save, and Save As.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FL/Fl_Native_File_Chooser.H&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FL/platform.H&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... add callbacks here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tut4_add_file_support() {</div>
<div class="line">  <span class="keywordtype">int</span> ix = app_menu_bar-&gt;find_index(menu_quit_callback);</div>
<div class="line">  app_menu_bar-&gt;insert(ix, <span class="stringliteral">&quot;Open&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;o&#39;</span>, menu_open_callback, NULL, FL_MENU_DIVIDER);</div>
<div class="line">  app_menu_bar-&gt;insert(ix+1, <span class="stringliteral">&quot;Save&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;s&#39;</span>, menu_save_callback);</div>
<div class="line">  app_menu_bar-&gt;insert(ix+2, <span class="stringliteral">&quot;Save as...&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;S&#39;</span>, menu_save_as_callback, NULL, FL_MENU_DIVIDER);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The menu shortcuts <code>FL_COMMAND+'s'</code> and <code>FL_COMMAND+'S'</code> look the same at a first glance, but the second shortcut is actually <code>Ctrl-Shift-S</code> due to the capital letter 'S'. Also, we use <code>FL_COMMAND</code> as our menu shortcut modifier key. <code>FL_COMMAND</code> translates to <code>FL_CTRL</code> on Windows and Linux, and to <code>FL_META</code> on macOS, better known as the cloverleaf, or simply "the Apple key".</dd></dl>
<p>We implement the Save As callback first, because we will want to call it from the Open callback later. The basic callback is only a few lines of code.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_save_as_callback(Fl_Widget*, <span class="keywordtype">void</span>*) {</div>
<div class="line">  Fl_Native_File_Chooser file_chooser;</div>
<div class="line">  file_chooser.title(<span class="stringliteral">&quot;Save File As...&quot;</span>);</div>
<div class="line">  file_chooser.type(Fl_Native_File_Chooser::BROWSE_SAVE_FILE);</div>
<div class="line">  <span class="keywordflow">if</span> (file_chooser.show() == 0) {</div>
<div class="line">    app_text_buffer-&gt;savefile(file_chooser.filename());</div>
<div class="line">    <a class="code hl_function" href="group__globals.html#ga6d69964bb621a0a6b7c83b7bfa250709">set_filename</a>(file_chooser.filename());</div>
<div class="line">    set_changed(<span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>However if the user has already set a file name including path information, it is the polite thing to preload the file chooser with that information. This little chunk of code will separate the file name from the path before we call <code>file_chooser.show()</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// insert before `if (file_chooser.show()...`</span></div>
<div class="line">  <span class="keywordflow">if</span> (app_filename[0]) {</div>
<div class="line">    <span class="keywordtype">char</span> temp_filename[FL_PATH_MAX];</div>
<div class="line">    fl_strlcpy(temp_filename, app_filename, FL_PATH_MAX);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code hl_function" href="fluid__filename_8cxx.html#a759dc8f4db57c592bc53e334e1f8827d">fl_filename_name</a>(temp_filename);</div>
<div class="line">    <span class="keywordflow">if</span> (name) {</div>
<div class="line">      file_chooser.preset_file(name);</div>
<div class="line">      temp_filename[name - temp_filename] = 0;</div>
<div class="line">      file_chooser.directory(temp_filename);</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Great. Now let's add code for our File/Save menu. If no filename was set yet, it falls back to our Save As callback. <code>Fl_Text_Editor::savefile()</code> writes the contents of our text widget into a UTF-8 encoded text file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_save_callback(Fl_Widget*, <span class="keywordtype">void</span>*) {</div>
<div class="line">  <span class="keywordflow">if</span> (!app_filename[0]) {</div>
<div class="line">    menu_save_as_callback(NULL, NULL);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    app_text_buffer-&gt;savefile(file_chooser.filename());</div>
<div class="line">    set_changed(<span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now that we have a save method available, we can improve the <code>menu_quit_callback</code> and offer the option to save the current modified text before quitting the app. Here is the new quit callback code that replaces the old callback:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_quit_callback(Fl_Widget *, <span class="keywordtype">void</span> *) {</div>
<div class="line">  <span class="keywordflow">if</span> (text_changed) {</div>
<div class="line">      <span class="keywordtype">int</span> r = <a class="code hl_function" href="group__group__comdlg.html#ga36c19b29fcd5c261f3eafdf9f7126b16">fl_choice</a>(<span class="stringliteral">&quot;The current file has not been saved.\n&quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;Would you like to save it now?&quot;</span>,</div>
<div class="line">                        <span class="stringliteral">&quot;Cancel&quot;</span>, <span class="stringliteral">&quot;Save&quot;</span>, <span class="stringliteral">&quot;Don&#39;t Save&quot;</span>);</div>
<div class="line">      <span class="keywordflow">if</span> (r == 0)   <span class="comment">// cancel</span></div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      <span class="keywordflow">if</span> (r == 1) { <span class="comment">// save</span></div>
<div class="line">        menu_save_callback(NULL, NULL);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">  }</div>
<div class="line">  Fl::hide_all_windows();</div>
<div class="line">}</div>
</div><!-- fragment --><p>On to loading a new file. Let's write the function to load a file from a given file name:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> load(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename) {</div>
<div class="line">  <span class="keywordflow">if</span> (app_text_buffer-&gt;loadfile(filename) == 0) {</div>
<div class="line">    <a class="code hl_function" href="group__globals.html#ga6d69964bb621a0a6b7c83b7bfa250709">set_filename</a>(filename);</div>
<div class="line">    set_changed(<span class="keyword">false</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>A friendly app should warn the user if file operations fail. This can be done in three lines of code, so let's add an alert dialog after every <code>loadfile</code> and <code>savefile</code> call. This is exemplary for <code>load()</code>, and the code is very similar for the two other locations.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> load(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename) {</div>
<div class="line">  <span class="keywordflow">if</span> (app_text_buffer-&gt;loadfile(filename) == 0) {</div>
<div class="line">    <a class="code hl_function" href="group__globals.html#ga6d69964bb621a0a6b7c83b7bfa250709">set_filename</a>(filename);</div>
<div class="line">    set_changed(<span class="keyword">false</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="group__group__comdlg.html#gae998e9cd38954bfde24bd20e550e9b8a">fl_alert</a>(<span class="stringliteral">&quot;Failed to load file\n%s\n%s&quot;</span>,</div>
<div class="line">             filename,</div>
<div class="line">             strerror(errno));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__comdlg_html_gae998e9cd38954bfde24bd20e550e9b8a"><div class="ttname"><a href="group__group__comdlg.html#gae998e9cd38954bfde24bd20e550e9b8a">fl_alert</a></div><div class="ttdeci">void fl_alert(const char *fmt,...)</div><div class="ttdef"><b>Definition</b> fl_ask.cxx:122</div></div>
</div><!-- fragment --><p>If the user selects our pulldown "Load" menu, we first check if the current text was modified and provide a dialog box that offers to save the changes before loading a new text file:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_open_callback(Fl_Widget*, <span class="keywordtype">void</span>*) {</div>
<div class="line">  <span class="keywordflow">if</span> (text_changed) {</div>
<div class="line">    <span class="keywordtype">int</span> r = <a class="code hl_function" href="group__group__comdlg.html#ga36c19b29fcd5c261f3eafdf9f7126b16">fl_choice</a>(<span class="stringliteral">&quot;The current file has not been saved.\n&quot;</span></div>
<div class="line">                      <span class="stringliteral">&quot;Would you like to save it now?&quot;</span>,</div>
<div class="line">                      <span class="stringliteral">&quot;Cancel&quot;</span>, <span class="stringliteral">&quot;Save&quot;</span>, <span class="stringliteral">&quot;Don&#39;t Save&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (r == 2)</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (r == 1)</div>
<div class="line">      menu_save_callback();</div>
<div class="line">  }</div>
<div class="line">  ...</div>
</div><!-- fragment --><p>If the user did not cancel the operation, we pop up a file chooser for loading the file, using similar code as in Save As.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">  Fl_Native_File_Chooser file_chooser;</div>
<div class="line">  file_chooser.title(<span class="stringliteral">&quot;Open File...&quot;</span>);</div>
<div class="line">  file_chooser.type(Fl_Native_File_Chooser::BROWSE_FILE);</div>
<div class="line">...</div>
</div><!-- fragment --><p>Again, we preload the file chooser with the last used path and file name:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">  <span class="keywordflow">if</span> (app_filename[0]) {</div>
<div class="line">    <span class="keywordtype">char</span> temp_filename[FL_PATH_MAX];</div>
<div class="line">    fl_strlcpy(temp_filename, app_filename, FL_PATH_MAX);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *name = <a class="code hl_function" href="fluid__filename_8cxx.html#a759dc8f4db57c592bc53e334e1f8827d">fl_filename_name</a>(temp_filename);</div>
<div class="line">    <span class="keywordflow">if</span> (name) {</div>
<div class="line">      file_chooser.preset_file(name);</div>
<div class="line">      temp_filename[name - temp_filename] = 0;</div>
<div class="line">      file_chooser.directory(temp_filename);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">...</div>
</div><!-- fragment --><p>And finally, we pop up the file chooser. If the user cancels the file dialog, we do nothing and keep the current file. Otherwise, we call the <code>load()</code> function that we already wrote:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (file_chooser.show() == 0)</div>
<div class="line">    load(file_chooser.filename());</div>
<div class="line">}</div>
</div><!-- fragment --><p>We really should support two more ways to load documents from a file. Let's modify the "show and run" part of <code>main()</code> to handle command line parameters and desktop drag'n'drop operations. For that, we refactor the last two lines of <code>main()</code> into a new function:</p>
<div class="fragment"><div class="line"><span class="comment">// ... new function here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  tut1_build_app_window();</div>
<div class="line">  tut2_build_app_menu_bar();</div>
<div class="line">  tut3_build_main_editor();</div>
<div class="line">  tut4_add_file_support();</div>
<div class="line">  <span class="comment">// ... refactor those into the new function</span></div>
<div class="line">  <span class="comment">// app_window-&gt;show(argc, argv);</span></div>
<div class="line">  <span class="comment">// return Fl::run();</span></div>
<div class="line">  <span class="keywordflow">return</span> tut4_handle_commandline_and_run(argc, argv);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Our function to show the window and run the app has a few lines of boilerplate code. <code>Fl::args_to_utf8()</code> converts the command line argument from whatever the host system provides into Unicode. <code>Fl::args()</code> goes through the list of arguments and gives <code>args_handler()</code> a chance to handle each argument. It also makes sure that FLTK specific args are still forwarded to FLTK, so <code>"-scheme plastic"</code> and <code>"-background #aaccff"</code> will draw beautiful blue buttons in a plastic look.</p>
<p><code><a class="el" href="group__group__macosx.html#ga0702a54934d10f5b72157137cf291296">fl_open_callback()</a></code> lets FLTK know what to do if a user drops a text file onto our editor icon (Apple macOS). Here, we ask it to call the <code>load()</code> function that we wrote earlier.</p>
<div class="fragment"><div class="line"><span class="comment">// ... args_handler here</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> tut4_handle_commandline_and_run(<span class="keywordtype">int</span> &amp;argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">  <span class="keywordtype">int</span> i = 0;</div>
<div class="line">  Fl::args_to_utf8(argc, argv);</div>
<div class="line">  Fl::args(argc, argv, i, args_handler);</div>
<div class="line">  <a class="code hl_function" href="group__group__macosx.html#ga0702a54934d10f5b72157137cf291296">fl_open_callback</a>(load);</div>
<div class="line">  app_window-&gt;show(argc, argv);</div>
<div class="line">  <span class="keywordflow">return</span> Fl::run();</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__macosx_html_ga0702a54934d10f5b72157137cf291296"><div class="ttname"><a href="group__group__macosx.html#ga0702a54934d10f5b72157137cf291296">fl_open_callback</a></div><div class="ttdeci">void fl_open_callback(void(*cb)(const char *))</div><div class="ttdef"><b>Definition</b> Fl.cxx:2332</div></div>
</div><!-- fragment --><p>Last work item for this long chapter: what should our <code>args_handler</code> do? We could handle additional command line options here, but for now, all we want to handle is file names and paths. Let's make this easy: if the current arg does not start with a '-', we assume it is a file name, and we call <code>load()</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> args_handler(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv, <span class="keywordtype">int</span> &amp;i) {</div>
<div class="line">  <span class="keywordflow">if</span> (argv &amp;&amp; argv[i] &amp;&amp; argv[i][0]!=<span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line">    load(argv[i]);</div>
<div class="line">    i++;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>So this is our basic but quite functional text editor app in about 100 lines of code. The following chapters add some user convenience functions and show off some FLTK features including split editors and syntax highlighting.</p>
<h1><a class="anchor" id="editor_cut_copy_paste"></a>
Chapter 5: Cut, Copy, and Paste</h1>
<p>The FLTK Text Editor widget comes with builtin cut, copy, and paste functionality, but as a courtesy, we should also offer these as menu items in the main menu.</p>
<p>In our feature list, we noted that we want to implement a split text editor. This requires that the callbacks know which text editor has the keyboard focus. Calling <code>Fl::focus()</code> may return <code>NULL</code> or other unknown widgets, so we add a little test in our callbacks:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_cut_callback(Fl_Widget*, <span class="keywordtype">void</span>* v) {</div>
<div class="line">  Fl_Widget *e = Fl::focus();</div>
<div class="line">  <span class="keywordflow">if</span> (e &amp;&amp; (e == app_editor || e == app_split_editor))</div>
<div class="line">    Fl_Text_Editor::kf_cut(0, (Fl_Text_Editor*)e);</div>
<div class="line">}</div>
</div><!-- fragment --><p>We can write very similar callbacks for undo, redo, copy, paste, and delete. Adding a new menu and the six menu items follows the same pattern as before. Using the Menu/Item notation will create an Edit menu for us:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> tut5_cut_copy_paste() {</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Edit/Undo&quot;</span>,   FL_COMMAND+<span class="charliteral">&#39;z&#39;</span>, menu_undo_callback);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Edit/Redo&quot;</span>,   FL_COMMAND+<span class="charliteral">&#39;Z&#39;</span>, menu_redo_callback, NULL, FL_MENU_DIVIDER);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Edit/Cut&quot;</span>,    FL_COMMAND+<span class="charliteral">&#39;x&#39;</span>, menu_cut_callback);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Edit/Copy&quot;</span>,   FL_COMMAND+<span class="charliteral">&#39;c&#39;</span>, menu_copy_callback);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Edit/Paste&quot;</span>,  FL_COMMAND+<span class="charliteral">&#39;v&#39;</span>, menu_paste_callback);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Edit/Delete&quot;</span>, 0,              menu_delete_callback);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="editor_find"></a>
Chapter 6: Find and Find Next</h1>
<p>Corporate called. They want a dialog box for their users that can search for some word in the text file. We can add this functionality using a callback and a standard FLTK dialog box.</p>
<p>Here is some code to find a string in a text editor. The first four lines make sure that we start our search at the cursor position of the current editor window. The rest of the code searches the string and marks it if found.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> find_next(<span class="keyword">const</span> <span class="keywordtype">char</span> *needle) {</div>
<div class="line">  Fl_Text_Editor *editor = app_editor;</div>
<div class="line">  Fl_Widget *e = Fl::focus();</div>
<div class="line">  <span class="keywordflow">if</span> (e &amp;&amp; e == app_split_editor)</div>
<div class="line">    editor = app_split_editor;</div>
<div class="line">  <span class="keywordtype">int</span> pos = editor-&gt;insert_position();</div>
<div class="line">  <span class="keywordtype">int</span> found = app_text_buffer-&gt;search_forward(pos, needle, &amp;pos);</div>
<div class="line">  <span class="keywordflow">if</span> (found) {</div>
<div class="line">    app_text_buffer-&gt;select(pos, pos + (<span class="keywordtype">int</span>)strlen(needle));</div>
<div class="line">    editor-&gt;insert_position(pos + (<span class="keywordtype">int</span>)strlen(needle));</div>
<div class="line">    editor-&gt;show_insert_position();</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <a class="code hl_function" href="group__group__comdlg.html#gae998e9cd38954bfde24bd20e550e9b8a">fl_alert</a>(<span class="stringliteral">&quot;No further occurrences of &#39;%s&#39; found!&quot;</span>, needle);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The callbacks are short, using the FLTK text field dialog box and the <code>find_next</code> function that we already implemented. The last searched text is saved in <code>last_find_text</code> to be reused by <code>menu_find_next_callback</code>. If no search text was set yet, or it was set to an empty text, "Find Next" will forward to <code>menu_find_callback</code> and pop up our "Find Text" dialog.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> last_find_text[1024] = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> menu_find_callback(Fl_Widget*, <span class="keywordtype">void</span>* v) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *find_text = <a class="code hl_function" href="group__group__comdlg.html#ga2fef37bee5a282b195b98386bd4b8bda">fl_input</a>(<span class="stringliteral">&quot;Find in text:&quot;</span>, last_find_text);</div>
<div class="line">  <span class="keywordflow">if</span> (find_text) {</div>
<div class="line">    fl_strlcpy(last_find_text, find_text, <span class="keyword">sizeof</span>(last_find_text));</div>
<div class="line">    find_next(find_text);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> menu_find_next_callback(Fl_Widget*, <span class="keywordtype">void</span>* v) {</div>
<div class="line">  <span class="keywordflow">if</span> (last_find_text[0]) {</div>
<div class="line">    find_next(last_find_text);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    menu_find_callback(NULL, NULL);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__comdlg_html_ga2fef37bee5a282b195b98386bd4b8bda"><div class="ttname"><a href="group__group__comdlg.html#ga2fef37bee5a282b195b98386bd4b8bda">fl_input</a></div><div class="ttdeci">const char * fl_input(const char *fmt, const char *defstr,...)</div><div class="ttdef"><b>Definition</b> fl_ask.cxx:307</div></div>
</div><!-- fragment --><p>And of course we need to add two menu items to our main application menu.</p>
<div class="fragment"><div class="line">...</div>
<div class="line">app_menu_bar-&gt;add(<span class="stringliteral">&quot;Find/Find...&quot;</span>,   FL_COMMAND+<span class="charliteral">&#39;f&#39;</span>, menu_find_callback);</div>
<div class="line">app_menu_bar-&gt;add(<span class="stringliteral">&quot;Find/Find Next&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;g&#39;</span>, menu_find_next_callback, NULL, FL_MENU_DIVIDER);</div>
<div class="line">...</div>
</div><!-- fragment --><h1><a class="anchor" id="editor_replace"></a>
Chapter 7: Replace and Replace Next</h1>
<p>To implement the next feature, we will need to implement our own "Find
and Replace" dialog box. To make this dialog box useful, it needs the following elements:</p>
<ul>
<li>a text input field for the text that we want to find</li>
<li>a text input field for the replacement text</li>
<li>a button to find the next occurrence</li>
<li>a button to replace the current text and find the next occurrence</li>
<li>a button to close the dialog</li>
</ul>
<p>This is rather complex functionality, so instead of adding more global variables, we will pack this dialog into a class, derived from <code>Fl_Window</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The tutorial uses <code>Fl_Double_Window</code> instead of <code>Fl_Window</code> throughout. Historically, on some platforms, <code>Fl_Window</code> renders faster, but has a tendency to flicker. In today's world, this has very little relevance and FLTK optimizes both window types. <code>Fl_Double_Window</code> is recommended unless there is a specific reason to use <code>Fl_Window</code>.</dd></dl>
<p>Let's implement the text replacement code first:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> last_replace_text[1024] = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> replace_selection(<span class="keyword">const</span> <span class="keywordtype">char</span> *new_text) {</div>
<div class="line">  Fl_Text_Editor *editor = app_editor;</div>
<div class="line">  Fl_Widget *e = Fl::focus();</div>
<div class="line">  <span class="keywordflow">if</span> (e &amp;&amp; e == app_split_editor)</div>
<div class="line">    editor = app_split_editor;</div>
<div class="line">  <span class="keywordtype">int</span> start, end;</div>
<div class="line">  <span class="keywordflow">if</span> (app_text_buffer-&gt;selection_position(&amp;start, &amp;end)) {</div>
<div class="line">    app_text_buffer-&gt;remove_selection();</div>
<div class="line">    app_text_buffer-&gt;insert(start, new_text);</div>
<div class="line">    app_text_buffer-&gt;select(start, start + (<span class="keywordtype">int</span>)strlen(new_text));</div>
<div class="line">    editor-&gt;insert_position(start + (<span class="keywordtype">int</span>)strlen(new_text));</div>
<div class="line">    editor-&gt;show_insert_position();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>As before, the first four lines anticipate a split editor and find the editor that has focus. The code then deletes the currently selected text, replaces it with the new text, selects the new text, and finally sets the text cursor to the end of the new text.</p>
<h3>The <a class="el" href="classReplace__Dialog.html">Replace_Dialog</a> class</h3>
<p>The <a class="el" href="classReplace__Dialog.html">Replace_Dialog</a> class holds pointers to our active UI elements as well as all the callbacks for the dialog buttons.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a> : <span class="keyword">public</span> Fl_Double_Window {</div>
<div class="line">  Fl_Input *find_text_input;</div>
<div class="line">  Fl_Input *replace_text_input;</div>
<div class="line">  Fl_Button *find_next_button;</div>
<div class="line">  Fl_Button *replace_and_find_button;</div>
<div class="line">  Fl_Button *close_button;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *label);</div>
<div class="line">  <span class="keywordtype">void</span> show() FL_OVERRIDE;</div>
<div class="line">private:</div>
<div class="line">  static <span class="keywordtype">void</span> find_next_callback(Fl_Widget*, <span class="keywordtype">void</span>*);</div>
<div class="line">  static <span class="keywordtype">void</span> replace_and_find_callback(Fl_Widget*, <span class="keywordtype">void</span>*);</div>
<div class="line">  static <span class="keywordtype">void</span> close_callback(Fl_Widget*, <span class="keywordtype">void</span>*);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a> *replace_dialog = NULL;</div>
<div class="ttc" id="aclassReplace__Dialog_html"><div class="ttname"><a href="classReplace__Dialog.html">Replace_Dialog</a></div><div class="ttdef"><b>Definition</b> editor.cxx:456</div></div>
</div><!-- fragment --><p>The constructor creates the dialog and marks it as "non modal". This will make the dialog hover over the application window like a toolbox window until the user closes it, allowing multiple "find and replace" operations. So here is our constructor:</p>
<div class="fragment"><div class="line">Replace_Dialog::Replace_Dialog(<span class="keyword">const</span> <span class="keywordtype">char</span> *label)</div>
<div class="line">: Fl_Double_Window(430, 110, label)</div>
<div class="line">{</div>
<div class="line">  find_text_input = <span class="keyword">new</span> Fl_Input(100, 10, 320, 25, <span class="stringliteral">&quot;Find:&quot;</span>);</div>
<div class="line">  replace_text_input = <span class="keyword">new</span> Fl_Input(100, 40, 320, 25, <span class="stringliteral">&quot;Replace:&quot;</span>);</div>
<div class="line">  Fl_Flex* button_field = <span class="keyword">new</span> Fl_Flex(100, 70, w()-100, 40);</div>
<div class="line">  button_field-&gt;type(Fl_Flex::HORIZONTAL);</div>
<div class="line">  button_field-&gt;margin(0, 5, 10, 10);</div>
<div class="line">  button_field-&gt;gap(10);</div>
<div class="line">  find_next_button = <span class="keyword">new</span> Fl_Button(0, 0, 0, 0, <span class="stringliteral">&quot;Next&quot;</span>);</div>
<div class="line">  find_next_button-&gt;callback(find_next_callback, <span class="keyword">this</span>);</div>
<div class="line">  replace_and_find_button = <span class="keyword">new</span> Fl_Button(0, 0, 0, 0, <span class="stringliteral">&quot;Replace&quot;</span>);</div>
<div class="line">  replace_and_find_button-&gt;callback(replace_and_find_callback, <span class="keyword">this</span>);</div>
<div class="line">  close_button = <span class="keyword">new</span> Fl_Button(0, 0, 0, 0, <span class="stringliteral">&quot;Close&quot;</span>);</div>
<div class="line">  close_button-&gt;callback(close_callback, <span class="keyword">this</span>);</div>
<div class="line">  button_field-&gt;end();</div>
<div class="line">  set_non_modal();</div>
<div class="line">}</div>
</div><!-- fragment --><p>All buttons are created inside an <code>Fl_Flex</code> group. They will be arranged automatically by <code>Fl_Flex</code>, so there is no need to set x and y coordinates or a width or height. <code>button_field</code> will lay out the buttons for us.</p>
<dl class="section note"><dt>Note</dt><dd>There is no need to write a destructor or delete individual widgets. When we delete an instance of <code><a class="el" href="classReplace__Dialog.html">Replace_Dialog</a></code>, all children are deleted for us.</dd></dl>
<p>The <code>show()</code> method overrides the window's show method. It adds some code to preload the values of the text fields for added convenience. It then pops up the dialog box by calling the original <code>Fl_Double_Window::show()</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Replace_Dialog::show() {</div>
<div class="line">  find_text_input-&gt;value(last_find_text);</div>
<div class="line">  replace_text_input-&gt;value(last_replace_text);</div>
<div class="line">  Fl_Double_Window::show();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The buttons in the dialog need callbacks to be useful. If callbacks are defined within a class, they must be defined <code>static</code>, but a pointer to the class can be provided through the <code>user_data</code> field. We have done that in the constructor by adding <code>this</code> as the last argument when setting the callback, for example in <code>close_button-&gt;callback(close_callback, this);</code>.</p>
<p>The callback itself can then extract the <code>this</code> pointer with a static cast:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Replace_Dialog::close_callback(Fl_Widget*, <span class="keywordtype">void</span>* my_dialog) {</div>
<div class="line">  <a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a> *dlg = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a>*<span class="keyword">&gt;</span>(my_dialog);</div>
<div class="line">  dlg-&gt;hide();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The callback for the Find button uses our already implemented <code>find_next</code> function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Replace_Dialog::find_next_callback(Fl_Widget*, <span class="keywordtype">void</span>* my_dialog) {</div>
<div class="line">  <a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a> *dlg = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a>*<span class="keyword">&gt;</span>(my_dialog);</div>
<div class="line">  fl_strlcpy(last_find_text, dlg-&gt;find_text_input-&gt;value(), <span class="keyword">sizeof</span>(last_find_text));</div>
<div class="line">  fl_strlcpy(last_replace_text, dlg-&gt;replace_text_input-&gt;value(), <span class="keyword">sizeof</span>(last_replace_text));</div>
<div class="line">  <span class="keywordflow">if</span> (last_find_text[0])</div>
<div class="line">    find_next(last_find_text);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The Replace button callback calls our newly implemented <code>replace_selection</code> function and then continues on to the <code>find_next_callback</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Replace_Dialog::replace_and_find_callback(Fl_Widget*, <span class="keywordtype">void</span>* my_dialog) {</div>
<div class="line">  <a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a> *dlg = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a>*<span class="keyword">&gt;</span>(my_dialog);</div>
<div class="line">  replace_selection(dlg-&gt;replace_text_input-&gt;value());</div>
<div class="line">  find_next_callback(NULL, my_dialog);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This long chapter comes close to its end. We are missing menu items that pop up our dialog and that allow a quick "Replace and Find Next" functionality without popping up the dialog. The code is quite similar to the "Find" and "Find Next" code in the previous chapter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_replace_callback(Fl_Widget*, <span class="keywordtype">void</span>*) {</div>
<div class="line">  <span class="keywordflow">if</span> (!replace_dialog)</div>
<div class="line">    replace_dialog = <span class="keyword">new</span> <a class="code hl_class" href="classReplace__Dialog.html">Replace_Dialog</a>(<span class="stringliteral">&quot;Find and Replace&quot;</span>);</div>
<div class="line">  replace_dialog-&gt;show();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> menu_replace_next_callback(Fl_Widget*, <span class="keywordtype">void</span>*) {</div>
<div class="line">  <span class="keywordflow">if</span> (!last_find_text[0]) {</div>
<div class="line">    menu_replace_callback(NULL, NULL);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    replace_selection(last_replace_text);</div>
<div class="line">    find_next(last_find_text);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tut7_implement_replace() {</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Find/Replace...&quot;</span>,   FL_COMMAND+<span class="charliteral">&#39;r&#39;</span>, menu_replace_callback);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Find/Replace Next&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;t&#39;</span>, menu_replace_next_callback);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="editor_editor_features"></a>
Chapter 8: Editor Features</h1>
<p>Chapter 7 was long an intense. Let's relax and implement something simple here. We want menus with check boxes that can toggle some text editor features on and off:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> tut8_editor_features() {</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Window/Line Numbers&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;l&#39;</span>, menu_linenumbers_callback, NULL, FL_MENU_TOGGLE);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Window/Word Wrap&quot;</span>, 0, menu_wordwrap_callback, NULL, FL_MENU_TOGGLE);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>Fl_Widget</code> parameter in callbacks always points to the widget that causes the callback. Menu items are not derived from widgets, so to find out which menu item caused a callback, we can do this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_linenumbers_callback(Fl_Widget* w, <span class="keywordtype">void</span>*) {</div>
<div class="line">  Fl_Menu_Bar* menu = <span class="keyword">static_cast&lt;</span>Fl_Menu_Bar*<span class="keyword">&gt;</span>(w);</div>
<div class="line">  <span class="keyword">const</span> Fl_Menu_Item* linenumber_item = menu-&gt;mvalue();</div>
<div class="line">  <span class="keywordflow">if</span> (linenumber_item-&gt;value()) {</div>
<div class="line">    app_editor-&gt;linenumber_width(40);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    app_editor-&gt;linenumber_width(0);</div>
<div class="line">  }</div>
<div class="line">  app_editor-&gt;redraw();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Setting the width enables the line numbers, setting it to 0 disables the line number display. When changing the value of a widget, FLTK will make sure that the widget is redrawn to reflect the new value. When changing other attributes such as colors or fonts, FLTK assumes that many attributes are changed at the same time and leaves it to the user to call <code>Fl_Widget::redraw()</code> when done. Here we call <code>app_editor-&gt;redraw()</code> to make sure that the change in the line number setting is also drawn on screen.</p>
<p>Let's not forget to update the line number display for a potential split editor widget es well:</p>
<div class="fragment"><div class="line"><span class="comment">// add before the end of menu_linenumbers_callback</span></div>
<div class="line"><span class="keywordflow">if</span> (app_split_editor) {</div>
<div class="line">  <span class="keywordflow">if</span> (linenumber_item-&gt;value()) {</div>
<div class="line">    app_split_editor-&gt;linenumber_width(40);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    app_split_editor-&gt;linenumber_width(0);</div>
<div class="line">  }</div>
<div class="line">  app_split_editor-&gt;redraw();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The word wrap feature is activated by calling <code>Fl_Text_Editor::wrap_mode()</code> with the parameters <code>Fl_Text_Display::WRAP_AT_BOUNDS</code> and <code>0</code>. It's deactivated with <code>Fl_Text_Display::WRAP_NONE</code>. The implementation of the callback is the same as <code>menu_linenumbers_callback</code>.</p>
<h1><a class="anchor" id="editor_split_editor"></a>
Chapter 9: Split Editor</h1>
<p>When editing long source code files, it can be really helpful to split the editor to view statements at the top of the text while adding features at the bottom of the text in a split text view.</p>
<p>FLTK can link multiple text editors to a single text buffer. Let's implement this now. This chapter will show you how to rearrange widgets in an existing widget tree.</p>
<p>Our initializer removes the main text editor from the widget tree and replaces it with an <code><a class="el" href="classFl__Tile.html">Fl_Tile</a></code>. A tile can hold multiple widgets that can then be resized interactively by the user by clicking and dragging the divider between those widgets.</p>
<p>We start by replacing the editor widget with a tile group of the same size.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FL/Fl_Tile.H&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classFl__Tile.html">Fl_Tile</a> *app_tile = NULL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> tut9_split_editor() {</div>
<div class="line">  app_window-&gt;begin();</div>
<div class="line">  app_tile = <span class="keyword">new</span> <a class="code hl_class" href="classFl__Tile.html">Fl_Tile</a>(app_editor-&gt;x(), app_editor-&gt;y(),</div>
<div class="line">                         app_editor-&gt;w(), app_editor-&gt;h());</div>
<div class="line">  app_window-&gt;remove(app_editor);</div>
<div class="ttc" id="aclassFl__Tile_html"><div class="ttname"><a href="classFl__Tile.html">Fl_Tile</a></div></div>
</div><!-- fragment --><p>Next we add our existing editor as the first child of the tile and create another text editor <code>app_split_editor</code> as the second child of the tile, but it's hidden for now with a height of zero pixels.</p>
<dl class="section note"><dt>Note</dt><dd>Creating the new <code><a class="el" href="classFl__Tile.html">Fl_Tile</a></code> also calls <code>Fl_Tile::begin()</code>. <br  />
<br  />
Adding <code>app_editor</code> to the tile would have also removed it from <code>app_window</code>, so <code>app_window-&gt;remove(app_editor)</code> in the code above is not really needed, but illustrates what we are doing.</dd></dl>
<div class="fragment"><div class="line">app_tile-&gt;add(app_editor);</div>
<div class="line">app_split_editor = <span class="keyword">new</span> Fl_Text_Editor(app_tile-&gt;x(), app_tile-&gt;y()+app_tile-&gt;h(),</div>
<div class="line">                                      app_tile-&gt;w(), 0);</div>
<div class="line">app_split_editor-&gt;buffer(app_text_buffer);</div>
<div class="line">app_split_editor-&gt;textfont(FL_COURIER);</div>
<div class="line">app_split_editor-&gt;hide();</div>
</div><!-- fragment --><p>Now we clean up after ourselves and make sure that the resizables are all set correctly. Lastly, we add a menu item with a callback.</p>
<div class="fragment"><div class="line">  app_tile-&gt;end();</div>
<div class="line">  app_tile-&gt;size_range(0, 25, 25);</div>
<div class="line">  app_tile-&gt;size_range(1, 25, 25);</div>
<div class="line">  app_window-&gt;end();</div>
<div class="line">  app_window-&gt;resizable(app_tile);</div>
<div class="line">  app_tile-&gt;resizable(app_editor);</div>
<div class="line">  app_menu_bar-&gt;add(<span class="stringliteral">&quot;Window/Split&quot;</span>, FL_COMMAND+<span class="charliteral">&#39;i&#39;</span>, menu_split_callback, NULL, FL_MENU_TOGGLE);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now with all widgets in place, the callback's job is to show and resize, or hide and resize the split editor. We can implement that like here:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> menu_split_callback(Fl_Widget* w, <span class="keywordtype">void</span>*) {</div>
<div class="line">  Fl_Menu_Bar* menu = <span class="keyword">static_cast&lt;</span>Fl_Menu_Bar*<span class="keyword">&gt;</span>(w);</div>
<div class="line">  <span class="keyword">const</span> Fl_Menu_Item* splitview_item = menu-&gt;mvalue();</div>
<div class="line">  <span class="keywordflow">if</span> (splitview_item-&gt;value()) {</div>
<div class="line">    <span class="keywordtype">int</span> h_split = app_tile-&gt;h()/2;</div>
<div class="line">    app_editor-&gt;size(app_tile-&gt;w(), h_split);</div>
<div class="line">    app_split_editor-&gt;resize(app_tile-&gt;x(), app_tile-&gt;y() + h_split,</div>
<div class="line">                             app_tile-&gt;w(), app_tile-&gt;h() - h_split);</div>
<div class="line">    app_split_editor-&gt;show();</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    app_editor-&gt;size(app_tile-&gt;w(), app_tile-&gt;h());</div>
<div class="line">    app_split_editor-&gt;resize(app_tile-&gt;x(), app_tile-&gt;y()+app_tile-&gt;h(),</div>
<div class="line">                             app_tile-&gt;w(), 0);</div>
<div class="line">    app_split_editor-&gt;hide();</div>
<div class="line">  }</div>
<div class="line">  app_tile-&gt;resizable(app_editor);</div>
<div class="line">  app_tile-&gt;init_sizes();</div>
<div class="line">  app_tile-&gt;redraw();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="editor_syntax_highlighting"></a>
Chapter 10: Syntax Highlighting</h1>
<p>Chapter 10 adds a lot of code to implement "C" language syntax highlighting. Not all code is duplicated here in the documentation. Please check out <code>test/editor.cxx</code> for all the details.</p>
<p>The Fl_Text_Editor widget supports highlighting of text with different fonts, colors, and sizes. The implementation is based on the excellent <a href="https://sourceforge.net/projects/nedit/">NEdit</a> text editor core, from <a href="https://sourceforge.net/projects/nedit/">https://sourceforge.net/projects/nedit/</a>, which uses a parallel "style" buffer which tracks the font, color, and size of the text that is drawn.</p>
<p>Styles are defined using the Fl_Text_Display::Style_Table_Entry structure defined in <code>&lt;FL/Fl_Text_Display.H&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Style_Table_Entry {</div>
<div class="line">  Fl_Color color;</div>
<div class="line">  Fl_Font  font;</div>
<div class="line">  <span class="keywordtype">int</span>      size;</div>
<div class="line">  <span class="keywordtype">unsigned</span> attr;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>color</code> member sets the color for the text, the <code>font</code> member sets the FLTK font index to use, and the <code>size</code> member sets the pixel size of the text. The <code>attr</code> member is currently not used.</p>
<p>For our text editor we'll define 7 styles for plain code, comments, keywords, and preprocessor directives:</p>
<div class="fragment"><div class="line">Fl_Text_Display::Style_Table_Entry styletable[] = {     <span class="comment">// Style table</span></div>
<div class="line">  { FL_BLACK,      FL_COURIER,        FL_NORMAL_SIZE }, <span class="comment">// A - Plain</span></div>
<div class="line">  { FL_DARK_GREEN, FL_COURIER_ITALIC, FL_NORMAL_SIZE }, <span class="comment">// B - Line comments</span></div>
<div class="line">  { FL_DARK_GREEN, FL_COURIER_ITALIC, FL_NORMAL_SIZE }, <span class="comment">// C - Block comments</span></div>
<div class="line">  { FL_BLUE,       FL_COURIER,        FL_NORMAL_SIZE }, <span class="comment">// D - Strings</span></div>
<div class="line">  { FL_DARK_RED,   FL_COURIER,        FL_NORMAL_SIZE }, <span class="comment">// E - Directives</span></div>
<div class="line">  { FL_DARK_RED,   FL_COURIER_BOLD,   FL_NORMAL_SIZE }, <span class="comment">// F - Types</span></div>
<div class="line">  { FL_BLUE,       FL_COURIER_BOLD,   FL_NORMAL_SIZE }  <span class="comment">// G - Keywords</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>You'll notice that the comments show a letter next to each style - each style in the style buffer is referenced using a character starting with the letter 'A'.</p>
<p>You call the <code>highlight_data()</code> method to associate the style data and buffer with the text editor widget:</p>
<div class="fragment"><div class="line">Fl_Text_Buffer *app_style_buffer;</div>
<div class="line"> </div>
<div class="line">app_editor-&gt;highlight_data(app_style_buffer, styletable,</div>
<div class="line">                           <span class="keyword">sizeof</span>(styletable) / <span class="keyword">sizeof</span>(styletable[0]),</div>
<div class="line">                           <span class="charliteral">&#39;A&#39;</span>, style_unfinished_cb, 0);</div>
</div><!-- fragment --><p>Finally, you need to add a callback to the main text buffer so that changes to the text buffer are mirrored in the style buffer:</p>
<div class="fragment"><div class="line">app_text_buffer-&gt;add_modify_callback(style_update, app_editor);</div>
</div><!-- fragment --><p>The <code>style_update()</code> function, like the <code>change_cb()</code> function described earlier, is called whenever text is added or removed from the text buffer. It mirrors the changes in the style buffer and then updates the style data as necessary:</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &#39;style_update()&#39; - Update the style buffer...</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">style_update(<span class="keywordtype">int</span>        pos,          <span class="comment">// I - Position of update</span></div>
<div class="line">             <span class="keywordtype">int</span>        nInserted,    <span class="comment">// I - Number of inserted chars</span></div>
<div class="line">             <span class="keywordtype">int</span>        nDeleted,     <span class="comment">// I - Number of deleted chars</span></div>
<div class="line">             <span class="keywordtype">int</span>        nRestyled,    <span class="comment">// I - Number of restyled chars</span></div>
<div class="line">             <span class="keyword">const</span> <span class="keywordtype">char</span> *deletedText, <span class="comment">// I - Text that was deleted</span></div>
<div class="line">             <span class="keywordtype">void</span>       *cbArg) {     <span class="comment">// I - Callback data</span></div>
<div class="line">  <span class="keywordtype">int</span>  start,                         <span class="comment">// Start of text</span></div>
<div class="line">       end;                           <span class="comment">// End of text</span></div>
<div class="line">  <span class="keywordtype">char</span> last,                          <span class="comment">// Last style on line</span></div>
<div class="line">       *style,                        <span class="comment">// Style data</span></div>
<div class="line">       *text;                         <span class="comment">// Text data</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If this is just a selection change, just unselect the style buffer...</span></div>
<div class="line">  <span class="keywordflow">if</span> (nInserted == 0 &amp;&amp; nDeleted == 0) {</div>
<div class="line">    app_style_buffer-&gt;unselect();</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Track changes in the text buffer...</span></div>
<div class="line">  <span class="keywordflow">if</span> (nInserted &gt; 0) {</div>
<div class="line">    <span class="comment">// Insert characters into the style buffer...</span></div>
<div class="line">    style = <span class="keyword">new</span> <span class="keywordtype">char</span>[nInserted + 1];</div>
<div class="line">    memset(style, <span class="charliteral">&#39;A&#39;</span>, nInserted);</div>
<div class="line">    style[nInserted] = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    app_style_buffer-&gt;replace(pos, pos + nDeleted, style);</div>
<div class="line">    <span class="keyword">delete</span>[] style;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Just delete characters in the style buffer...</span></div>
<div class="line">    app_style_buffer-&gt;remove(pos, pos + nDeleted);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Select the area that was just updated to avoid unnecessary</span></div>
<div class="line">  <span class="comment">// callbacks...</span></div>
<div class="line">  app_style_buffer-&gt;select(pos, pos + nInserted - nDeleted);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Re-parse the changed region; we do this by parsing from the</span></div>
<div class="line">  <span class="comment">// beginning of the line of the changed region to the end of</span></div>
<div class="line">  <span class="comment">// the line of the changed region...  Then we check the last</span></div>
<div class="line">  <span class="comment">// style character and keep updating if we have a multi-line</span></div>
<div class="line">  <span class="comment">// comment character...</span></div>
<div class="line">  start = app_text_buffer-&gt;line_start(pos);</div>
<div class="line">  end   = app_text_buffer-&gt;line_end(pos + nInserted - nDeleted);</div>
<div class="line">  text  = app_text_buffer-&gt;text_range(start, end);</div>
<div class="line">  style = app_style_buffer-&gt;text_range(start, end);</div>
<div class="line">  last  = style[end - start - 1];</div>
<div class="line"> </div>
<div class="line">  style_parse(text, style, end - start);</div>
<div class="line"> </div>
<div class="line">  app_style_buffer-&gt;replace(start, end, style);</div>
<div class="line">  ((Fl_Text_Editor *)cbArg)-&gt;redisplay_range(start, end);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (last != style[end - start - 1]) {</div>
<div class="line">    <span class="comment">// The last character on the line changed styles, so reparse the</span></div>
<div class="line">    <span class="comment">// remainder of the buffer...</span></div>
<div class="line">    free(text);</div>
<div class="line">    free(style);</div>
<div class="line"> </div>
<div class="line">    end   = app_text_buffer-&gt;length();</div>
<div class="line">    text  = app_text_buffer-&gt;text_range(start, end);</div>
<div class="line">    style = app_style_buffer-&gt;text_range(start, end);</div>
<div class="line"> </div>
<div class="line">    style_parse(text, style, end - start);</div>
<div class="line"> </div>
<div class="line">    app_style_buffer-&gt;replace(start, end, style);</div>
<div class="line">    ((Fl_Text_Editor *)cbArg)-&gt;redisplay_range(start, end);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  free(text);</div>
<div class="line">  free(style);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>style_parse()</code> function scans a copy of the text in the buffer and generates the necessary style characters for display. It assumes that parsing begins at the start of a line:</p>
<div class="fragment"><div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// &#39;style_parse()&#39; - Parse text and produce style data.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span></div>
<div class="line">style_parse(<span class="keyword">const</span> <span class="keywordtype">char</span> *text,</div>
<div class="line">            <span class="keywordtype">char</span>       *style,</div>
<div class="line">            <span class="keywordtype">int</span>        length) {</div>
<div class="line">  <span class="keywordtype">char</span>       current;</div>
<div class="line">  <span class="keywordtype">int</span>        col;</div>
<div class="line">  <span class="keywordtype">int</span>        last;</div>
<div class="line">  <span class="keywordtype">char</span>       buf[255],</div>
<div class="line">             *bufptr;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *temp;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (current = *style, col = 0, last = 0; length &gt; 0; length --, text ++) {</div>
<div class="line">    <span class="keywordflow">if</span> (current == <span class="charliteral">&#39;A&#39;</span>) {</div>
<div class="line">      <span class="comment">// Check for directives, comments, strings, and keywords...</span></div>
<div class="line">      <span class="keywordflow">if</span> (col == 0 &amp;&amp; *text == <span class="charliteral">&#39;#&#39;</span>) {</div>
<div class="line">        <span class="comment">// Set style to directive</span></div>
<div class="line">        current = <span class="charliteral">&#39;E&#39;</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(text, <span class="stringliteral">&quot;//&quot;</span>, 2) == 0) {</div>
<div class="line">        current = <span class="charliteral">&#39;B&#39;</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(text, <span class="stringliteral">&quot;/*&quot;</span>, 2) == 0) {</div>
<div class="line">        current = <span class="charliteral">&#39;C&#39;</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strncmp(text, <span class="stringliteral">&quot;\\\&quot;&quot;</span>, 2) == 0) {</div>
<div class="line">        <span class="comment">// Quoted quote...</span></div>
<div class="line">        *style++ = current;</div>
<div class="line">        *style++ = current;</div>
<div class="line">        text ++;</div>
<div class="line">        length --;</div>
<div class="line">        col += 2;</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*text == <span class="charliteral">&#39;\&quot;&#39;</span>) {</div>
<div class="line">        current = <span class="charliteral">&#39;D&#39;</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!last &amp;&amp; islower(*text)) {</div>
<div class="line">        <span class="comment">// Might be a keyword...</span></div>
<div class="line">        <span class="keywordflow">for</span> (temp = text, bufptr = buf;</div>
<div class="line">             islower(*temp) &amp;&amp; bufptr &lt; (buf + <span class="keyword">sizeof</span>(buf) - 1);</div>
<div class="line">             *bufptr++ = *temp++);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!islower(*temp)) {</div>
<div class="line">          *bufptr = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line"> </div>
<div class="line">          bufptr = buf;</div>
<div class="line"> </div>
<div class="line">          <span class="keywordflow">if</span> (bsearch(&amp;bufptr, code_types,</div>
<div class="line">                      <span class="keyword">sizeof</span>(code_types) / <span class="keyword">sizeof</span>(code_types[0]),</div>
<div class="line">                      <span class="keyword">sizeof</span>(code_types[0]), compare_keywords)) {</div>
<div class="line">            <span class="keywordflow">while</span> (text &lt; temp) {</div>
<div class="line">              *style++ = <span class="charliteral">&#39;F&#39;</span>;</div>
<div class="line">              text ++;</div>
<div class="line">              length --;</div>
<div class="line">              col ++;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            text --;</div>
<div class="line">            length ++;</div>
<div class="line">            last = 1;</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bsearch(&amp;bufptr, code_keywords,</div>
<div class="line">                             <span class="keyword">sizeof</span>(code_keywords) / <span class="keyword">sizeof</span>(code_keywords[0]),</div>
<div class="line">                             <span class="keyword">sizeof</span>(code_keywords[0]), compare_keywords)) {</div>
<div class="line">            <span class="keywordflow">while</span> (text &lt; temp) {</div>
<div class="line">              *style++ = <span class="charliteral">&#39;G&#39;</span>;</div>
<div class="line">              text ++;</div>
<div class="line">              length --;</div>
<div class="line">              col ++;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            text --;</div>
<div class="line">            length ++;</div>
<div class="line">            last = 1;</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (current == <span class="charliteral">&#39;C&#39;</span> &amp;&amp; strncmp(text, <span class="stringliteral">&quot;*/&quot;</span>, 2) == 0) {</div>
<div class="line">      <span class="comment">// Close a C comment...</span></div>
<div class="line">      *style++ = current;</div>
<div class="line">      *style++ = current;</div>
<div class="line">      text ++;</div>
<div class="line">      length --;</div>
<div class="line">      current = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">      col += 2;</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (current == <span class="charliteral">&#39;D&#39;</span>) {</div>
<div class="line">      <span class="comment">// Continuing in string...</span></div>
<div class="line">      <span class="keywordflow">if</span> (strncmp(text, <span class="stringliteral">&quot;\\\&quot;&quot;</span>, 2) == 0) {</div>
<div class="line">        <span class="comment">// Quoted end quote...</span></div>
<div class="line">        *style++ = current;</div>
<div class="line">        *style++ = current;</div>
<div class="line">        text ++;</div>
<div class="line">        length --;</div>
<div class="line">        col += 2;</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*text == <span class="charliteral">&#39;\&quot;&#39;</span>) {</div>
<div class="line">        <span class="comment">// End quote...</span></div>
<div class="line">        *style++ = current;</div>
<div class="line">        col ++;</div>
<div class="line">        current = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Copy style info...</span></div>
<div class="line">    <span class="keywordflow">if</span> (current == <span class="charliteral">&#39;A&#39;</span> &amp;&amp; (*text == <span class="charliteral">&#39;{&#39;</span> || *text == <span class="charliteral">&#39;}&#39;</span>)) *style++ = <span class="charliteral">&#39;G&#39;</span>;</div>
<div class="line">    <span class="keywordflow">else</span> *style++ = current;</div>
<div class="line">    col ++;</div>
<div class="line"> </div>
<div class="line">    last = isalnum(*text) || *text == <span class="charliteral">&#39;.&#39;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (*text == <span class="charliteral">&#39;\n&#39;</span>) {</div>
<div class="line">      <span class="comment">// Reset column and possibly reset the style</span></div>
<div class="line">      col = 0;</div>
<div class="line">      <span class="keywordflow">if</span> (current == <span class="charliteral">&#39;B&#39;</span> || current == <span class="charliteral">&#39;E&#39;</span>) current = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> 
<hr>
<table summary="navigation bar" width="100%" border="0">
<tr>
  <td width="45%" align="LEFT">
    <a class="el" href="resize.html">
    [Prev]
    How Does Resizing Work?
    </a>
  </td>
  <td width="10%" align="CENTER">
    <a class="el" href="index.html">[Index]</a>
  </td>
  <td width="45%" align="RIGHT">
    <a class="el" href="drawing.html">
    Drawing Things in FLTK
    [Next]
    </a>
  </td>
</tr>
</table>
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>

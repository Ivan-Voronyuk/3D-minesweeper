<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>fltk: Drawing Things in FLTK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">fltk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">FLTK Programming Manual</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Drawing Things in FLTK</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This chapter covers the drawing functions that are provided with FLTK.</p>
<h1><a class="anchor" id="drawing_WhenCanYouDraw"></a>
When Can You Draw Things in FLTK?</h1>
<p>There are only certain places you can execute FLTK code that draws to the computer's display. Calling these functions at other places will result in undefined behavior!</p>
<ul>
<li>The most common place is inside the virtual Fl_Widget::draw() method. To write code here, you must subclass one of the existing Fl_Widget classes and implement your own version of draw().</li>
</ul>
<ul>
<li>You can also create custom <a class="el" href="common.html#common_boxtypes">boxtypes</a> and <a class="el" href="common.html#common_labeltype">labeltypes</a>. These involve writing small procedures that can be called by existing Fl_Widget::draw() methods. These "types" are identified by an 8-bit index that is stored in the widget's <code><a class="el" href="structbox.html">box()</a></code>, <code>labeltype()</code>, and possibly other properties.</li>
</ul>
<ul>
<li>You can call Fl_Window::make_current() to do incremental update of a widget. Use Fl_Widget::window() to find the window.</li>
</ul>
<p>In contrast, code that draws to other drawing surfaces than the display (i.e., instances of derived classes of the Fl_Surface_Device class, except Fl_Display_Device, such as Fl_Printer and Fl_Copy_Surface) can be executed at any time as follows: </p><ol>
<li>
Make your surface the new current drawing surface calling the Fl_Surface_Device::push_current(Fl_Surface_Device*) function. </li>
<li>
Make a series of calls to any of the drawing functions described below; these will operate on the new current drawing surface; </li>
<li>
Set the current drawing surface back to its previous state calling Fl_Surface_Device::pop_current(). </li>
</ol>
<h1><a class="anchor" id="drawing_DrawingUnit"></a>
What Units Do FLTK Functions Use?</h1>
<p>Before version 1.4 all graphical quantities used by FLTK were in pixel units: a window of width 500 units was 500 pixels wide, a line of length 10 units was 10 pixels long, lines of text written using a 14-point font were 14 pixels below each other. This organization is not sufficient to support GUI apps that can be drawn on screens of varying pixel density, especially on High-DPI screens, because widgets become very small and text becomes unreadable.</p>
<p>FLTK version 1.4 introduces a new feature, a screen-specific <b>scale factor</b> which is a float number with a typical value in the 1-2.5 range and is used as follows: any graphical element with an FLTK value of <em>v</em> units is drawn on the screen with <em>v</em> * <em>scale</em> units. Thus, a window with width 500 units is 500*scale pixels wide, a line of length 10 units is 10*scale pixels long, lines of text written using a 14-point font are 14*scale pixels below each other. Consider a system with two screens, one with regular DPI and one with a twice higher DPI. If the first screen's scale factor is set to 1 and that of the second screen to 2, the GUI of any FLTK app appears equally sized on the two screens.</p>
<p>FLTK uses several units to measure graphical elements: </p><ul>
<li>
All quantities used by the public FLTK API to measure graphical elements (e.g., window widths, line lengths, font sizes, clipping regions, image widths and heights) are in <b>FLTK units</b> except if it's explicitly documented another unit is used. FLTK units are both platform- and DPI-independent. An example of FLTK API using another unit is Fl_Gl_Window::pixel_w(). </li>
<li>
<p class="startli">Just before drawing to a screen, the library internally multiplies all quantities expressed in FLTK units by the current value of the scale factor for the screen in use and obtains quantities in <b>drawing units</b>. The current scale factor value, for an Fl_Window named <em>window</em>, is given by</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> nscreen = <a class="code hl_class" href="classwindow.html">window</a>-&gt;screen_num();  <span class="comment">// the screen where window is mapped</span></div>
<div class="line"><span class="keywordtype">float</span> s = Fl::screen_scale(nscreen); <span class="comment">// this screen&#39;s scale factor</span></div>
<div class="ttc" id="aclasswindow_html"><div class="ttname"><a href="classwindow.html">window</a></div><div class="ttdef"><b>Definition</b> animated.cxx:108</div></div>
</div><!-- fragment --><p class="endli">One drawing unit generally corresponds to one screen pixel ... </p>
</li>
<li>
<p class="startli">... but not on macOS and for retina displays, where one drawing unit corresponds to two pixels.</p>
<p class="endli"></p>
</li>
<li>
... and not with the Wayland platform, where one drawing unit may correspond to 1, 2, or 3 pixels according to the current value of the Wayland-defined, integer-valued scale factor. </li>
</ul>
<p>At application start time, FLTK attempts to detect the adequate scale factor value for each screen of the system. Here is how that's done under the <a class="el" href="osissues.html#osissues_x_scaling">X11</a>, <a class="el" href="osissues.html#osissues_windows_scaling">Windows</a>, and <a class="el" href="osissues.html#osissues_wayland_scaling">Wayland</a> platforms. If the resulting scale factor is not satisfactory, and also under the macOS platform, it's possible to set the <code>FLTK_SCALING_FACTOR</code> environmental variable to the desired numerical value (e.g., 1.75) and any FLTK app will start scaled with that value. Furthermore, it's possible to change the scale factor value of any screen at run time with ctrl/+/-/0/ keystrokes which enlarge, shrink, and reset, respectively, all FLTK windows on a screen and their content. Under macOS, the corresponding GUI scaling shortcuts are cmd/+/-/0/.</p>
<p>GUI rescaling involves also image drawing: the screen area covered by the drawn image contains a number of pixels that grows with the scale factor. When FLTK draws images, it maps the image data (the size of these data is given by Fl_Image::data_w() and Fl_Image::data_h()) to the screen area whose size (in FLTK units) is given by Fl_Image::w() and Fl_Image::h(). How exactly such mapping is performed depends on the image type, the platform and some hardware features. The most common case for Fl_RGB_Image's is that FLTK uses a scaled drawing system feature that directly maps image data to screen pixels. An important feature of FLTK for image drawing is the Fl_Image::scale() member function, new in FLTK version 1.4. This function controls the image drawing size (in FLTK units, given by Fl_Image::w() and Fl_Image::h()) independently from the size of the image data (given by Fl_Image::data_w() and Fl_Image::data_h()). An image with large enough data size can thus be drawn at the full resolution of the screen even when the screen area covered by the image grows following the GUI scale factor.</p>
<p>The Fl_Image_Surface class is intended to create an Fl_RGB_Image from a series of FLTK drawing operations. The Fl_Image_Surface constructor allows to control whether the size in pixels of the resulting image matches the FLTK units used when performing drawing operations, or matches the number of pixels corresponding to these FLTK units given the current value of the scale factor. The first result is obtained with <code>new Fl_Image_Surface(w, h)</code>, the second with <code>new Fl_Image_Surface(w, h, 1)</code>.</p>
<p>When drawing to Fl_Printer or Fl_PostScript_File_Device, the drawing unit is initially one point, that is, 1/72 of an inch. This unit is changed by calls to Fl_Paged_Device::scale().</p>
<h1><a class="anchor" id="drawing_DrawingFunctions"></a>
Drawing Functions</h1>
<p>To use the drawing functions you must first include the &lt;FL/fl_draw.H&gt; header file. FLTK provides the following types of drawing functions:</p>
<ul>
<li><a class="el" href="drawing.html#drawing_boxes">Boxes</a> </li>
<li><a class="el" href="drawing.html#drawing_clipping">Clipping</a> </li>
<li><a class="el" href="drawing.html#drawing_colors">Colors</a> </li>
<li><a class="el" href="drawing.html#drawing_contrast">Color Contrast</a> </li>
<li><a class="el" href="drawing.html#drawing_lines">Line Dashes and Thickness</a> </li>
<li><a class="el" href="drawing.html#drawing_fast">Drawing Fast Shapes</a> </li>
<li><a class="el" href="drawing.html#drawing_complex">Drawing Complex Shapes</a> </li>
<li><a class="el" href="drawing.html#drawing_text">Drawing Text</a> </li>
<li><a class="el" href="drawing.html#drawing_fonts">Fonts</a> </li>
<li><a class="el" href="drawing.html#drawing_character_encoding">Character Encoding</a> </li>
<li><a class="el" href="drawing.html#drawing_overlay">Drawing Overlays</a> </li>
<li><a class="el" href="drawing.html#drawing_images">Drawing Images</a> </li>
<li><a class="el" href="drawing.html#drawing_direct_image_drawing">Direct Image Drawing</a> </li>
<li><a class="el" href="drawing.html#drawing_direct_image_reading">Direct Image Reading</a> </li>
<li><a class="el" href="drawing.html#drawing_Fl_Image">Image Classes</a> </li>
<li><a class="el" href="drawing.html#drawing_offscreen">Offscreen Drawing</a></li>
</ul>
<h2><a class="anchor" id="drawing_boxes"></a>
Boxes</h2>
<p>FLTK provides three functions that can be used to draw boxes for buttons and other UI controls. Each function uses the supplied upper-lefthand corner and width and height to determine where to draw the box.</p>
<p>void <a class="el" href="fl__boxtype_8cxx.html#a8c19f7e3d1dfa15759f2f6e0c35a7541">fl_draw_box(Fl_Boxtype b, int x, int y, int w, int h, Fl_Color c)</a></p>
<dl class="section user"><dt></dt><dd>The <code>fl_draw_box</code>() function draws a standard boxtype <code>b</code> in the specified color <code>c</code>.</dd></dl>
<p><a class="anchor" id="drawing_fl_frame"></a>void <a class="el" href="fl__boxtype_8cxx.html#aeb7d9862b7d98015acad84386f6bdd45">fl_frame(const char *s, int x, int y, int w, int h)</a> <br  />
 void <a class="el" href="fl__boxtype_8cxx.html#a5f8de0bccbd6b3e7dbe6542d1b092b69">fl_frame2(const char *s, int x, int y, int w, int h)</a></p>
<dl class="section user"><dt></dt><dd>The <code>fl_frame</code>() and <code>fl_frame2</code>() functions draw a series of line segments around the given box. The string <code>s</code> must contain groups of 4 letters which specify one of 24 standard grayscale values, where 'A' is black and 'X' is white. The results of calling these functions with a string that is not a multiple of 4 characters in length are undefined.</dd></dl>
<dl class="section user"><dt></dt><dd>The only difference between <code>fl_frame</code>() and <code>fl_frame2</code>() is the order of the line segments:<ul>
<li>For <code>fl_frame</code>() the order of each set of 4 characters is: top, left, bottom, right.</li>
<li>For <code>fl_frame2</code>() the order of each set of 4 characters is: bottom, right, top, left.</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Note that <a class="el" href="common.html#common_fl_frame">fl_frame(Fl_Boxtype b)</a> is described in the <a class="el" href="common.html#common_boxtypes">Box Types</a> section.</dd></dl>
<h2><a class="anchor" id="drawing_clipping"></a>
Clipping</h2>
<p>You can limit all your drawing to a rectangular region by calling <code>fl_push_clip</code>(), and put the drawings back by using <code>fl_pop_clip</code>(). This rectangle is measured in <a class="el" href="drawing.html#drawing_DrawingUnit">FLTK units</a> and is unaffected by the current transformation matrix.</p>
<p>In addition, the system may provide clipping when updating windows which may be more complex than a simple rectangle.</p>
<p>void fl_push_clip(int x, int y, int w, int h) <br  />
 void fl_clip(int x, int y, int w, int h)</p>
<dl class="section user"><dt></dt><dd>Intersect the current clip region with a rectangle and push this new region onto the stack.</dd></dl>
<dl class="section user"><dt></dt><dd>The <code>fl_clip</code>() version is deprecated and will be removed from future releases.</dd></dl>
<p>void fl_push_no_clip()</p>
<dl class="section user"><dt></dt><dd>Pushes an empty clip region on the stack so nothing will be clipped.</dd></dl>
<p>void fl_pop_clip()</p>
<dl class="section user"><dt></dt><dd>Restore the previous clip region.</dd></dl>
<dl class="section user"><dt></dt><dd><b>Note:</b> You must call <code>fl_pop_clip</code>() once for every time you call <code>fl_push_clip</code>(). If you return to FLTK with the clip stack not empty unpredictable results occur.</dd></dl>
<p>int fl_not_clipped(int x, int y, int w, int h)</p>
<dl class="section user"><dt></dt><dd>Returns non-zero if any of the rectangle intersects the current clip region. If this returns 0 you don't have to draw the object.</dd></dl>
<dl class="section user"><dt></dt><dd><b>Note:</b> Under X this returns 2 if the rectangle is partially clipped, and 1 if it is entirely inside the clip region.</dd></dl>
<p>int fl_clip_box(int x, int y, int w, int h, int &amp;X, int &amp;Y, int &amp;W, int &amp;H)</p>
<dl class="section user"><dt></dt><dd>Intersect the rectangle <code>x,y,w,h</code> with the current clip region and returns the bounding box of the result in <code>X,Y,W,H</code>. Returns non-zero if the resulting rectangle is different than the original. This can be used to limit the necessary drawing to a rectangle. <code>W</code> and <code>H</code> are set to zero if the rectangle is completely outside the region.</dd></dl>
<p>void fl_clip_region(Fl_Region r) <br  />
 Fl_Region fl_clip_region()</p>
<dl class="section user"><dt></dt><dd>Replace the top of the clip stack with a clipping region of any shape. Fl_Region is an operating system specific type. The second form returns the current clipping region.</dd></dl>
<h2><a class="anchor" id="drawing_colors"></a>
Colors</h2>
<p>FLTK manages colors as 32-bit unsigned integers, encoded as RGBI. When the "RGB" bytes are non-zero, the value is treated as RGB. If these bytes are zero, the "I" byte will be used as an index into the colormap. Colors with both "RGB" set and an "I" &gt;0 are reserved for special use.</p>
<p>Values from 0 to 255, i.e. the "I" index value, represent colors from the FLTK standard colormap and are allocated as needed on screens without TrueColor support. The <b>Fl_Color</b> enumeration type defines the standard colors and color cube for the first 256 colors. All of these are named with symbols in <a class="el" href="enumerations.html">&lt;FL/Enumerations.H&gt;</a>. Example:</p>
<div class="image">
<img src="fltk-colormap.png" alt=""/>
<div class="caption">
FLTK default colormap (Fl_Color 0x00 - 0xff)</div></div>
 <p>Color values greater than 255 are treated as 24-bit RGB values. These are mapped to the closest color supported by the screen, either from one of the 256 colors in the FLTK colormap or a direct RGB value on TrueColor screens.</p>
<p>Fl_Color fl_rgb_color(uchar r, uchar g, uchar b) <br  />
 Fl_Color fl_rgb_color(uchar grayscale)</p>
<dl class="section user"><dt></dt><dd>Generate Fl_Color out of specified 8-bit RGB values or one 8-bit grayscale value.</dd></dl>
<p>void fl_color(Fl_Color c) <br  />
 void fl_color(int c)</p>
<dl class="section user"><dt></dt><dd>Sets the color for all subsequent drawing operations. Please use the first form: the second form is only provided for back compatibility.</dd></dl>
<dl class="section user"><dt></dt><dd>For colormapped displays, a color cell will be allocated out of <code>fl_colormap</code> the first time you use a color. If the colormap fills up then a least-squares algorithm is used to find the closest color.</dd></dl>
<p>Fl_Color fl_color()</p>
<dl class="section user"><dt></dt><dd>Returns the last color that was set using <code>fl_color</code>(). This can be used for state save/restore.</dd></dl>
<p>void fl_color(uchar r, uchar g, uchar b)</p>
<dl class="section user"><dt></dt><dd>Set the color for all subsequent drawing operations. The closest possible match to the RGB color is used. The RGB color is used directly on TrueColor displays. For colormap visuals the nearest index in the gray ramp or color cube is used.</dd></dl>
<p>unsigned Fl::get_color(Fl_Color i) <br  />
 void Fl::get_color(Fl_Color i, uchar &amp;red, uchar &amp;green, uchar &amp;blue)</p>
<dl class="section user"><dt></dt><dd>Generate RGB values from a colormap index value <code>i</code>. The first returns the RGB as a 32-bit unsigned integer, and the second decomposes the RGB into three 8-bit values.</dd></dl>
<p>Fl::get_system_colors() <br  />
 Fl::foreground() <br  />
 Fl::background() <br  />
 Fl::background2()</p>
<dl class="section user"><dt></dt><dd>The first gets color values from the user preferences or the system, and the other routines are used to apply those values.</dd></dl>
<p>Fl::own_colormap() <br  />
 Fl::free_color(Fl_Color i, int overlay) <br  />
 Fl::set_color(Fl_Color i, unsigned c)</p>
<dl class="section user"><dt></dt><dd><code>Fl::own_colormap()</code> is used to install a local colormap [X11 only]. </dd></dl>
<dl class="section user"><dt></dt><dd><code>Fl::free_color()</code> and <code>Fl::set_color()</code> are used to remove and replace entries from the colormap.</dd></dl>
<p>There are two predefined graphical interfaces for choosing colors. The function fl_show_colormap() shows a table of colors and returns an Fl_Color index value. The Fl_Color_Chooser widget provides a standard RGB color chooser.</p>
<p>As the Fl_Color encoding maps to a 32-bit unsigned integer representing RGBI, it is also possible to specify a color using a hex constant as a color map index: </p><pre>
// COLOR MAP INDEX
color(0x000000II)
        ------ |
           |   |
           |   Color map index (8 bits)
           Must be zero
</pre> <div class="fragment"><div class="line">button-&gt;color(0x000000ff);                  <span class="comment">// colormap index #255 (FL_WHITE)</span></div>
</div><!-- fragment --><p>or specify a color using a hex constant for the RGB components: </p><pre>
// RGB COLOR ASSIGNMENTS
color(0xRRGGBB00)
         | | | |
         | | | Must be zero
         | | Blue (8 bits)
         | Green (8 bits)
         Red (8 bits)
</pre> <div class="fragment"><div class="line">button-&gt;color(0xff000000);                  <span class="comment">// RGB: red</span></div>
<div class="line">button-&gt;color(0x00ff0000);                  <span class="comment">// RGB: green</span></div>
<div class="line">button-&gt;color(0x0000ff00);                  <span class="comment">// RGB: blue</span></div>
<div class="line">button-&gt;color(0xffffff00);                  <span class="comment">// RGB: white</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If TrueColor is not available, any RGB colors will be set to the nearest entry in the colormap.</dd></dl>
<h2><a class="anchor" id="drawing_contrast"></a>
Color Contrast</h2>
<p>Although these are not real "drawing" functions, creating readable contrast is essential in a good GUI design. FLTK tries to help with this by providing <a class="el" href="group__fl__attributes.html#ga1a26c5f2d8f46430813d3d39809eb678">fl_contrast()</a> and related functions.</p>
<p>The basic function is Fl_Color <a class="el" href="group__fl__attributes.html#ga1a26c5f2d8f46430813d3d39809eb678">fl_contrast(Fl_Color fg, Fl_Color bg, int context, int size)</a>;</p>
<p>The parameters <code>context</code> and <code>size</code> are optional and reserved for future use (since FLTK 1.4.0).</p>
<p>The return value can be used to substitute the foreground color <code>fg</code> used for drawing (usually the "text" or "label" color) on a particular background color <code>bg</code> with either black (FL_BLACK) or white (FL_WHITE). This is useful if the background color is not known or can be changed by the user or a system "theme".</p>
<p>FLTK calculates the contrast between <code>fg</code> and <code>bg</code> and returns the same color (<code>fg</code>) if the contrast is considered sufficient or one of FL_BLACK or FL_WHITE if the contrast of the given foreground color would be insufficient. Then either FL_BLACK or FL_WHITE is chosen, whichever has the higher contrast with the background color.</p>
<p>Example, may be used in a widget's draw() method:</p>
<div class="fragment"><div class="line">Fl_Color bg = color();          <span class="comment">// background color of the widget</span></div>
<div class="line">Fl_Color fg = FL_BLUE;          <span class="comment">// the chosen foreground (drawing) color</span></div>
<div class="line">fl_color(<a class="code hl_function" href="group__fl__attributes.html#ga1a26c5f2d8f46430813d3d39809eb678">fl_contrast</a>(fg, bg));  <span class="comment">// set the drawing color</span></div>
<div class="line">fl_rect(..);                    <span class="comment">// draw a rectangle with sufficient contrast</span></div>
<div class="ttc" id="agroup__fl__attributes_html_ga1a26c5f2d8f46430813d3d39809eb678"><div class="ttname"><a href="group__fl__attributes.html#ga1a26c5f2d8f46430813d3d39809eb678">fl_contrast</a></div><div class="ttdeci">Fl_Color fl_contrast(Fl_Color fg, Fl_Color bg, int context, int size)</div><div class="ttdef"><b>Definition</b> fl_contrast.cxx:506</div></div>
</div><!-- fragment --><p>FLTK 1.4.0 introduced a new contrast algorithm which is superior to the one used up to FLTK 1.3.x. You can use</p>
<p>fl_contrast_mode(FL_CONTRAST_LEGACY);</p>
<p>early in your program to select the old behavior if you really need strict backwards compatibility. This is discouraged because the new algorithm is much better with regard to human contrast perception. The default mode since FLTK 1.4.0 is</p>
<p>fl_contrast_mode(FL_CONTRAST_CIELAB);</p>
<p>For more info please see the linked documentation of these functions.</p>
<p>Additionally the old and new contrast calculations can be fine tuned with the new function (since 1.4.0)</p>
<p><a class="el" href="group__fl__attributes.html#ga5cb53fa508f3e45a0ccab46151461a2c">fl_contrast_level(int level)</a>;</p>
<p>This is not recommended but can be useful for some border cases. Please refer to the documentation of <a class="el" href="group__fl__attributes.html#ga2f3ff53f7107c7017f7a792bde3796e6">fl_contrast_level()</a>.</p>
<p>Finally, developers can define their own contrast calculation function with</p>
<p>void <a class="el" href="group__fl__attributes.html#ga6d287a61ac3562108bc71e9c1e740246">fl_contrast_function(Fl_Contrast_Function *f)</a>;</p>
<p>Please see the documentation for details.</p>
<h2><a class="anchor" id="drawing_lines"></a>
Line Dashes and Thickness</h2>
<p>FLTK supports drawing of lines with different styles and widths.</p>
<p>void fl_line_style(int style, int width, char* dashes)</p>
<div class="image">
<img src="fl_line_style.png" alt=""/>
<div class="caption">
fl_line_style() styles</div></div>
 <dl class="section user"><dt></dt><dd>Set how to draw lines (the "pen"). If you change this it is your responsibility to set it back to the default with <code>fl_line_style(0)</code>.</dd></dl>
<dl class="section user"><dt></dt><dd><code>style</code> is a bitmask which is a bitwise-OR of the following values. If you don't specify a dash type you will get a solid line. If you don't specify a cap or join type you will get a system-defined default of whatever value is fastest.</dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><code>FL_SOLID</code> solid line </li>
<li><code>FL_DASH</code> 75% dashed line </li>
<li><code>FL_DOT</code> 50% pixel dotted </li>
<li><code>FL_DASHDOT</code> dash / dot pattern </li>
<li><code>FL_DASHDOTDOT</code> dash / two dot pattern </li>
<li><code>FL_CAP_FLAT</code> end is flat </li>
<li><code>FL_CAP_ROUND</code> end is round </li>
<li><code>FL_CAP_SQUARE</code> extends past end point 1/2 line width </li>
<li><code>FL_JOIN_MITER</code> line join extends to a point </li>
<li><code>FL_JOIN_ROUND</code> line join is rounded </li>
<li><code>FL_JOIN_BEVEL</code> line join is flat (tidied)</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd><code>width</code> is the number of <a class="el" href="drawing.html#drawing_DrawingUnit">FLTK units</a> thick to draw the lines. Zero results in the system-defined default, which on both X and Windows is somewhat different and nicer than 1.</dd></dl>
<dl class="section user"><dt></dt><dd><code>dashes</code> is a pointer to an array of dash lengths, measured in <a class="el" href="drawing.html#drawing_DrawingUnit">FLTK units</a>. The first location is how long to draw a solid portion, the next is how long to draw the gap, then the solid, etc. It is terminated with a zero-length entry. A <code>NULL</code> pointer or a zero-length array results in a solid line. Odd array sizes are not supported and result in undefined behavior.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Full functionality is not available under Windows 95, 98, and Me due to the reduced drawing functionality these operating systems provide.</li>
<li>Because of how line styles are implemented on Windows systems, you <em>must</em> set the line style <em>after</em> setting the drawing color. If you set the color after the line style you will lose the line style settings!</li>
<li>The dashes array does not work under Windows 95, 98, or Me, since those operating systems do not support complex line styles.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="drawing_fast"></a>
Drawing Fast Shapes</h2>
<p>These functions are used to draw almost all the FLTK widgets. They draw on exact pixel boundaries and are as fast as possible. Their behavior is duplicated exactly on all platforms FLTK is ported. It is undefined whether these are affected by the <a class="el" href="drawing.html#drawing_complex">transformation matrix</a>, so you should only call these while the matrix is set to the identity matrix (the default).</p>
<p>void fl_point(int x, int y)</p>
<dl class="section user"><dt></dt><dd>Draw a single pixel at the given coordinates.</dd></dl>
<p>void fl_rectf(int x, int y, int w, int h) <br  />
 void fl_rectf(int x, int y, int w, int h, Fl_Color c)</p>
<dl class="section user"><dt></dt><dd>Color a rectangle that exactly fills the given bounding box.</dd></dl>
<p>void fl_rectf(int x, int y, int w, int h, uchar r, uchar g, uchar b)</p>
<dl class="section user"><dt></dt><dd>Color a rectangle with "exactly" the passed <code>r,g,b</code> color. On screens with less than 24 bits of color this is done by drawing a solid-colored block using <a class="el" href="drawing.html#drawing_fl_draw_image">fl_draw_image()</a> so that the correct color shade is produced.</dd></dl>
<p>void fl_rect(int x, int y, int w, int h) <br  />
 void fl_rect(int x, int y, int w, int h, Fl_Color c)</p>
<dl class="section user"><dt></dt><dd>Draw a 1-pixel border <em>inside</em> this bounding box.</dd></dl>
<p>void fl_rounded_rect(int x, int y, int w, int h, int radius) void fl_rounded_rectf(int x, int y, int w, int h, int radius)</p>
<dl class="section user"><dt></dt><dd>Draw an outlined or filled rectangle with rounded corners.</dd></dl>
<p>void fl_line(int x, int y, int x1, int y1) <br  />
 void fl_line(int x, int y, int x1, int y1, int x2, int y2)</p>
<dl class="section user"><dt></dt><dd>Draw one or two lines between the given points.</dd></dl>
<p>void fl_loop(int x, int y, int x1, int y1, int x2, int y2) <br  />
 void fl_loop(int x, int y, int x1, int y1, int x2, int y2, int x3, int y3)</p>
<dl class="section user"><dt></dt><dd>Outline a 3 or 4-sided polygon with lines.</dd></dl>
<p>void fl_polygon(int x, int y, int x1, int y1, int x2, int y2) <br  />
 void fl_polygon(int x, int y, int x1, int y1, int x2, int y2, int x3, int y3)</p>
<dl class="section user"><dt></dt><dd>Fill a 3 or 4-sided polygon. The polygon must be convex.</dd></dl>
<p>void fl_xyline(int x, int y, int x1) <br  />
 void fl_xyline(int x, int y, int x1, int y2) <br  />
 void fl_xyline(int x, int y, int x1, int y2, int x3)</p>
<dl class="section user"><dt></dt><dd>Draw horizontal and vertical lines. A horizontal line is drawn first, then a vertical, then a horizontal.</dd></dl>
<p>void fl_yxline(int x, int y, int y1) <br  />
 void fl_yxline(int x, int y, int y1, int x2) <br  />
 void fl_yxline(int x, int y, int y1, int x2, int y3)</p>
<dl class="section user"><dt></dt><dd>Draw vertical and horizontal lines. A vertical line is drawn first, then a horizontal, then a vertical.</dd></dl>
<p>void fl_arc(int x, int y, int w, int h, double a1, double a2) <br  />
 void fl_pie(int x, int y, int w, int h, double a1, double a2)</p>
<dl class="section user"><dt></dt><dd>Draw ellipse sections using integer coordinates. These functions match the rather limited circle drawing code provided by X and Windows. The advantage over using <a class="el" href="drawing.html#drawing_fl_arc">fl_arc()</a> with floating point coordinates is that they are faster because they often use the hardware, and they draw much nicer small circles, since the small sizes are often hard-coded bitmaps.</dd></dl>
<dl class="section user"><dt></dt><dd>If a complete circle is drawn it will fit inside the passed bounding box. The two angles are measured in degrees counter-clockwise from 3'oclock and are the starting and ending angle of the arc, <code>a2</code> must be greater or equal to <code>a1</code>.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="image">
<img src="fl_pie_arc_diagram.png" alt=""/>
<div class="caption">
fl_pie() and fl_arc()</div></div>
 </dd></dl>
<dl class="section user"><dt></dt><dd><code>fl_arc</code>() draws a series of lines to approximate the arc. Notice that the integer version of <code>fl_arc</code>() has a different number of arguments to the other <a class="el" href="drawing.html#drawing_fl_arc">fl_arc()</a> function described later in this chapter.</dd></dl>
<dl class="section user"><dt></dt><dd><code>fl_pie</code>() draws a filled-in pie slice. This slice may extend outside the line drawn by <code>fl_arc</code>(); to avoid this use <code>w-1</code> and <code>h-1</code>.</dd></dl>
<p>void fl_scroll(int X, int Y, int W, int H, int dx, int dy, void (<em>draw_area)(void</em>, int,int,int,int), void* data) </p><dl class="section user"><dt></dt><dd>Scroll a rectangle and draw the newly exposed portions. The contents of the rectangular area is first shifted by <code>dx</code> and <code>dy</code> <a class="el" href="drawing.html#drawing_DrawingUnit">FLTK units</a>. The callback is then called for every newly exposed rectangular area,</dd></dl>
<h2><a class="anchor" id="drawing_complex"></a>
Drawing Complex Shapes</h2>
<p>The complex drawing functions let you draw arbitrary shapes with 2-D linear transformations. The functionality matches that found in the Adobe&reg; PostScript&trade; language. The exact pixels that are filled are less defined than for the fast drawing functions so that FLTK can take advantage of drawing hardware. On both X and Windows the transformed vertices are rounded to integers before drawing the line segments: this severely limits the accuracy of these functions for complex graphics, so use OpenGL when greater accuracy and/or performance is required.</p>
<p>void fl_load_matrix(double a,double b,double c,double d,double x,double y) void fl_load_identity()</p>
<dl class="section user"><dt></dt><dd>Set the current transformation.</dd></dl>
<p>void fl_push_matrix() <br  />
 void fl_pop_matrix()</p>
<dl class="section user"><dt></dt><dd>Save and restore the current transformation. The maximum depth of the stack is 32 entries.</dd></dl>
<p>void fl_scale(double x,double y) <br  />
 void fl_scale(double x) <br  />
 void fl_translate(double x,double y) <br  />
 void fl_rotate(double d) <br  />
 void fl_mult_matrix(double a,double b,double c,double d,double x,double y)</p>
<dl class="section user"><dt></dt><dd>Concatenate another transformation onto the current one. The rotation angle is in degrees (not radians) and is counter-clockwise.</dd></dl>
<p>double fl_transform_x(double x, double y) <br  />
 double fl_transform_y(double x, double y) <br  />
 double fl_transform_dx(double x, double y) <br  />
 double fl_transform_dy(double x, double y) <br  />
 void fl_transformed_vertex(double xf, double yf)</p>
<dl class="section user"><dt></dt><dd>Transform a coordinate or a distance using the current transformation matrix. After transforming a coordinate pair, it can be added to the vertex list without any further translations using <code>fl_transformed_vertex</code>().</dd></dl>
<p>void fl_begin_points() <br  />
 void fl_end_points()</p>
<dl class="section user"><dt></dt><dd>Start and end drawing a list of points. Points are added to the list with <code>fl_vertex</code>().</dd></dl>
<p>void fl_begin_line() <br  />
 void fl_end_line()</p>
<dl class="section user"><dt></dt><dd>Start and end drawing lines.</dd></dl>
<p>void fl_begin_loop() <br  />
 void fl_end_loop()</p>
<dl class="section user"><dt></dt><dd>Start and end drawing a closed sequence of lines.</dd></dl>
<p>void fl_begin_polygon() <br  />
 void fl_end_polygon()</p>
<dl class="section user"><dt></dt><dd>Start and end drawing a convex filled polygon.</dd></dl>
<p>void fl_begin_complex_polygon() <br  />
 void fl_gap() <br  />
 void fl_end_complex_polygon()</p>
<dl class="section user"><dt></dt><dd>Start and end drawing a complex filled polygon. This polygon may be concave, may have holes in it, or may be several disconnected pieces. Call <code>fl_gap</code>() to separate loops of the path. It is unnecessary but harmless to call <code>fl_gap</code>() before the first vertex, after the last one, or several times in a row.</dd></dl>
<dl class="section user"><dt></dt><dd><code>fl_gap</code>() should only be called between <code>fl_begin_complex_polygon</code>() and <code>fl_end_complex_polygon</code>(). To outline the polygon, use <code>fl_begin_loop</code>() and replace each <code>fl_gap</code>() with a <code>fl_end_loop</code>();fl_begin_loop() pair.</dd></dl>
<dl class="section user"><dt></dt><dd><b>Note:</b> For portability, you should only draw polygons that appear the same whether "even/odd" or "non-zero" winding rules are used to fill them. Holes should be drawn in the opposite direction of the outside loop.</dd></dl>
<p>void fl_vertex(double x,double y)</p>
<dl class="section user"><dt></dt><dd>Add a single vertex to the current path.</dd></dl>
<p>void fl_curve(double X0, double Y0, double X1, double Y1, double X2, double Y2, double X3, double Y3)</p>
<dl class="section user"><dt></dt><dd>Add a series of points on a BÃ©zier curve to the path. The curve ends (and two of the points are) at <code>X0,Y0</code> and <code>X3,Y3</code>.</dd></dl>
<p><a class="anchor" id="drawing_fl_arc"></a>void fl_arc(double x, double y, double r, double start, double end)</p>
<dl class="section user"><dt></dt><dd>Add a series of points to the current path on the arc of a circle; you can get elliptical paths by using scale and rotate before calling <code>fl_arc</code>(). The center of the circle is given by <code>x</code> and <code>y</code>, and <code>r</code> is its radius. <code>fl_arc</code>() takes <code>start</code> and <code>end</code> angles that are measured in degrees counter-clockwise from 3 o'clock. If <code>end</code> is less than <code>start</code> then it draws the arc in a clockwise direction.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="image">
<img src="fl_arc_xyr_diagram.png" alt=""/>
<div class="caption">
fl_arc(x,y,r,a1,a2)</div></div>
 </dd></dl>
<p>void fl_circle(double x, double y, double r)</p>
<dl class="section user"><dt></dt><dd><code>fl_circle(x,y,r)</code> is equivalent to <code>fl_arc(x,y,r,0,360)</code> but may be faster. It must be the <em>only</em> thing in the path: if you want a circle as part of a complex polygon you must use <code>fl_arc</code>().</dd></dl>
<dl class="section user"><dt></dt><dd><b>Note:</b> <code>fl_circle</code>() draws incorrectly if the transformation is both rotated and non-square scaled.</dd></dl>
<h2><a class="anchor" id="drawing_text"></a>
Drawing Text</h2>
<p>All text is drawn in the <a class="el" href="drawing.html#drawing_fl_font">current font</a>. It is undefined whether this location or the characters are modified by the current transformation.</p>
<p>void fl_draw(const char *, int x, int y) <br  />
 void fl_draw(const char *, int n, int x, int y)</p>
<dl class="section user"><dt></dt><dd>Draw a nul-terminated string or an array of <code>n</code> bytes starting at the given location. In both cases, the text must be UTF-8 encoded. Text is aligned to the left and to the baseline of the font. To align to the bottom, subtract <code>fl_descent</code>() from <code>y</code>. To align to the top, subtract <code>fl_descent</code>() and add <code>fl_height</code>(). This version of <code>fl_draw</code>() provides direct access to the text drawing function of the underlying OS. It does not apply any special handling to control characters.</dd></dl>
<p>void fl_rtl_draw(const char *str, int n, int x, int y)</p>
<dl class="section user"><dt></dt><dd>Draw a UTF-8 string of length n bytes right to left starting at the given x, y location.</dd></dl>
<p>void fl_draw(const char* str, int x, int y, int w, int h, Fl_Align align, Fl_Image* img, int draw_symbols, int spacing)</p>
<dl class="section user"><dt></dt><dd>Fancy string drawing function which is used to draw all the labels. The string is formatted and aligned inside the passed box. Handles '\t' and '\n', expands all other control characters to ^X, and aligns inside or against the edges of the box described by <code>x</code>, <code>y</code>, <code>w</code> and <code>h</code>. See Fl_Widget::align() for values for <code>align</code>. The value <code>FL_ALIGN_INSIDE</code> is ignored, as this function always prints inside the box. Parameter <code>spacing</code> controls the space between text and image.</dd></dl>
<dl class="section user"><dt></dt><dd>If <code>img</code> is provided and is not <code>NULL</code>, the image is drawn above or below the text as specified by the <code>align</code> value.</dd></dl>
<dl class="section user"><dt></dt><dd>The <code>draw_symbols</code> argument specifies whether or not to look for symbol names starting with the "@" character.</dd></dl>
<p>void fl_measure(const char *str, int&amp; w, int&amp; h, int draw_symbols)</p>
<dl class="section user"><dt></dt><dd>Measure how wide and tall the string will be when printed by the <code>fl_draw(...align)</code> function. This includes leading/trailing white space in the string, kerning, etc. </dd></dl>
<dl class="section user"><dt></dt><dd>If the incoming <code>w</code> is non-zero it will wrap to that width. </dd></dl>
<dl class="section user"><dt></dt><dd>This will probably give unexpected values unless you have called <a class="el" href="drawing.html#drawing_fl_font">fl_font()</a> explicitly in your own code. Refer to the full documentation for fl_measure() for details on usage and how to avoid common pitfalls.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fl_text_extents() &ndash; measure the 'inked' area of a string </dd>
<dd>
fl_width() &ndash; measure the width of a string or single character </dd>
<dd>
fl_height() &ndash; measure the height of the <a class="el" href="drawing.html#drawing_fl_font">current font</a> </dd>
<dd>
fl_descent() &ndash; the height of the descender for the <a class="el" href="drawing.html#drawing_fl_font">current font</a></dd></dl>
<p>int fl_height()</p>
<dl class="section user"><dt></dt><dd>Recommended minimum line spacing for the <a class="el" href="drawing.html#drawing_fl_font">current font</a>. You can also just use the value of <code>size</code> passed to <a class="el" href="drawing.html#drawing_fl_font">fl_font()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fl_text_extents(), fl_measure(), fl_width(), fl_descent()</dd></dl>
<p>int fl_descent()</p>
<dl class="section user"><dt></dt><dd>Recommended distance above the bottom of a <code>fl_height</code>() tall box to draw the text at so it looks centered vertically in that box.</dd></dl>
<p>double fl_width(const char* txt) <br  />
 double fl_width(const char* txt, int n) <br  />
 double fl_width(unsigned int unicode_char)</p>
<dl class="section user"><dt></dt><dd>Return the width of a nul-terminated string, a sequence of <code>n</code> characters, or a single character in the <a class="el" href="drawing.html#drawing_fl_font">current font</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fl_measure(), fl_text_extents(), fl_height(), fl_descent()</dd></dl>
<p>void fl_text_extents(const char* txt, int&amp; dx, int&amp; dy, int&amp; w, int&amp; h)</p>
<dl class="section user"><dt></dt><dd>Determines the minimum dimensions of a nul-terminated string, ie. the 'inked area'. </dd></dl>
<dl class="section user"><dt></dt><dd>Given a string "txt" drawn using fl_draw(txt, x, y) you would determine its extents in <a class="el" href="drawing.html#drawing_DrawingUnit">FLTK units</a> on the display using fl_text_extents(txt, dx, dy, wo, ho) such that a bounding box that exactly fits around the inked area of the text could be drawn with fl_rect(x+dx, y+dy, wo, ho). </dd></dl>
<dl class="section user"><dt></dt><dd>Refer to the full documentation for fl_text_extents() for details on usage.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>fl_measure(), fl_width(), fl_height(), fl_descent()</dd></dl>
<p>const char* fl_shortcut_label(int shortcut)</p>
<dl class="section user"><dt></dt><dd>Unparse a shortcut value as used by Fl_Button or Fl_Menu_Item into a human-readable string like "Alt+N". This only works if the shortcut is a character key or a numbered function key. If the shortcut is zero an empty string is returned. The return value points at a static buffer that is overwritten with each call.</dd></dl>
<h2><a class="anchor" id="drawing_fonts"></a>
Fonts</h2>
<p>FLTK supports a set of standard fonts based on the Times, Helvetica/Arial, Courier, and Symbol typefaces, as well as custom fonts that your application may load. Each font is accessed by an index into a font table.</p>
<p>Initially only the first 16 faces are filled in. There are symbolic names for them: FL_HELVETICA, FL_TIMES, FL_COURIER, and modifier values FL_BOLD and FL_ITALIC which can be added to these, and FL_SYMBOL and FL_ZAPF_DINGBATS. Faces greater than 255 cannot be used in Fl_Widget labels, since Fl_Widget stores the index as a byte.</p>
<p>One important thing to note about 'current font' is that there are so many paths through the GUI event handling code as widgets are partially or completely hidden, exposed and then re-drawn and therefore you can not guarantee that 'current font' contains the same value that you set on the other side of the event loop. Your value may have been superseded when a widget was redrawn. You are strongly advised to set the font explicitly before you draw any text or query the width and height of text strings, etc.</p>
<p><a class="anchor" id="drawing_fl_font"></a>void fl_font(int face, int size)</p>
<dl class="section user"><dt></dt><dd>Set the current font, which is then used by the routines described above. You may call this outside a draw context if necessary to call fl_width(), but on X this will open the display.</dd></dl>
<dl class="section user"><dt></dt><dd>The font is identified by a <code>face</code> and a <code>size</code>. The size of the font is measured in <a class="el" href="drawing.html#drawing_DrawingUnit">FLTK units</a> and not "points". Lines should be spaced <code>size</code> FLTK units apart or more.</dd></dl>
<p>int fl_font() <br  />
 int fl_size()</p>
<dl class="section user"><dt></dt><dd>Returns the face and size set by the most recent call to <code>fl_font(a,b)</code>. This can be used to save/restore the font.</dd></dl>
<h2><a class="anchor" id="drawing_character_encoding"></a>
Character Encoding</h2>
<p>FLTK 1.3 and later versions expect all text in Unicode UTF-8 encoding. UTF-8 is ASCII compatible for the first 128 characters. International characters are encoded in multibyte sequences.</p>
<p>FLTK expects individual characters, characters that are not part of a string, in UCS-4 encoding, which is also ASCII compatible, but requires 4 bytes to store a Unicode character.</p>
<p>FLTK can draw accurately any Unicode-supported script for which the system contains relevant fonts. Under X11 platforms, this requires to build the library with the FLTK_USE_PANGO CMake option turned On (or with configure &ndash;enable-pango).</p>
<p>Plain text drawing starting at a user-given coordinate is well supported by FLTK, including for right-to-left scripts. Further text-related operations (i.e., selection, formatting, input, and editing) are functional with left-to-right scripts only.</p>
<p>For more information about character encodings, see the chapter on <a class="el" href="unicode.html">Unicode and UTF-8 Support</a>.</p>
<h2><a class="anchor" id="drawing_overlay"></a>
Drawing Overlays</h2>
<p>These functions allow you to draw interactive selection rectangles without using the overlay hardware. FLTK will XOR a single rectangle outline over a window.</p>
<p>void fl_overlay_rect(int x, int y, int w, int h) <br  />
 void fl_overlay_clear()</p>
<dl class="section user"><dt></dt><dd><code>fl_overlay_rect</code>() draws a selection rectangle, erasing any previous rectangle by XOR'ing it first. <code>fl_overlay_clear</code>() will erase the rectangle without drawing a new one.</dd></dl>
<dl class="section user"><dt></dt><dd>Using these functions is tricky. You should make a widget with both a <code>handle()</code> and <code>draw()</code> method. <code>draw()</code> should call <code>fl_overlay_clear</code>() before doing anything else. Your <code>handle()</code> method should call <code><a class="el" href="classwindow.html">window()</a>-&gt;make_current()</code> and then <code>fl_overlay_rect</code>() after FL_DRAG events, and should call <code>fl_overlay_clear</code>() after a FL_RELEASE event.</dd></dl>
<h1><a class="anchor" id="drawing_images"></a>
Drawing Images</h1>
<p>To draw images, you can either do it directly from data in your memory, or you can create a Fl_Image object. The advantage of drawing directly is that it is more intuitive, and it is faster if the image data changes more often than it is redrawn. The advantage of using the object is that FLTK will cache translated forms of the image (on X it uses a server pixmap) and thus redrawing is <em>much</em> faster.</p>
<h2><a class="anchor" id="drawing_direct_image_drawing"></a>
Direct Image Drawing</h2>
<p>The behavior when drawing images when the current transformation matrix is not the identity is not defined, so you should only draw images when the matrix is set to the identity.</p>
<p><a class="anchor" id="drawing_fl_draw_image"></a>void fl_draw_image(const uchar *buf,int X,int Y,int W,int H,int D,int L)<br  />
 void fl_draw_image_mono(const uchar *buf,int X,int Y,int W,int H,int D,int L)</p>
<dl class="section user"><dt></dt><dd>Draw an 8-bit per color RGB or luminance image. The pointer points at the "r" data of the top-left pixel. Color data must be in <code>r,g,b</code> order. The top left corner is given by <code>X</code> and <code>Y</code> and the size of the image is given by <code>W</code> and <code>H</code>. <code>D</code> is the delta to add to the pointer between pixels, it may be any value greater or equal to <code>3</code>, or it can be negative to flip the image horizontally. <code>L</code> is the delta to add to the pointer between lines (if 0 is passed it uses <code>W*D</code>). and may be larger than <code>W*D</code> to crop data, or negative to flip the image vertically.</dd></dl>
<dl class="section user"><dt></dt><dd>It is highly recommended that you put the following code before the first show() of <em>any</em> window in your program to get rid of the dithering if possible:</dd></dl>
<div class="fragment"><div class="line">Fl::visual(FL_RGB);</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>Gray scale (1-channel) images may be drawn. This is done if <code>abs(D)</code> is less than 3, or by calling <code>fl_draw_image_mono</code>(). Only one 8-bit sample is used for each pixel, and on screens with different numbers of bits for red, green, and blue only gray colors are used. Setting <code>D</code> greater than 1 will let you display one channel of a color image.</dd></dl>
<dl class="section user"><dt></dt><dd><b>Note:</b> The X version does not support all possible visuals. If FLTK cannot draw the image in the current visual it will abort. FLTK supports any visual of 8 bits or less, and all common TrueColor visuals up to 32 bits.</dd></dl>
<p>typedef void (*Fl_Draw_Image_Cb)(void *data,int x,int y,int w,uchar *buf) <br  />
 void fl_draw_image(Fl_Draw_Image_Cb cb,void *data,int X,int Y,int W,int H,int D) <br  />
 void fl_draw_image_mono(Fl_Draw_Image_Cb cb,void *data,int X,int Y,int W,int H,int D)</p>
<dl class="section user"><dt></dt><dd>Call the passed function to provide each scan line of the image. This lets you generate the image as it is being drawn, or do arbitrary decompression of stored data, provided it can be decompressed to individual scan lines easily.</dd></dl>
<dl class="section user"><dt></dt><dd>The callback is called with the <code>void*</code> user data pointer which can be used to point at a structure of information about the image, and the <code>x</code>, <code>y</code>, and <code>w</code> of the scan line desired from the image. 0,0 is the upper-left corner of the image, <em>not <code>X,Y</code></em>. A pointer to a buffer to put the data into is passed. You must copy <code>w</code> pixels from scanline <code>y</code>, starting at pixel <code>x</code>, to this buffer.</dd></dl>
<dl class="section user"><dt></dt><dd>Due to cropping, less than the whole image may be requested. So <code>x</code> may be greater than zero, the first <code>y</code> may be greater than zero, and <code>w</code> may be less than <code>W</code>. The buffer is long enough to store the entire <code>W*D</code> pixels, this is for convenience with some decompression schemes where you must decompress the entire line at once: decompress it into the buffer, and then if <code>x</code> is not zero, copy the data over so the <code>x'th</code> pixel is at the start of the buffer.</dd></dl>
<dl class="section user"><dt></dt><dd>You can assume the <code>y's</code> will be consecutive, except the first one may be greater than zero.</dd></dl>
<dl class="section user"><dt></dt><dd>If <code>D</code> is 4 or more, you must fill in the unused bytes with zero.</dd></dl>
<p>int fl_draw_pixmap(char* const* data, int x, int y, Fl_Color bg) <br  />
 int fl_draw_pixmap(const char* const* cdata, int x, int y, Fl_Color bg)</p>
<dl class="section user"><dt></dt><dd>Draws XPM image data, with the top-left corner at the given position. The image is dithered on 8-bit displays so you won't lose color space for programs displaying both images and pixmaps. This function returns zero if there was any error decoding the XPM data.</dd></dl>
<dl class="section user"><dt></dt><dd>To use an XPM, do:</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;foo.xpm&quot;</span></div>
<div class="line">...</div>
<div class="line">fl_draw_pixmap(foo, X, Y);</div>
</div><!-- fragment --><dl class="section user"><dt></dt><dd>Transparent colors are replaced by the optional Fl_Color argument. To draw with true transparency you must use the Fl_Pixmap class.</dd></dl>
<p>int fl_measure_pixmap(char* const* data, int &amp;w, int &amp;h) <br  />
 int fl_measure_pixmap(const char* const* cdata, int &amp;w, int &amp;h)</p>
<dl class="section user"><dt></dt><dd>An XPM image contains the dimensions in its data. This function finds and returns the width and height. The return value is non-zero if the dimensions were parsed ok and zero if there was any problem.</dd></dl>
<h2><a class="anchor" id="drawing_direct_image_reading"></a>
Direct Image Reading</h2>
<p>FLTK provides a single function for reading from the current window or off-screen buffer into a RGB(A) image buffer.</p>
<p>uchar* fl_read_image(uchar *p, int X, int Y, int W, int H, int alpha)</p>
<dl class="section user"><dt></dt><dd>Read a RGB(A) image from the current window or off-screen buffer. The <code>p</code> argument points to a buffer that can hold the image and must be at least <code>W*H*3</code> bytes when reading RGB images and <code>W*H*4</code> bytes when reading RGBA images. If <code>NULL</code>, <code>fl_read_image</code>() will create an array of the proper size which can be freed using <code>delete</code>[].</dd></dl>
<dl class="section user"><dt></dt><dd>The <code>alpha</code> parameter controls whether an alpha channel is created and the value that is placed in the alpha channel. If 0, no alpha channel is generated.</dd></dl>
<h2><a class="anchor" id="drawing_Fl_Image"></a>
Image Classes</h2>
<p>FLTK provides a base image class called Fl_Image which supports creating, copying, and drawing images of various kinds, along with some basic color operations. Images can be used as labels for widgets using the <code>image()</code> and <code>deimage()</code> methods or drawn directly. Images can be drawn scaled to any size, independently from the size of the image's data (see Fl_Image::scale()).</p>
<p>The Fl_Image class does almost nothing by itself, but is instead supported by three basic image types:</p>
<ul>
<li>Fl_Bitmap </li>
<li>Fl_Pixmap </li>
<li>Fl_RGB_Image</li>
</ul>
<p>The Fl_Bitmap class encapsulates a mono-color bitmap image. The <code>draw()</code> method draws the image using the current drawing color.</p>
<p>The Fl_Pixmap class encapsulates a colormapped image. The <code>draw()</code> method draws the image using the colors in the file, and masks off any transparent colors automatically.</p>
<p>The Fl_RGB_Image class encapsulates a full-color (or grayscale) image with 1 to 4 color components. Images with an even number of components are assumed to contain an alpha channel that is used for transparency. The transparency provided by the draw() method is either a 24-bit blend against the existing window contents or a "screen door" transparency mask, depending on the platform and screen color depth.</p>
<p>char fl_can_do_alpha_blending()</p>
<dl class="section user"><dt></dt><dd><code>fl_can_do_alpha_blending</code>() will return 1, if your platform supports true alpha blending for RGBA images, or 0, if FLTK will use screen door transparency.</dd></dl>
<p>FLTK also provides several image classes based on the three standard image types for common file formats:</p>
<ul>
<li>Fl_GIF_Image </li>
<li><a class="el" href="classFl__Anim__GIF__Image.html">Fl_Anim_GIF_Image</a> </li>
<li>Fl_JPEG_Image </li>
<li>Fl_PNG_Image </li>
<li>Fl_PNM_Image </li>
<li>Fl_XBM_Image </li>
<li>Fl_XPM_Image </li>
<li>Fl_SVG_Image </li>
<li>Fl_BMP_Image </li>
<li>Fl_ICO_Image</li>
</ul>
<p>Each of these image classes loads a named file of the corresponding format. The Fl_Shared_Image class can be used to load any type of image file - the class examines the file and constructs an image of the appropriate type.</p>
<p>Finally, FLTK provides a special image class called Fl_Tiled_Image to tile another image object in the specified area. This class can be used to tile a background image in a Fl_Group widget, for example.</p>
<p>virtual Fl_Image* Fl_Image::copy() <br  />
 virtual Fl_Image* Fl_Image::copy(int W, int H) const</p>
<dl class="section user"><dt></dt><dd>The <code>copy()</code> method creates a copy of the image. The second form specifies the new size of the image - the image is resized using the nearest-neighbor algorithm (this is the default).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>As of FLTK 1.3.3 the image resizing algorithm can be changed. See Fl_Image::RGB_scaling(Fl_RGB_Scaling method)</dd></dl>
<p>virtual void Fl_Image::draw(int x, int y, int w, int h, int ox, int oy)</p>
<dl class="section user"><dt></dt><dd>The <code>draw()</code> method draws the image object. <code>x,y,w,h</code> indicates the destination rectangle. <code>ox,oy,w,h</code> is the source rectangle. This source rectangle is copied to the destination. The source rectangle may extend outside the image, i.e. <code>ox</code> and <code>oy</code> may be negative and <code>w</code> and <code>h</code> may be bigger than the image, and this area is left unchanged.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See exceptions for Fl_Tiled_Image::draw() regarding arguments <code>ox</code>, <code>oy</code>, <code>w</code>, and <code>h</code>.</dd></dl>
<p>virtual void Fl_Image::draw(int x, int y)</p>
<dl class="section user"><dt></dt><dd>Draws the image with the upper-left corner at <code>x, y</code>. This is the same as doing <code>img-&gt;draw(x, y, img-&gt;w(), img-&gt;h(), 0, 0)</code> where img is a pointer to any Fl_Image type.</dd></dl>
<h1><a class="anchor" id="drawing_offscreen"></a>
Offscreen Drawing</h1>
<p>Sometimes it can be very useful to generate a complex drawing in memory first and copy it to the screen at a later point in time. This technique can significantly reduce the amount of repeated drawing. Offscreen drawing functions are declared in &lt;FL/fl_draw.H&gt;.</p>
<p>Fl_Double_Window uses offscreen rendering to avoid flickering on systems that don't support double-buffering natively.</p>
<p>FLTK can draw into an offscreen buffer at any time. There is no need to wait for an Fl_Widget::draw() to occur.</p>
<dl class="section note"><dt>Note</dt><dd>In FLTK 1.3.x and earlier versions all offscreen drawing functions described below were implemented as macros and created certain temporary variables to save context information. You needed to create local scope blocks with curly braces { ... } if you used offscreen functions more than once in a function or method. This is no longer necessary since offscreen drawing is now implemented in real functions (no macros).</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Fl_Offscreen oscr = <a class="code hl_function" href="group__fl__drawings.html#ga22259d434be43b30f74bfb3e96c5fdab">fl_create_offscreen</a>(120, 120);</div>
<div class="line"><a class="code hl_function" href="group__fl__drawings.html#ga13b7fd0b4efda44b3e5072f43c5ee168">fl_begin_offscreen</a>(oscr);</div>
<div class="line">fl_color(FL_WHITE);</div>
<div class="line">fl_rectf(0, 0, 120, 120);</div>
<div class="line"><a class="code hl_function" href="group__fl__drawings.html#gac2195ac3bd679bac0b2810c8ac90faa6">fl_end_offscreen</a>();</div>
<div class="line"><span class="comment">// other code here</span></div>
<div class="line"><a class="code hl_function" href="group__fl__drawings.html#ga13b7fd0b4efda44b3e5072f43c5ee168">fl_begin_offscreen</a>(oscr);</div>
<div class="line">fl_color(FL_BLACK);</div>
<div class="line">fl_rectf(10, 10, 100, 100);</div>
<div class="line"><a class="code hl_function" href="group__fl__drawings.html#gac2195ac3bd679bac0b2810c8ac90faa6">fl_end_offscreen</a>();</div>
<div class="line"><span class="comment">// other code here</span></div>
<div class="line"><a class="code hl_function" href="group__fl__drawings.html#ga785ac58171dc8843150dd075861a27db">fl_delete_offscreen</a>(oscr);</div>
<div class="ttc" id="agroup__fl__drawings_html_ga13b7fd0b4efda44b3e5072f43c5ee168"><div class="ttname"><a href="group__fl__drawings.html#ga13b7fd0b4efda44b3e5072f43c5ee168">fl_begin_offscreen</a></div><div class="ttdeci">void fl_begin_offscreen(Fl_Offscreen ctx)</div><div class="ttdef"><b>Definition</b> Fl_Image_Surface.cxx:331</div></div>
<div class="ttc" id="agroup__fl__drawings_html_ga22259d434be43b30f74bfb3e96c5fdab"><div class="ttname"><a href="group__fl__drawings.html#ga22259d434be43b30f74bfb3e96c5fdab">fl_create_offscreen</a></div><div class="ttdeci">Fl_Offscreen fl_create_offscreen(int w, int h)</div><div class="ttdef"><b>Definition</b> Fl_Image_Surface.cxx:306</div></div>
<div class="ttc" id="agroup__fl__drawings_html_ga785ac58171dc8843150dd075861a27db"><div class="ttname"><a href="group__fl__drawings.html#ga785ac58171dc8843150dd075861a27db">fl_delete_offscreen</a></div><div class="ttdeci">void fl_delete_offscreen(Fl_Offscreen ctx)</div><div class="ttdef"><b>Definition</b> Fl_Image_Surface.cxx:316</div></div>
<div class="ttc" id="agroup__fl__drawings_html_gac2195ac3bd679bac0b2810c8ac90faa6"><div class="ttname"><a href="group__fl__drawings.html#gac2195ac3bd679bac0b2810c8ac90faa6">fl_end_offscreen</a></div><div class="ttdeci">void fl_end_offscreen()</div><div class="ttdef"><b>Definition</b> Fl_Image_Surface.cxx:342</div></div>
</div><!-- fragment --><p>Fl_Offscreen <a class="el" href="group__fl__drawings.html#ga22259d434be43b30f74bfb3e96c5fdab">fl_create_offscreen(int w, int h)</a></p>
<dl class="section user"><dt></dt><dd>Create an RGB offscreen buffer containing as many pixels as in a screen area of size <code>w</code>,h <a class="el" href="drawing.html#drawing_DrawingUnit">FLTK units</a>.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga785ac58171dc8843150dd075861a27db">fl_delete_offscreen(Fl_Offscreen)</a></p>
<dl class="section user"><dt></dt><dd>Delete a previously created offscreen buffer. All drawings are lost.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga13b7fd0b4efda44b3e5072f43c5ee168">fl_begin_offscreen(Fl_Offscreen)</a></p>
<dl class="section user"><dt></dt><dd>Send all subsequent drawing commands to this offscreen buffer.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#gac2195ac3bd679bac0b2810c8ac90faa6">fl_end_offscreen()</a></p>
<dl class="section user"><dt></dt><dd>Quit sending drawing commands to this offscreen buffer.</dd></dl>
<p>void fl_copy_offscreen(int x, int y, int w, int h, Fl_Offscreen osrc, int srcx, int srcy)</p>
<dl class="section user"><dt></dt><dd>Copy a rectangular area of the size <code>w*h</code> from <code>srcx</code>,srcy in the offscreen buffer into the current drawing surface at <code>x</code>,y.</dd></dl>
<p>void <a class="el" href="group__fl__drawings.html#ga3f790f7afb6b4a2ee640087a3f9a2b89">fl_rescale_offscreen(Fl_Offscreen &amp;osrc)</a> </p><dl class="section user"><dt></dt><dd>Adapts the offscreen's size in pixels to a changed value of the scale factor while keeping the offscreen's graphical content.</dd></dl>
<p> 
<hr>
<table summary="navigation bar" width="100%" border="0">
<tr>
  <td width="45%" align="LEFT">
    <a class="el" href="editor.html">
    [Prev]
    Designing a Simple Text Editor
    </a>
  </td>
  <td width="10%" align="CENTER">
    <a class="el" href="index.html">[Index]</a>
  </td>
  <td width="45%" align="RIGHT">
    <a class="el" href="events.html">
    Handling Events
    [Next]
    </a>
  </td>
</tr>
</table>
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
